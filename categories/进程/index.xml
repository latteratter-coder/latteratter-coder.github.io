<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>进程 on 二进制</title><link>https://zhangquanhua1.github.io/categories/%E8%BF%9B%E7%A8%8B/</link><description>Recent content in 进程 on 二进制</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 06 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://zhangquanhua1.github.io/categories/%E8%BF%9B%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux内核启动流程</title><link>https://zhangquanhua1.github.io/p/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 06 Sep 2025 00:00:00 +0000</pubDate><guid>https://zhangquanhua1.github.io/p/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>&lt;h1 id="加电复位cpu的本能"&gt;加电复位：CPU的&amp;quot;本能&amp;quot;
&lt;/h1&gt;&lt;p&gt;当按下开机键，CPU获得电力后，其行为由硬件设计预先决定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重置寄存器&lt;/strong&gt;：将所有内部寄存器设置为已知的初始状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进入实模式&lt;/strong&gt;：x86架构CPU会进入&lt;strong&gt;实模式（Real Mode）&lt;/strong&gt;，在此模式下可直接访问最初的1MB内存，无内存保护或权限分级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行第一条指令&lt;/strong&gt;：CPU的程序计数器（CS:IP寄存器）被硬编码指向内存地址 &lt;strong&gt;&lt;code&gt;0xFFFF0&lt;/code&gt;&lt;/strong&gt;。该地址位于主板的&lt;strong&gt;BIOS&lt;/strong&gt;（或现代计算机的&lt;strong&gt;UEFI&lt;/strong&gt;）固件芯片中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;至此，CPU只是机械地执行硬件设计好的步骤，对&amp;quot;内核&amp;quot;一无所知。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id="第一棒固件biosuefi"&gt;第一棒：固件（BIOS/UEFI）
&lt;/h1&gt;&lt;p&gt;CPU开始执行固件中的代码，其主要任务是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;硬件自检（POST）&lt;/strong&gt;：检查关键硬件（内存、显卡、键盘等）是否正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化硬件&lt;/strong&gt;：配置主板芯片组、磁盘控制器等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寻找引导程序&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BIOS&lt;/strong&gt;：按照预设顺序（如：U盘-&amp;gt;硬盘）读取存储设备的&lt;strong&gt;第一个扇区（512字节）&lt;/strong&gt;，即&lt;strong&gt;主引导记录（MBR）&lt;/strong&gt;，并将其加载到内存地址 &lt;strong&gt;&lt;code&gt;0x7C00&lt;/code&gt;&lt;/strong&gt; 处。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UEFI&lt;/strong&gt;：更先进，直接从&lt;strong&gt;EFI系统分区&lt;/strong&gt;中查找并加载扩展性更强的引导程序文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;移交控制权&lt;/strong&gt;：CPU跳转到 &lt;code&gt;0x7C00&lt;/code&gt;（或UEFI加载的引导程序地址），开始执行引导程序代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="第二棒引导程序bootloader"&gt;第二棒：引导程序（Bootloader）
&lt;/h1&gt;&lt;p&gt;MBR中的空间很小，通常只存放引导程序的&lt;strong&gt;第一阶段&lt;/strong&gt;。其核心任务是加载功能更全的&lt;strong&gt;第二阶段&lt;/strong&gt;引导程序（如GRUB、Windows Boot Manager）。&lt;/p&gt;
&lt;p&gt;第二阶段引导程序的工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提供菜单&lt;/strong&gt;：允许用户选择要启动的操作系统（如果有多个）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;识别文件系统&lt;/strong&gt;：具备解析磁盘文件系统（如EXT4, NTFS）的能力，而不仅仅是读写原始扇区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加载内核映像&lt;/strong&gt;：根据配置，从文件系统中找到&lt;strong&gt;内核文件&lt;/strong&gt;（如Linux的 &lt;code&gt;/boot/vmlinuz-xxx&lt;/code&gt;），并将其读取到内存中合适的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;准备内核运行环境&lt;/strong&gt;：设置启动参数（如根文件系统位置、分辨率）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;切换CPU模式&lt;/strong&gt;：将CPU从&lt;strong&gt;实模式&lt;/strong&gt;切换到现代的&lt;strong&gt;保护模式（Protected Mode）&lt;/strong&gt; 或 &lt;strong&gt;长模式（Long Mode, 64位）&lt;/strong&gt;，以启用虚拟内存、权限保护等关键特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跳转到内核&lt;/strong&gt;：最后，引导程序&lt;strong&gt;跳转（jump）&lt;/strong&gt; 到内核在内存中的入口地址，将控制权彻底交给内核。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;引导程序是内核的&amp;quot;引路人&amp;quot;，完成了从&amp;quot;找扇区&amp;quot;到&amp;quot;找文件&amp;quot;的关键跨越。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id="第三棒内核启动与初始化"&gt;第三棒：内核启动与初始化
&lt;/h1&gt;&lt;p&gt;内核启动是一个复杂的过程，可分为两个主要阶段：&lt;/p&gt;
&lt;h2 id="第一阶段架构相关初始化汇编"&gt;第一阶段：架构相关初始化（汇编）
&lt;/h2&gt;&lt;p&gt;这是内核最先执行的代码，直接与CPU硬件交互，通常用汇编语言编写：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置初始堆栈&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清除BSS段&lt;/strong&gt;：将未初始化的全局变量区域清零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解压内核&lt;/strong&gt;（如果需要）：许多发行版的内核映像是压缩过的（如&lt;code&gt;vmlinuz&lt;/code&gt;），此阶段会进行自解压。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启用分页（Paging）&lt;/strong&gt;：建立初始页表，开启MMU（内存管理单元），让CPU使用&lt;strong&gt;虚拟内存地址&lt;/strong&gt;。这是现代操作系统的基石。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置中断描述符表（IDT）&lt;/strong&gt;：为处理硬件中断、异常和系统调用做好准备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跳转到主入口点&lt;/strong&gt;：最终跳转到如 &lt;code&gt;start_kernel()&lt;/code&gt; 这样的C语言函数，进入内核主体。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="第二阶段通用内核初始化c语言"&gt;第二阶段：通用内核初始化（C语言）
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;start_kernel()&lt;/code&gt; 是内核初始化的&amp;quot;主函数&amp;quot;，它调用一系列初始化函数来构建整个操作系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sched_init()&lt;/code&gt;: 初始化&lt;strong&gt;调度器&lt;/strong&gt;，创建0号进程（&lt;code&gt;idle&lt;/code&gt;进程）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mm_init()&lt;/code&gt;: 初始化&lt;strong&gt;内存管理&lt;/strong&gt;系统（伙伴系统、slab分配器）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;trap_init()&lt;/code&gt; / &lt;code&gt;init_IRQ()&lt;/code&gt;: 完善&lt;strong&gt;中断和异常处理&lt;/strong&gt;机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;time_init()&lt;/code&gt;: 初始化&lt;strong&gt;系统时钟&lt;/strong&gt;，内核开始感知时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vfs_caches_init()&lt;/code&gt;: 初始化&lt;strong&gt;虚拟文件系统（VFS）&lt;/strong&gt;，为挂载根文件系统做准备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;挂载根文件系统&lt;/strong&gt;：可能先挂载内存中的&lt;code&gt;initramfs&lt;/code&gt;（临时根文件系统）来加载必要驱动，再挂载真正的根文件系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动第一个用户空间进程&lt;/strong&gt;：这是内核初始化的&lt;strong&gt;最后一步&lt;/strong&gt;。内核线程会尝试执行用户空间的 &lt;code&gt;/sbin/init&lt;/code&gt;（或其链接，如 &lt;code&gt;/lib/systemd/systemd&lt;/code&gt;）。这个进程成为所有用户进程的祖先（PID 1）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一旦 &lt;code&gt;/sbin/init&lt;/code&gt; 被执行，内核的启动过程就正式结束，控制权交给了用户空间。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id="内核启动后它是后台运行吗"&gt;内核启动后，它是后台运行吗？
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;答案是：否。内核不是一个在&amp;quot;后台&amp;quot;运行的进程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个关键区别。内核的运行方式与普通程序（前台或后台）有本质不同：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内核是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常驻内存的代码和数据&lt;/strong&gt;：内核始终驻留在物理内存的受保护区域（内核空间）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;被动的执行环境和服务提供者&lt;/strong&gt;：内核自身不会主动持续运行。它的代码在以下三种情况下被&lt;strong&gt;被动调用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统调用（Syscall）&lt;/strong&gt;：应用程序主动请求操作系统服务（如读写文件），通过指令（如&lt;code&gt;syscall&lt;/code&gt;）陷入内核。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;硬件中断（Interrupt）&lt;/strong&gt;：硬件设备需要CPU关注（如网卡收到数据、时钟滴答），触发CPU执行对应的&lt;strong&gt;中断处理程序&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异常（Exception）&lt;/strong&gt;：CPU执行指令时发生错误（如除零），由内核的异常处理程序处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;所有进程的&amp;quot;底层&amp;quot;&lt;/strong&gt;：每个用户进程都像是在内核这个&amp;quot;地基&amp;quot;上建立的&amp;quot;房子&amp;quot;。当需要执行特权操作时，进程就&amp;quot;陷入&amp;quot;地基（内核）中寻求帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特征&lt;/th&gt;
&lt;th&gt;用户进程（前台/后台）&lt;/th&gt;
&lt;th&gt;内核&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;运行方式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;主动执行自己的代码流&lt;/td&gt;
&lt;td&gt;被动响应（系统调用、中断、异常）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存在形式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;进程列表中的一个实体&lt;/td&gt;
&lt;td&gt;常驻内存的代码和数据结构，是进程运行的&lt;strong&gt;环境&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CPU模式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;用户态&lt;/td&gt;
&lt;td&gt;内核态（当被调用时）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;如何结束&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;调用&lt;code&gt;exit()&lt;/code&gt;或被杀掉&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;永不结束&lt;/strong&gt;，直到计算机关机&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="总结与类比"&gt;总结与类比
&lt;/h1&gt;&lt;p&gt;计算机启动过程就像一场精心设计的接力赛：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU&lt;/strong&gt;：是运动员，只有跑步的本能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BIOS/UEFI&lt;/strong&gt;：是第一棒教练（接生婆），确保运动员健康并把他交给下一棒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;引导程序（GRUB等）&lt;/strong&gt;：是第二棒领跑员（家庭教师），带领运动员到正确的位置并交棒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内核&lt;/strong&gt;：是第三棒运动员兼体育场建筑师（大学），它接管比赛，并首先建造整个体育场（初始化系统），然后制定规则（系统调用），裁判比赛（调度进程）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;init&lt;/code&gt; / &lt;code&gt;systemd&lt;/code&gt;&lt;/strong&gt;：是赛后活动组织者，根据规则启动各种游戏和服务（用户进程）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核并非后台守护进程，而是&lt;strong&gt;系统的基石&lt;/strong&gt;。它静默地存在于内存中，等待被应用程序和硬件事件调用，从而为所有程序提供安全、可靠、统一的硬件访问和管理服务。&lt;/p&gt;</description></item><item><title>内核是如何管理进程的</title><link>https://zhangquanhua1.github.io/p/%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E7%9A%84/</link><pubDate>Sat, 06 Sep 2025 00:00:00 +0000</pubDate><guid>https://zhangquanhua1.github.io/p/%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E7%9A%84/</guid><description>&lt;p&gt;内核管理进程的核心可以概括为：&lt;strong&gt;“一抽象，两分离，四管理”&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一抽象&lt;/strong&gt;：将运行中的程序抽象为&lt;strong&gt;进程（Process）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;两分离&lt;/strong&gt;：实现&lt;strong&gt;CPU虚拟化&lt;/strong&gt;（分时复用）和&lt;strong&gt;内存虚拟化&lt;/strong&gt;（每个进程有独立的地址空间）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;四管理&lt;/strong&gt;：通过&lt;strong&gt;进程描述符（PCB）&lt;/strong&gt;、&lt;strong&gt;进程调度&lt;/strong&gt;、&lt;strong&gt;内存管理&lt;/strong&gt;和&lt;strong&gt;进程间通信（IPC）&lt;/strong&gt; 这四大机制来具体实现管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们详细展开。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="1-进程的抽象进程描述符pcb"&gt;1. 进程的抽象：进程描述符（PCB）
&lt;/h1&gt;&lt;p&gt;内核要管理进程，首先必须能&lt;strong&gt;描述&lt;/strong&gt;一个进程。内核通过一个称为&lt;strong&gt;进程控制块（PCB, Process Control Block）&lt;/strong&gt; 的数据结构来代表一个进程。在Linux中，这就是 &lt;code&gt;task_struct&lt;/code&gt; 结构体（非常庞大，包含上百个字段）。&lt;/p&gt;
&lt;p&gt;这个结构体是内核管理进程的&lt;strong&gt;核心&lt;/strong&gt;，它就像一个进程的“户口本”或“病历”，记录了关于该进程的一切信息，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程标识符（PID）&lt;/strong&gt;：唯一的身份证，用于区分不同进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程状态&lt;/strong&gt;：运行、就绪、睡眠、僵尸状态等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;程序计数器（PC）&lt;/strong&gt;：记录下一条要执行的指令地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU寄存器&lt;/strong&gt;：当进程被切换时，需要保存当前的寄存器状态，以便下次恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存管理信息&lt;/strong&gt;：指向页表（Page Table）的指针，这是实现虚拟内存的关键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;文件描述符表&lt;/strong&gt;：记录该进程打开了哪些文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源使用信息&lt;/strong&gt;：CPU时间、内存使用量等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优先级&lt;/strong&gt;：用于调度器决定谁先运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程间关系&lt;/strong&gt;：父进程、子进程、兄弟进程等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;内核将所有进程的PCB通过链表或树等数据结构组织起来&lt;/strong&gt;。因此，管理进程在很大程度上就是管理这些 &lt;code&gt;task_struct&lt;/code&gt; 结构体。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="2-进程的生命周期管理状态机"&gt;2. 进程的生命周期管理（状态机）
&lt;/h1&gt;&lt;p&gt;进程并非从生到死都在运行。内核为其定义了一系列状态（State），形成一个状态机：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;就绪（Ready）&lt;/strong&gt;：进程已准备好，只等调度器分配CPU即可运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行（Running）&lt;/strong&gt;：进程正在CPU上执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;阻塞/睡眠（Blocked/Sleeping）&lt;/strong&gt;：进程在等待某个事件（如等待用户输入、等待磁盘IO完成），此时它不需要CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;僵尸（Zombie）&lt;/strong&gt;：进程已终止，但其PCB还未被父进程回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;终止（Terminated）&lt;/strong&gt;：进程结束，所有资源被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核负责根据事件（如IO完成、时间片用完）来驱动进程在这些状态间转换。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="3-cpu虚拟化进程调度scheduling"&gt;3. CPU虚拟化：进程调度（Scheduling）
&lt;/h1&gt;&lt;p&gt;CPU核心数远少于进程数，内核通过&lt;strong&gt;调度器（Scheduler）&lt;/strong&gt; 来制造“每个进程都在同时运行”的假象，即&lt;strong&gt;分时复用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调度器的工作流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择&lt;/strong&gt;：从就绪队列中，根据特定的&lt;strong&gt;调度算法&lt;/strong&gt;（如CFS-完全公平调度器）选择一个最值得运行的进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;切换&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上下文切换（Context Switch）&lt;/strong&gt;：将当前运行进程的状态（寄存器、PC等）保存到其PCB中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加载&lt;/strong&gt;：将下一个要运行进程的状态从其PCB中加载到CPU寄存器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换&lt;strong&gt;页表&lt;/strong&gt;，从而切换内存地址空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行&lt;/strong&gt;：CPU开始执行新进程的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;触发调度的时机：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主动让出&lt;/strong&gt;：进程执行系统调用（如&lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;等待IO）或主动&lt;code&gt;yield&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;被动抢占&lt;/strong&gt;：硬件时钟中断发生，调度器检查当前进程的时间片是否用完，如果用完则强制切换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过频繁的调度和上下文切换，内核实现了多个进程在CPU上的“同时”运行。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="4-内存虚拟化内存管理memory-management"&gt;4. 内存虚拟化：内存管理（Memory Management）
&lt;/h1&gt;&lt;p&gt;每个进程都认为自己独享整个内存空间。这是内核通过&lt;strong&gt;虚拟内存&lt;/strong&gt;机制实现的魔法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内核为每个进程维护一张独立的页表（Page Table）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页表定义了&lt;strong&gt;虚拟地址&lt;/strong&gt;到&lt;strong&gt;物理地址&lt;/strong&gt;的映射关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MMU（内存管理单元）在CPU执行指令时，通过查询当前进程的页表来自动完成地址转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这样做的好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;隔离性与保护&lt;/strong&gt;：进程A无法访问进程B的内存，因为它们的虚拟地址映射到不同的物理页。一个进程的崩溃不会影响整个系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简化编程&lt;/strong&gt;：程序员只需关心统一的虚拟地址空间，无需关心物理内存的具体布局。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核的内存管理子系统负责分配和回收物理内存页，并在进程切换时负责切换页表基地址寄存器（如x86的CR3）。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="5-进程间通信ipc-inter-process-communication"&gt;5. 进程间通信（IPC, Inter-Process Communication）
&lt;/h1&gt;&lt;p&gt;进程之间需要协作，但由于内存隔离，它们不能直接访问对方的地址空间。内核提供了多种&lt;strong&gt;进程间通信（IPC）&lt;/strong&gt; 机制来安全地传递数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;管道（Pipe）&lt;/strong&gt;：单向字节流，常用于父子进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消息队列（Message Queue）&lt;/strong&gt;：内核维护的消息链表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;共享内存（Shared Memory）&lt;/strong&gt;：效率最高的方式。内核将同一块物理内存映射到多个进程的虚拟地址空间中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;信号（Signal）&lt;/strong&gt;：一种异步通知机制，用于通知进程某个事件已发生（如&lt;code&gt;kill&lt;/code&gt;命令）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;信号量（Semaphore）&lt;/strong&gt; 和 &lt;strong&gt;互斥锁（Mutex）&lt;/strong&gt;：用于同步对共享资源的访问，防止竞争条件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所有这些机制都由内核提供和管理，确保了通信的安全性和可靠性。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="6-系统调用进程与内核的接口"&gt;6. 系统调用：进程与内核的接口
&lt;/h1&gt;&lt;p&gt;用户进程运行在&lt;strong&gt;用户态&lt;/strong&gt;，权限受限。当它需要请求内核的服务（如创建进程、读写文件、申请内存）时，必须通过&lt;strong&gt;系统调用（System Call）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;系统调用是用户进程主动陷入内核的唯一方式。过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程在寄存器中设置好系统调用号和参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行一条特殊的指令（如&lt;code&gt;syscall&lt;/code&gt;或&lt;code&gt;int 0x80&lt;/code&gt;），触发&lt;strong&gt;软中断&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU切换到内核态，跳转到内核中预先定义好的&lt;strong&gt;系统调用处理函数&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内核验证请求合法性后，代表进程执行所需操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作完成，内核将结果返回给进程，并切换回用户态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;创建新进程的&lt;code&gt;fork()&lt;/code&gt;和加载新程序的&lt;code&gt;execve()&lt;/code&gt;，本身就是两个最重要的系统调用。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id="总结内核如何管理进程"&gt;总结：内核如何管理进程
&lt;/h1&gt;&lt;p&gt;内核通过一个精巧的体系来管理进程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用PCB描述进程&lt;/strong&gt;：为每个进程创建一个&lt;code&gt;task_struct&lt;/code&gt;作为管理元数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用状态机管理生命周期&lt;/strong&gt;：跟踪每个进程处于创建、就绪、运行、阻塞、退出等状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用调度器分配CPU&lt;/strong&gt;：通过上下文切换和分时复用，实现CPU的虚拟化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用页表隔离内存&lt;/strong&gt;：为每个进程提供独立的虚拟地址空间，实现内存的虚拟化和保护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用IPC机制 Facilitate 协作&lt;/strong&gt;：提供管道、共享内存等机制，让隔离的进程能安全通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用系统调用提供接口&lt;/strong&gt;：作为用户进程请求内核服务的唯一入口，保证安全和可控。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终，内核像一位交响乐指挥家，协调着各个进程（乐手），合理分配硬件资源（乐器），让整个系统（乐团）和谐、高效地运行。&lt;/p&gt;</description></item><item><title>加载一个新程序的过程</title><link>https://zhangquanhua1.github.io/p/%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%96%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</link><pubDate>Sat, 06 Sep 2025 00:00:00 +0000</pubDate><guid>https://zhangquanhua1.github.io/p/%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%96%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</guid><description>&lt;h1 id="总体概览"&gt;总体概览
&lt;/h1&gt;&lt;p&gt;加载并执行一个新程序的过程可以概括为以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外壳（Shell）解析命令&lt;/strong&gt;并准备参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fork()&lt;/code&gt;：创建一个新的子进程&lt;/strong&gt;。这个子进程几乎是父进程（如 Shell）的完美复制品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;execve()&lt;/code&gt;：在子进程上下文中执行“程序替换”&lt;/strong&gt;。这是魔法发生的地方：内核停止当前子进程的运行，清空其内存空间（除了一些保留信息），然后将&lt;strong&gt;指定的可执行文件&lt;/strong&gt;加载到该内存空间中，并为其设置全新的运行环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态链接器（如果必要）介入&lt;/strong&gt;，加载程序所依赖的共享库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;程序开始执行&lt;/strong&gt;，从 &lt;code&gt;main()&lt;/code&gt; 函数开始。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个过程的核心是 &lt;code&gt;execve()&lt;/code&gt; 系统调用。下图描绘了这个过程的完整流程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;flowchart TD
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;A[用户在Shell中输入命令] --&amp;gt; B[Shell解析命令&amp;lt;br&amp;gt;调用fork()创建子进程]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;B --&amp;gt; C[子进程调用execve()系统调用]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;C --&amp;gt; D[&amp;#34;内核处理execve()请求&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;subgraph D[内核处理流程]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; D1[验证文件&amp;lt;br&amp;gt;权限、格式等] --&amp;gt; D2[释放旧地址空间&amp;lt;br&amp;gt;“拆毁旧世界”]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; D2 --&amp;gt; D3[加载可执行文件&amp;lt;br&amp;gt;ELF解析、映射文本/数据段等]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; D3 --&amp;gt; D4[设置新堆栈&amp;lt;br&amp;gt;填充参数argv、环境变量envp]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; D4 --&amp;gt; D5[设置寄存器&amp;lt;br&amp;gt;将eip指向入口点]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;end
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;D --&amp;gt; E{&amp;#34;是否为动态链接程序?&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;E -- 是 --&amp;gt; F[载入解释器(ld-linux)&amp;lt;br&amp;gt;由解释器加载所需共享库]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;E -- 否 --&amp;gt; G[跳转到程序入口点_start]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;F --&amp;gt; G
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;G --&amp;gt; H[执行用户程序的main()函数]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;H --&amp;gt; I[程序正常执行]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id="详细过程分析"&gt;详细过程分析
&lt;/h1&gt;&lt;h2 id="第1步shell-的工作用户空间"&gt;第1步：Shell 的工作（用户空间）
&lt;/h2&gt;&lt;p&gt;当你在 Shell 中输入 &lt;code&gt;./my_program arg1 arg2&lt;/code&gt; 后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Shell 解析命令，将 &lt;code&gt;&amp;quot;my_program&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;arg1&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;arg2&amp;quot;&lt;/code&gt; 分别存储起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell 调用 &lt;code&gt;fork()&lt;/code&gt; 系统调用，创建一个几乎是自身副本的子进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="第2步fork--创建进程胚子内核空间"&gt;第2步：&lt;code&gt;fork()&lt;/code&gt; - 创建进程胚子（内核空间）
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt; 系统调用被执行，CPU 陷入内核。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内核创建一个新的&lt;strong&gt;进程描述符（&lt;code&gt;task_struct&lt;/code&gt;）&lt;/strong&gt;，为其分配一个新的 &lt;strong&gt;PID&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内核复制父进程的几乎所有资源给子进程，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存空间&lt;/strong&gt;：通过写时复制（Copy-on-Write, COW）技术，创建一个当前和父进程完全一样的地址空间映射（但实际物理内存页暂时共享）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;打开的文件描述符表&lt;/strong&gt;：子进程也继承了父进程打开的文件（stdin, stdout, stderr等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程上下文&lt;/strong&gt;（寄存器状态等）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在，系统中有了两个几乎一样的进程：父进程（Shell）和子进程。它们都从 &lt;code&gt;fork()&lt;/code&gt; 返回开始执行。&lt;code&gt;fork()&lt;/code&gt; 对父进程返回子进程的 PID，对子进程返回 0。代码可以通过返回值判断自己是父是子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="第3步execve--魔法核心从用户空间到内核空间"&gt;第3步：&lt;code&gt;execve()&lt;/code&gt; - 魔法核心（从用户空间到内核空间）
&lt;/h2&gt;&lt;p&gt;在子进程中，Shell 的子进程副本会调用 &lt;code&gt;execve()&lt;/code&gt; 系统调用，其原型大致如下：&lt;br&gt;
&lt;code&gt;int execve(const char *filename, char *const argv[], char *const envp[]);&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;filename&lt;/code&gt;：要加载的程序路径（&lt;code&gt;&amp;quot;/home/user/my_program&amp;quot;&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;argv&lt;/code&gt;：参数数组（&lt;code&gt;{&amp;quot;my_program&amp;quot;, &amp;quot;arg1&amp;quot;, &amp;quot;arg2&amp;quot;, NULL}&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;envp&lt;/code&gt;：环境变量数组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一旦调用 &lt;code&gt;execve()&lt;/code&gt;，内核就开始执行以下繁重的工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a. 验证与准备&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查文件 &lt;code&gt;filename&lt;/code&gt; 是否存在、是否具有可执行权限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取文件的&lt;strong&gt;头部（Header）&lt;/strong&gt;，识别其格式（例如 ELF、Mach-O、PE）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;b. “拆毁旧世界” - 释放旧地址空间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内核释放子进程当前拥有的几乎所有资源（内存、信号处理函数等）。由于之前用的是写时复制，所以实际复制的物理内存页很少，释放代价低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里会处理一些例外，比如明确设置为“执行时关闭”（&lt;code&gt;close-on-exec&lt;/code&gt;）的文件描述符会被保留，这是进程间通信的重要手段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;c. “建立新世界” - 加载新程序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解析可执行文件&lt;/strong&gt;：以最常见的 ELF 格式为例，内核会解析程序头表（Program Header Table），找到需要加载的段（Segment），如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.text&lt;/code&gt; 段（代码段）：映射到内存的只读可执行区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.data&lt;/code&gt; 段（已初始化数据）：映射到内存的可读写区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.bss&lt;/code&gt; 段（未初始化数据）：映射到初始为零的可读写区域。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;映射到内存&lt;/strong&gt;：内核并不急于将文件内容全部读入物理内存，而是基于&lt;strong&gt;内存映射（mmap）&lt;/strong&gt; 机制，建立虚拟地址到文件偏移的映射关系。只有当程序实际访问某块内存时，才会通过&lt;strong&gt;缺页中断（Page Fault）&lt;/strong&gt; 将对应的文件内容加载到物理内存。这是懒加载（Lazy Loading），非常高效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加载解释器（动态链接器）&lt;/strong&gt;：如果程序是&lt;strong&gt;动态链接&lt;/strong&gt;的（绝大多数都是），ELF 文件中会指定一个“解释器”（Interpreter），通常是 &lt;code&gt;/lib64/ld-linux-x86-64.so.2&lt;/code&gt;。&lt;strong&gt;内核会先将这个动态链接器本身加载到进程的地址空间并映射&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;d. 设置新堆栈和寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置新堆栈&lt;/strong&gt;：内核为进程分配新的用户态堆栈，并将 &lt;code&gt;argv&lt;/code&gt; 和 &lt;code&gt;envp&lt;/code&gt; 中的参数和环境变量字符串压入（或放置到）堆栈的特定位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置寄存器&lt;/strong&gt;：在进程的内核栈中准备一个新的上下文环境。最关键的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;strong&gt;指令指针（EIP/RIP）&lt;/strong&gt; 设置为新程序的&lt;strong&gt;入口点（Entry Point）&lt;/strong&gt;。对于静态链接的程序，入口点就是程序本身的 &lt;code&gt;_start&lt;/code&gt;。对于动态链接的程序，入口点是&lt;strong&gt;动态链接器的入口点&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;strong&gt;栈指针（ESP/RSP）&lt;/strong&gt; 指向新设置的用户堆栈的顶部。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="第4步返回用户空间开始执行"&gt;第4步：返回用户空间，开始执行
&lt;/h2&gt;&lt;p&gt;当 &lt;code&gt;execve()&lt;/code&gt; 系统调用在内核中完成所有准备工作后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;内核将精心准备的新上下文恢复到 CPU 寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 切换回用户态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据设置好的指令指针（EIP/RIP），开始执行代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;现在有两种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;情况A：程序是静态链接的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 直接从程序的 &lt;code&gt;_start&lt;/code&gt; 符号开始执行。&lt;code&gt;_start&lt;/code&gt; 是程序真正的起点，由它来初始化运行环境，最后调用 &lt;code&gt;main()&lt;/code&gt; 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;情况B：程序是动态链接的（绝大多数）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU 首先跳转到&lt;strong&gt;动态链接器（&lt;a class="link" href="https://ld.so/" target="_blank" rel="noopener"
&gt;ld.so&lt;/a&gt;）&lt;/strong&gt; 的入口点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态链接器开始工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;它检查程序依赖哪些共享库（如 &lt;code&gt;libc.so.6&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;mmap()&lt;/code&gt; 将这些共享库也加载到进程的地址空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行&lt;strong&gt;重定位（Relocation）&lt;/strong&gt; 操作，修正程序中所有对共享库函数（如 &lt;code&gt;printf&lt;/code&gt;）的引用地址（将占位符替换为实际加载的地址）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行共享库的初始化代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，动态链接器&lt;strong&gt;跳转到原始程序的 &lt;code&gt;_start&lt;/code&gt; 入口点&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="第5步执行main函数"&gt;第5步：执行 &lt;code&gt;main()&lt;/code&gt; 函数
&lt;/h2&gt;&lt;p&gt;无论是否经过动态链接，最终控制权都会交到程序本身的 &lt;code&gt;_start&lt;/code&gt; 函数。这个函数是由编译器提供的，它负责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置全局变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化标准库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;code&gt;argv&lt;/code&gt; 和 &lt;code&gt;argc&lt;/code&gt; 从堆栈中取出，准备好参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用用户编写的 &lt;code&gt;main(int argc, char *argv[])&lt;/code&gt; 函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此，&lt;strong&gt;你的 &lt;code&gt;main&lt;/code&gt; 函数终于被调用，程序开始执行你写的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id="总结"&gt;总结
&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;步骤&lt;/th&gt;
&lt;th&gt;关键动作&lt;/th&gt;
&lt;th&gt;执行者&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;1. Shell解析&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;解析命令，获取参数&lt;/td&gt;
&lt;td&gt;Shell (用户态)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2. &lt;code&gt;fork()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;创建子进程副本&lt;/td&gt;
&lt;td&gt;内核&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;3. &lt;code&gt;execve()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统调用，陷入内核&lt;/td&gt;
&lt;td&gt;子进程 -&amp;gt; 内核&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;4. 内核处理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;验证文件、释放旧空间、映射新程序、设置堆栈和寄存器&lt;/td&gt;
&lt;td&gt;内核&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;5. 动态链接&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;加载并链接共享库&lt;/td&gt;
&lt;td&gt;动态链接器 &lt;code&gt;ld.so&lt;/code&gt; (用户态)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;6. 程序启动&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;运行 &lt;code&gt;_start&lt;/code&gt;，调用 &lt;code&gt;main()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用户程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以，&lt;code&gt;main&lt;/code&gt; 函数的加载和执行是内核与动态链接器（如果需要）协同工作的结果，是一个“先破后立”的过程：先通过 &lt;code&gt;execve()&lt;/code&gt; 清空当前进程的环境，再为其注入一个全新的程序生命。&lt;/p&gt;</description></item></channel></rss>