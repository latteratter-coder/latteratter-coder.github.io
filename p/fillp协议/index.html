<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="FILLP协议 目录 概述与背景 FILLP协议架构设计 代码文件结构说明 连接建立流程 数据传输流程 流量控制机制 RTT测量机制 重传和可靠性保证 系统调用和性能优化 关键数据结构 FILLP传输协议流程总结 总结和展望 1. 概述与背景 1.1 FILLP协议介绍 FILLP（Fast Internet Low Latency Protocol）是华为开发的一种基于UDP的可靠传输协议，专门为高带宽、长距离网络环境设计。在DSoftBus通信框架中，FILLP作为核心传输协议，提供了高性能的数据传输能力。\n1.2 核心特性 基于UDP的可靠传输：在UDP基础上实现可靠性保障 流控算法：支持多种流控算法(ALG0-ALG3) 快速重传：基于NACK的快速重传机制 高并发支持：支持多连接并发处理 安全机制：基于HMAC-SHA256的Cookie验证 跨平台：支持Linux、Windows等多平台 1.3 适用场景 高带宽长距离传输：卫星通信、跨洋数据传输 实时音视频传输：支持帧级别的数据标识和优先级 文件传输系统：大文件高效可靠传输 分布式存储：数据复制和同步 2. FILLP协议架构设计 2.1 分层架构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ┌─────────────────────────────────────────────────────────────────────────────┐ │ 应用程序 (Application) │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ FtSocket(), FtSend(), FtRecv() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 应用层API (app_lib) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ api.c │ │ socket_app.c │ │ epoll_app.c │ │ │ │ (外部接口) │ │ (Socket实现) │ │ (事件管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SockSend(), SockRecv(), SockConnect() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ FILLP协议核心层 (fillp_lib) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ fillp_conn.c │ │ fillp_input.c │ │ fillp_output.c │ │ │ │ (连接管理) │ │ (数据接收) │ │ (数据发送) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │fillp_flow_ctrl.c│ │ fillp_pcb.c │ │ fillp_frame.c │ │ │ │ (流量控制) │ │ (PCB管理) │ │ (帧处理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SpungePcb管理, NetConn管理 ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 网络抽象层 (Network Layer) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ net.c │ │ pcb.c │ │ spunge_core.c │ │ │ │ (网络连接) │ │ (PCB管理) │ │ (核心管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SysIoSend(), SysIoRecv() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 系统IO抽象层 (SysIO Layer) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ sysio.c │ │ sysio_udp.c │ │ spunge_stack.c │ │ │ │ (IO抽象接口) │ │ (UDP封装) │ │ (协议栈管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ sendto(), recvfrom() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 操作系统 (Operating System) │ │ UDP Socket 系统调用 │ └─────────────────────────────────────────────────────────────────────────────┘ 2.2 核心组件关系图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ┌──────────────────────────────────────────────────────────────────────────────┐ │ FILLP 核心组件关系 │ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ FtSocket │───→│ FtNetconn │───→│ SpungePcb │ │ │ │ (Socket) │ │ (网络连接) │ │ (PCB) │ │ │ └─────────────┘ └─────────────┘ └─────┬───────┘ │ │ │ │ │ │ │ ┌─────────────┐ │ │ │ └───────────→│ EventPoll │ │ │ │ │ (事件轮询) │ │ │ │ └─────────────┘ │ │ │ │ │ │ ┌─────────────┐ │ │ │ │ FillpPcb │←────────┘ │ │ │ (协议PCB) │ │ │ └─────┬───────┘ │ │ │ │ │ ┌──────────────────┼──────────────────┐ │ │ │ │ │ │ │ ┌─────▼─────┐ ┌───────▼─────┐ ┌──────▼──────┐ │ │ │FillpSendPcb│ │FillpRecvPcb │ │FlowControl │ │ │ │ (发送PCB) │ │ (接收PCB) │ │ (流量控制) │ │ │ └───────────┘ └────────────┘ └─────────────┘ │ └──────────────────────────────────────────────────────────────────────────────┘ 2.3 线程模型图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ┌─────────────────────────────────────────────────────────────────────────────┐ │ FILLP 线程模型 │ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ 应用线程 │ │ 协议栈线程 │ │ 定时器线程 │ │ │ │ (App Thread)│ │(Stack Thread)│ │(Timer Thread)│ │ │ │ │ │ │ │ │ │ │ │ FtSend() │──────────│ SendCycle │ │ PackTimer │ │ │ │ FtRecv() │ │ RecvCycle │ │ FcTimer │ │ │ │ FtConnect() │ │ PackCycle │ │KeepAlive │ │ │ │ │ │ │ │ ConnRetry │ │ │ └─────────────┘ └─────┬───────┘ └─────────────┘ │ │ │ │ │ │ │ │ │ │ │ │ ┌────▼────┐ ┌─────▼─────┐ ┌────▼────┐ │ │ │消息队列 │ │ UDP接收 │ │时间轮 │ │ │ │ (MSG) │ │(UDP Recv) │ │(Timing │ │ │ └─────────┘ │ select() │ │ Wheel) │ │ │ │recvfrom() │ └─────────┘ │ │ │sendto() │ │ │ └───────────┘ │ └─────────────────────────────────────────────────────────────────────────────┘ 3. 代码文件结构说明 3.1 主要头文件 (include/) 3.1.1 核心接口文件 fillpinc.h: 主要的API接口定义，包含所有外部调用的函数声明 fillptypes.h: 核心数据类型和结构体定义 fillpcallbacks.h: 系统回调函数类型定义，用于平台抽象 3.2 应用层 (app_lib/) 3.2.1 头文件 (include/) socket_app.h: Socket应用层接口定义 socket_opt.h: Socket选项设置接口 epoll_app.h: Epoll事件管理接口 spunge_app.h: Spunge应用层管理接口 fillp_stack_app_config_in.h: 应用层配置管理 fillp_dfx.h: 诊断和调试功能接口 3.2.2 源码文件 (src/) api.c: 外部API接口实现，包含FtSocket、FtSend、FtRecv等 socket_app.c: Socket应用层实现，处理用户接口调用 socket_opt.c: Socket选项设置实现 epoll_app.c: Epoll事件轮询实现 spunge_app.c: Spunge应用管理实现 fillp_stack_app_config.c: 应用层配置管理实现 fillp_dfx.c: 诊断功能实现 3.3 协议核心层 (fillp_lib/) 3.3.1 核心协议头文件 (include/) 主要协议文件\n"><title>FILLP协议</title><link rel=canonical href=https://latteratter-coder.github.io/p/fillp%E5%8D%8F%E8%AE%AE/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="FILLP协议"><meta property='og:description' content="FILLP协议 目录 概述与背景 FILLP协议架构设计 代码文件结构说明 连接建立流程 数据传输流程 流量控制机制 RTT测量机制 重传和可靠性保证 系统调用和性能优化 关键数据结构 FILLP传输协议流程总结 总结和展望 1. 概述与背景 1.1 FILLP协议介绍 FILLP（Fast Internet Low Latency Protocol）是华为开发的一种基于UDP的可靠传输协议，专门为高带宽、长距离网络环境设计。在DSoftBus通信框架中，FILLP作为核心传输协议，提供了高性能的数据传输能力。\n1.2 核心特性 基于UDP的可靠传输：在UDP基础上实现可靠性保障 流控算法：支持多种流控算法(ALG0-ALG3) 快速重传：基于NACK的快速重传机制 高并发支持：支持多连接并发处理 安全机制：基于HMAC-SHA256的Cookie验证 跨平台：支持Linux、Windows等多平台 1.3 适用场景 高带宽长距离传输：卫星通信、跨洋数据传输 实时音视频传输：支持帧级别的数据标识和优先级 文件传输系统：大文件高效可靠传输 分布式存储：数据复制和同步 2. FILLP协议架构设计 2.1 分层架构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ┌─────────────────────────────────────────────────────────────────────────────┐ │ 应用程序 (Application) │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ FtSocket(), FtSend(), FtRecv() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 应用层API (app_lib) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ api.c │ │ socket_app.c │ │ epoll_app.c │ │ │ │ (外部接口) │ │ (Socket实现) │ │ (事件管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SockSend(), SockRecv(), SockConnect() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ FILLP协议核心层 (fillp_lib) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ fillp_conn.c │ │ fillp_input.c │ │ fillp_output.c │ │ │ │ (连接管理) │ │ (数据接收) │ │ (数据发送) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │fillp_flow_ctrl.c│ │ fillp_pcb.c │ │ fillp_frame.c │ │ │ │ (流量控制) │ │ (PCB管理) │ │ (帧处理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SpungePcb管理, NetConn管理 ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 网络抽象层 (Network Layer) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ net.c │ │ pcb.c │ │ spunge_core.c │ │ │ │ (网络连接) │ │ (PCB管理) │ │ (核心管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SysIoSend(), SysIoRecv() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 系统IO抽象层 (SysIO Layer) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ sysio.c │ │ sysio_udp.c │ │ spunge_stack.c │ │ │ │ (IO抽象接口) │ │ (UDP封装) │ │ (协议栈管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ sendto(), recvfrom() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 操作系统 (Operating System) │ │ UDP Socket 系统调用 │ └─────────────────────────────────────────────────────────────────────────────┘ 2.2 核心组件关系图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ┌──────────────────────────────────────────────────────────────────────────────┐ │ FILLP 核心组件关系 │ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ FtSocket │───→│ FtNetconn │───→│ SpungePcb │ │ │ │ (Socket) │ │ (网络连接) │ │ (PCB) │ │ │ └─────────────┘ └─────────────┘ └─────┬───────┘ │ │ │ │ │ │ │ ┌─────────────┐ │ │ │ └───────────→│ EventPoll │ │ │ │ │ (事件轮询) │ │ │ │ └─────────────┘ │ │ │ │ │ │ ┌─────────────┐ │ │ │ │ FillpPcb │←────────┘ │ │ │ (协议PCB) │ │ │ └─────┬───────┘ │ │ │ │ │ ┌──────────────────┼──────────────────┐ │ │ │ │ │ │ │ ┌─────▼─────┐ ┌───────▼─────┐ ┌──────▼──────┐ │ │ │FillpSendPcb│ │FillpRecvPcb │ │FlowControl │ │ │ │ (发送PCB) │ │ (接收PCB) │ │ (流量控制) │ │ │ └───────────┘ └────────────┘ └─────────────┘ │ └──────────────────────────────────────────────────────────────────────────────┘ 2.3 线程模型图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ┌─────────────────────────────────────────────────────────────────────────────┐ │ FILLP 线程模型 │ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ 应用线程 │ │ 协议栈线程 │ │ 定时器线程 │ │ │ │ (App Thread)│ │(Stack Thread)│ │(Timer Thread)│ │ │ │ │ │ │ │ │ │ │ │ FtSend() │──────────│ SendCycle │ │ PackTimer │ │ │ │ FtRecv() │ │ RecvCycle │ │ FcTimer │ │ │ │ FtConnect() │ │ PackCycle │ │KeepAlive │ │ │ │ │ │ │ │ ConnRetry │ │ │ └─────────────┘ └─────┬───────┘ └─────────────┘ │ │ │ │ │ │ │ │ │ │ │ │ ┌────▼────┐ ┌─────▼─────┐ ┌────▼────┐ │ │ │消息队列 │ │ UDP接收 │ │时间轮 │ │ │ │ (MSG) │ │(UDP Recv) │ │(Timing │ │ │ └─────────┘ │ select() │ │ Wheel) │ │ │ │recvfrom() │ └─────────┘ │ │ │sendto() │ │ │ └───────────┘ │ └─────────────────────────────────────────────────────────────────────────────┘ 3. 代码文件结构说明 3.1 主要头文件 (include/) 3.1.1 核心接口文件 fillpinc.h: 主要的API接口定义，包含所有外部调用的函数声明 fillptypes.h: 核心数据类型和结构体定义 fillpcallbacks.h: 系统回调函数类型定义，用于平台抽象 3.2 应用层 (app_lib/) 3.2.1 头文件 (include/) socket_app.h: Socket应用层接口定义 socket_opt.h: Socket选项设置接口 epoll_app.h: Epoll事件管理接口 spunge_app.h: Spunge应用层管理接口 fillp_stack_app_config_in.h: 应用层配置管理 fillp_dfx.h: 诊断和调试功能接口 3.2.2 源码文件 (src/) api.c: 外部API接口实现，包含FtSocket、FtSend、FtRecv等 socket_app.c: Socket应用层实现，处理用户接口调用 socket_opt.c: Socket选项设置实现 epoll_app.c: Epoll事件轮询实现 spunge_app.c: Spunge应用管理实现 fillp_stack_app_config.c: 应用层配置管理实现 fillp_dfx.c: 诊断功能实现 3.3 协议核心层 (fillp_lib/) 3.3.1 核心协议头文件 (include/) 主要协议文件\n"><meta property='og:url' content='https://latteratter-coder.github.io/p/fillp%E5%8D%8F%E8%AE%AE/'><meta property='og:site_name' content='二进制'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='协议'><meta property='article:published_time' content='2025-09-17T00:00:00+00:00'><meta property='article:modified_time' content='2025-09-17T00:00:00+00:00'><meta name=twitter:title content="FILLP协议"><meta name=twitter:description content="FILLP协议 目录 概述与背景 FILLP协议架构设计 代码文件结构说明 连接建立流程 数据传输流程 流量控制机制 RTT测量机制 重传和可靠性保证 系统调用和性能优化 关键数据结构 FILLP传输协议流程总结 总结和展望 1. 概述与背景 1.1 FILLP协议介绍 FILLP（Fast Internet Low Latency Protocol）是华为开发的一种基于UDP的可靠传输协议，专门为高带宽、长距离网络环境设计。在DSoftBus通信框架中，FILLP作为核心传输协议，提供了高性能的数据传输能力。\n1.2 核心特性 基于UDP的可靠传输：在UDP基础上实现可靠性保障 流控算法：支持多种流控算法(ALG0-ALG3) 快速重传：基于NACK的快速重传机制 高并发支持：支持多连接并发处理 安全机制：基于HMAC-SHA256的Cookie验证 跨平台：支持Linux、Windows等多平台 1.3 适用场景 高带宽长距离传输：卫星通信、跨洋数据传输 实时音视频传输：支持帧级别的数据标识和优先级 文件传输系统：大文件高效可靠传输 分布式存储：数据复制和同步 2. FILLP协议架构设计 2.1 分层架构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ┌─────────────────────────────────────────────────────────────────────────────┐ │ 应用程序 (Application) │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ FtSocket(), FtSend(), FtRecv() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 应用层API (app_lib) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ api.c │ │ socket_app.c │ │ epoll_app.c │ │ │ │ (外部接口) │ │ (Socket实现) │ │ (事件管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SockSend(), SockRecv(), SockConnect() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ FILLP协议核心层 (fillp_lib) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ fillp_conn.c │ │ fillp_input.c │ │ fillp_output.c │ │ │ │ (连接管理) │ │ (数据接收) │ │ (数据发送) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │fillp_flow_ctrl.c│ │ fillp_pcb.c │ │ fillp_frame.c │ │ │ │ (流量控制) │ │ (PCB管理) │ │ (帧处理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SpungePcb管理, NetConn管理 ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 网络抽象层 (Network Layer) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ net.c │ │ pcb.c │ │ spunge_core.c │ │ │ │ (网络连接) │ │ (PCB管理) │ │ (核心管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SysIoSend(), SysIoRecv() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 系统IO抽象层 (SysIO Layer) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ sysio.c │ │ sysio_udp.c │ │ spunge_stack.c │ │ │ │ (IO抽象接口) │ │ (UDP封装) │ │ (协议栈管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ sendto(), recvfrom() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 操作系统 (Operating System) │ │ UDP Socket 系统调用 │ └─────────────────────────────────────────────────────────────────────────────┘ 2.2 核心组件关系图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ┌──────────────────────────────────────────────────────────────────────────────┐ │ FILLP 核心组件关系 │ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ FtSocket │───→│ FtNetconn │───→│ SpungePcb │ │ │ │ (Socket) │ │ (网络连接) │ │ (PCB) │ │ │ └─────────────┘ └─────────────┘ └─────┬───────┘ │ │ │ │ │ │ │ ┌─────────────┐ │ │ │ └───────────→│ EventPoll │ │ │ │ │ (事件轮询) │ │ │ │ └─────────────┘ │ │ │ │ │ │ ┌─────────────┐ │ │ │ │ FillpPcb │←────────┘ │ │ │ (协议PCB) │ │ │ └─────┬───────┘ │ │ │ │ │ ┌──────────────────┼──────────────────┐ │ │ │ │ │ │ │ ┌─────▼─────┐ ┌───────▼─────┐ ┌──────▼──────┐ │ │ │FillpSendPcb│ │FillpRecvPcb │ │FlowControl │ │ │ │ (发送PCB) │ │ (接收PCB) │ │ (流量控制) │ │ │ └───────────┘ └────────────┘ └─────────────┘ │ └──────────────────────────────────────────────────────────────────────────────┘ 2.3 线程模型图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ┌─────────────────────────────────────────────────────────────────────────────┐ │ FILLP 线程模型 │ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ 应用线程 │ │ 协议栈线程 │ │ 定时器线程 │ │ │ │ (App Thread)│ │(Stack Thread)│ │(Timer Thread)│ │ │ │ │ │ │ │ │ │ │ │ FtSend() │──────────│ SendCycle │ │ PackTimer │ │ │ │ FtRecv() │ │ RecvCycle │ │ FcTimer │ │ │ │ FtConnect() │ │ PackCycle │ │KeepAlive │ │ │ │ │ │ │ │ ConnRetry │ │ │ └─────────────┘ └─────┬───────┘ └─────────────┘ │ │ │ │ │ │ │ │ │ │ │ │ ┌────▼────┐ ┌─────▼─────┐ ┌────▼────┐ │ │ │消息队列 │ │ UDP接收 │ │时间轮 │ │ │ │ (MSG) │ │(UDP Recv) │ │(Timing │ │ │ └─────────┘ │ select() │ │ Wheel) │ │ │ │recvfrom() │ └─────────┘ │ │ │sendto() │ │ │ └───────────┘ │ └─────────────────────────────────────────────────────────────────────────────┘ 3. 代码文件结构说明 3.1 主要头文件 (include/) 3.1.1 核心接口文件 fillpinc.h: 主要的API接口定义，包含所有外部调用的函数声明 fillptypes.h: 核心数据类型和结构体定义 fillpcallbacks.h: 系统回调函数类型定义，用于平台抽象 3.2 应用层 (app_lib/) 3.2.1 头文件 (include/) socket_app.h: Socket应用层接口定义 socket_opt.h: Socket选项设置接口 epoll_app.h: Epoll事件管理接口 spunge_app.h: Spunge应用层管理接口 fillp_stack_app_config_in.h: 应用层配置管理 fillp_dfx.h: 诊断和调试功能接口 3.2.2 源码文件 (src/) api.c: 外部API接口实现，包含FtSocket、FtSend、FtRecv等 socket_app.c: Socket应用层实现，处理用户接口调用 socket_opt.c: Socket选项设置实现 epoll_app.c: Epoll事件轮询实现 spunge_app.c: Spunge应用管理实现 fillp_stack_app_config.c: 应用层配置管理实现 fillp_dfx.c: 诊断功能实现 3.3 协议核心层 (fillp_lib/) 3.3.1 核心协议头文件 (include/) 主要协议文件\n"><link rel="shortcut icon" href=/favicon.svg></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><div class=site-meta><h1 class=site-name><a href=/>二进制</a></h1><h2 class=site-description>学无止境</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#目录>目录</a></li><li><a href=#1-概述与背景>1. 概述与背景</a><ol><li><a href=#11-fillp协议介绍>1.1 FILLP协议介绍</a></li><li><a href=#12-核心特性>1.2 核心特性</a></li><li><a href=#13-适用场景>1.3 适用场景</a></li></ol></li><li><a href=#2-fillp协议架构设计>2. FILLP协议架构设计</a><ol><li><a href=#21-分层架构图>2.1 分层架构图</a></li><li><a href=#22-核心组件关系图>2.2 核心组件关系图</a></li><li><a href=#23-线程模型图>2.3 线程模型图</a></li></ol></li><li><a href=#3-代码文件结构说明>3. 代码文件结构说明</a><ol><li><a href=#31-主要头文件-include>3.1 主要头文件 (include/)</a><ol><li><a href=#311-核心接口文件>3.1.1 核心接口文件</a></li></ol></li><li><a href=#32-应用层-app_lib>3.2 应用层 (app_lib/)</a><ol><li><a href=#321-头文件-include>3.2.1 头文件 (include/)</a></li><li><a href=#322-源码文件-src>3.2.2 源码文件 (src/)</a></li></ol></li><li><a href=#33-协议核心层-fillp_lib>3.3 协议核心层 (fillp_lib/)</a><ol><li><a href=#331-核心协议头文件-include>3.3.1 核心协议头文件 (include/)</a></li><li><a href=#332-核心协议源码-src>3.3.2 核心协议源码 (src/)</a></li></ol></li><li><a href=#34-架构层次关系>3.4 架构层次关系</a></li></ol></li><li><a href=#4-连接建立流程>4. 连接建立流程</a><ol><li><a href=#41-连接建立状态机>4.1 连接建立状态机</a></li><li><a href=#42-客户端连接建立完整调用链>4.2 客户端连接建立完整调用链</a></li><li><a href=#43-四次握手详细过程>4.3 四次握手详细过程</a><ol><li><a href=#431-第一次握手conn_req>4.3.1 第一次握手：CONN_REQ</a></li><li><a href=#432-第二次握手conn_req_ack>4.3.2 第二次握手：CONN_REQ_ACK</a></li><li><a href=#433-第三次握手conn_confirm>4.3.3 第三次握手：CONN_CONFIRM</a></li><li><a href=#434-第四次握手conn_confirm_ack>4.3.4 第四次握手：CONN_CONFIRM_ACK</a></li></ol></li><li><a href=#44-cookie安全机制>4.4 Cookie安全机制</a></li></ol></li><li><a href=#5-数据传输流程>5. 数据传输流程</a><ol><li><a href=#51-发送数据流程>5.1 发送数据流程</a><ol><li><a href=#511-发送数据完整调用链>5.1.1 发送数据完整调用链</a></li><li><a href=#512-发送数据流程图>5.1.2 发送数据流程图</a></li></ol></li><li><a href=#52-接收数据流程>5.2 接收数据流程</a><ol><li><a href=#521-接收数据完整调用链>5.2.1 接收数据完整调用链</a></li><li><a href=#522-接收数据流程图>5.2.2 接收数据流程图</a></li></ol></li><li><a href=#53-数据包格式>5.3 数据包格式</a><ol><li><a href=#531-fillp协议头结构>5.3.1 FILLP协议头结构</a></li><li><a href=#532-不同消息类型的包结构>5.3.2 不同消息类型的包结构</a></li></ol></li><li><a href=#54-fillp双编号处理流程>5.4 FILLP双编号处理流程</a><ol><li><a href=#541-双编号机制概述>5.4.1 双编号机制概述</a></li><li><a href=#542-发送端双编号处理流程>5.4.2 发送端双编号处理流程</a></li><li><a href=#543-接收端双编号处理流程>5.4.3 接收端双编号处理流程</a></li><li><a href=#544-双编号协同工作机制>5.4.4 双编号协同工作机制</a></li><li><a href=#545-双编号在重传中的应用>5.4.5 双编号在重传中的应用</a></li><li><a href=#546-双编号的优势>5.4.6 双编号的优势</a></li><li><a href=#547-双编号状态管理>5.4.7 双编号状态管理</a></li></ol></li></ol></li><li><a href=#6-流量控制机制>6. 流量控制机制</a><ol><li><a href=#61-流控算法接口>6.1 流控算法接口</a></li><li><a href=#62-流量控制流程图>6.2 流量控制流程图</a></li><li><a href=#63-发送速率控制>6.3 发送速率控制</a></li><li><a href=#64-pack包处理>6.4 PACK包处理</a></li></ol></li><li><a href=#7-rtt测量机制>7. RTT测量机制</a><ol><li><a href=#71-rtt测量概述>7.1 RTT测量概述</a></li><li><a href=#72-连接建立期间rtt测量>7.2 连接建立期间RTT测量</a><ol><li><a href=#721-四次握手rtt测量流程>7.2.1 四次握手RTT测量流程</a></li><li><a href=#722-rtt计算公式>7.2.2 RTT计算公式</a></li></ol></li><li><a href=#73-pack包rtt测量机制>7.3 PACK包RTT测量机制</a></li><li><a href=#74-adhoc-rtt探测机制>7.4 ADHOC RTT探测机制</a></li><li><a href=#75-rtt在流量控制中的应用>7.5 RTT在流量控制中的应用</a></li><li><a href=#76-为什么fillp的rtt比实际网络时延要低>7.6 为什么FILLP的RTT比实际网络时延要低</a><ol><li><a href=#761-测量粒度问题>7.6.1 测量粒度问题</a></li><li><a href=#762-系统时钟精度和同步问题>7.6.2 系统时钟精度和同步问题</a></li><li><a href=#763-主要影响因素>7.6.3 主要影响因素</a></li></ol></li></ol></li><li><a href=#8-重传和可靠性保证>8. 重传和可靠性保证</a><ol><li><a href=#81-nack机制>8.1 NACK机制</a><ol><li><a href=#811-丢包检测和nack发送>8.1.1 丢包检测和NACK发送</a></li><li><a href=#812-nack延迟发送机制>8.1.2 NACK延迟发送机制</a></li></ol></li><li><a href=#82-快速重传>8.2 快速重传</a></li><li><a href=#83-乱序处理机制>8.3 乱序处理机制</a></li></ol></li><li><a href=#9-系统调用和性能优化>9. 系统调用和性能优化</a><ol><li><a href=#91-udp系统调用封装>9.1 UDP系统调用封装</a><ol><li><a href=#911-发送路径分析>9.1.1 发送路径分析</a></li><li><a href=#912-系统调用函数指针>9.1.2 系统调用函数指针</a></li></ol></li><li><a href=#92-性能优化要点>9.2 性能优化要点</a><ol><li><a href=#921-零拷贝优化>9.2.1 零拷贝优化</a></li><li><a href=#922-无锁数据结构>9.2.2 无锁数据结构</a></li><li><a href=#923-批量发送优化>9.2.3 批量发送优化</a></li></ol></li></ol></li><li><a href=#10-关键数据结构>10. 关键数据结构</a><ol><li><a href=#101-socket相关结构>10.1 Socket相关结构</a><ol><li><a href=#1011-ftsocket结构>10.1.1 FtSocket结构</a></li><li><a href=#1012-ftnetconn结构>10.1.2 FtNetconn结构</a></li></ol></li><li><a href=#102-协议控制块结构>10.2 协议控制块结构</a><ol><li><a href=#1021-fillppcb主结构>10.2.1 FillpPcb主结构</a></li><li><a href=#1022-发送控制块>10.2.2 发送控制块</a></li><li><a href=#1023-接收控制块>10.2.3 接收控制块</a></li></ol></li></ol></li><li><a href=#11-fillp传输协议流程总结>11. FILLP传输协议流程总结</a><ol><li><a href=#111-完整传输流程概览>11.1 完整传输流程概览</a></li><li><a href=#112-详细流程分析>11.2 详细流程分析</a><ol><li><a href=#1121-第一阶段协议栈初始化>11.2.1 第一阶段：协议栈初始化</a></li><li><a href=#1122-第二阶段连接建立四次握手>11.2.2 第二阶段：连接建立（四次握手）</a></li><li><a href=#1123-第三阶段数据传输>11.2.3 第三阶段：数据传输</a></li><li><a href=#1124-第四阶段流量控制>11.2.4 第四阶段：流量控制</a></li><li><a href=#1125-第五阶段错误处理和重传>11.2.5 第五阶段：错误处理和重传</a></li><li><a href=#1126-第六阶段连接管理和监控>11.2.6 第六阶段：连接管理和监控</a></li></ol></li><li><a href=#113-核心算法总结>11.3 核心算法总结</a><ol><li><a href=#1131-rtt测量算法>11.3.1 RTT测量算法</a></li><li><a href=#1132-流量控制算法>11.3.2 流量控制算法</a></li><li><a href=#1133-可靠性保证算法>11.3.3 可靠性保证算法</a></li></ol></li><li><a href=#114-系统调用映射>11.4 系统调用映射</a></li><li><a href=#115-传输协议特色>11.5 传输协议特色</a></li></ol></li><li><a href=#12-总结和展望>12. 总结和展望</a><ol><li><a href=#121-fillp协议优势总结>12.1 FILLP协议优势总结</a><ol><li><a href=#1211-技术优势>12.1.1 技术优势</a></li><li><a href=#1212-关键性能数据>12.1.2 关键性能数据</a></li><li><a href=#1213-技术创新点>12.1.3 技术创新点</a></li></ol></li><li><a href=#122-适用场景分析>12.2 适用场景分析</a></li><li><a href=#123-局限性和挑战>12.3 局限性和挑战</a><ol><li><a href=#1231-当前局限性>12.3.1 当前局限性</a></li><li><a href=#1232-技术挑战>12.3.2 技术挑战</a></li></ol></li><li><a href=#124-改进建议和发展方向>12.4 改进建议和发展方向</a><ol><li><a href=#1241-短期改进建议>12.4.1 短期改进建议</a></li><li><a href=#1242-长期发展方向>12.4.2 长期发展方向</a></li></ol></li><li><a href=#125-总结>12.5 总结</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%BD%91%E7%BB%9C/ style=background-color:#ea4335;color:#fff>网络</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/fillp%E5%8D%8F%E8%AE%AE/>FILLP协议</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Sep 17, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>21 minute read</time></div></footer></div></header><section class=article-content><h1 id=fillp协议>FILLP协议</h1><h2 id=目录>目录</h2><ol><li><a class=link href=#1-%e6%a6%82%e8%bf%b0%e4%b8%8e%e8%83%8c%e6%99%af>概述与背景</a></li><li><a class=link href=#2-fillp%e5%8d%8f%e8%ae%ae%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1>FILLP协议架构设计</a></li><li><a class=link href=#3-%e4%bb%a3%e7%a0%81%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84%e8%af%b4%e6%98%8e>代码文件结构说明</a></li><li><a class=link href=#4-%e8%bf%9e%e6%8e%a5%e5%bb%ba%e7%ab%8b%e6%b5%81%e7%a8%8b>连接建立流程</a></li><li><a class=link href=#5-%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e6%b5%81%e7%a8%8b>数据传输流程</a></li><li><a class=link href=#6-%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e6%9c%ba%e5%88%b6>流量控制机制</a></li><li><a class=link href=#7-rtt%e6%b5%8b%e9%87%8f%e6%9c%ba%e5%88%b6>RTT测量机制</a></li><li><a class=link href=#8-%e9%87%8d%e4%bc%a0%e5%92%8c%e5%8f%af%e9%9d%a0%e6%80%a7%e4%bf%9d%e8%af%81>重传和可靠性保证</a></li><li><a class=link href=#9-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%92%8c%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96>系统调用和性能优化</a></li><li><a class=link href=#10-%e5%85%b3%e9%94%ae%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>关键数据结构</a></li><li><a class=link href=#11-fillp%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae%e6%b5%81%e7%a8%8b%e6%80%bb%e7%bb%93>FILLP传输协议流程总结</a></li><li><a class=link href=#12-%e6%80%bb%e7%bb%93%e5%92%8c%e5%b1%95%e6%9c%9b>总结和展望</a></li></ol><hr><h2 id=1-概述与背景>1. 概述与背景</h2><h3 id=11-fillp协议介绍>1.1 FILLP协议介绍</h3><p>FILLP（Fast Internet Low Latency Protocol）是华为开发的一种基于UDP的可靠传输协议，专门为高带宽、长距离网络环境设计。在DSoftBus通信框架中，FILLP作为核心传输协议，提供了高性能的数据传输能力。</p><h3 id=12-核心特性>1.2 核心特性</h3><ul><li><strong>基于UDP的可靠传输</strong>：在UDP基础上实现可靠性保障</li><li><strong>流控算法</strong>：支持多种流控算法(ALG0-ALG3)</li><li><strong>快速重传</strong>：基于NACK的快速重传机制</li><li><strong>高并发支持</strong>：支持多连接并发处理</li><li><strong>安全机制</strong>：基于HMAC-SHA256的Cookie验证</li><li><strong>跨平台</strong>：支持Linux、Windows等多平台</li></ul><h3 id=13-适用场景>1.3 适用场景</h3><ol><li><strong>高带宽长距离传输</strong>：卫星通信、跨洋数据传输</li><li><strong>实时音视频传输</strong>：支持帧级别的数据标识和优先级</li><li><strong>文件传输系统</strong>：大文件高效可靠传输</li><li><strong>分布式存储</strong>：数据复制和同步</li></ol><hr><h2 id=2-fillp协议架构设计>2. FILLP协议架构设计</h2><h3 id=21-分层架构图>2.1 分层架构图</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌─────────────────────────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                           应用程序 (Application)                              │
</span></span><span class=line><span class=cl>└─────────────────────────────────┬───────────────────────────────────────────┘
</span></span><span class=line><span class=cl>                                  │ FtSocket(), FtSend(), FtRecv()
</span></span><span class=line><span class=cl>┌─────────────────────────────────┴───────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                        应用层API (app_lib)                                   │
</span></span><span class=line><span class=cl>│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐              │
</span></span><span class=line><span class=cl>│  │   api.c         │ │  socket_app.c   │ │   epoll_app.c   │              │
</span></span><span class=line><span class=cl>│  │  (外部接口)      │ │   (Socket实现)   │ │   (事件管理)     │              │
</span></span><span class=line><span class=cl>│  └─────────────────┘ └─────────────────┘ └─────────────────┘              │
</span></span><span class=line><span class=cl>└─────────────────────────────────┬───────────────────────────────────────────┘
</span></span><span class=line><span class=cl>                                  │ SockSend(), SockRecv(), SockConnect()
</span></span><span class=line><span class=cl>┌─────────────────────────────────┴───────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                       FILLP协议核心层 (fillp_lib)                            │
</span></span><span class=line><span class=cl>│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐              │
</span></span><span class=line><span class=cl>│  │  fillp_conn.c   │ │  fillp_input.c  │ │ fillp_output.c  │              │
</span></span><span class=line><span class=cl>│  │   (连接管理)     │ │   (数据接收)     │ │   (数据发送)     │              │
</span></span><span class=line><span class=cl>│  └─────────────────┘ └─────────────────┘ └─────────────────┘              │
</span></span><span class=line><span class=cl>│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐              │
</span></span><span class=line><span class=cl>│  │fillp_flow_ctrl.c│ │   fillp_pcb.c   │ │  fillp_frame.c  │              │
</span></span><span class=line><span class=cl>│  │   (流量控制)     │ │   (PCB管理)     │ │   (帧处理)       │              │
</span></span><span class=line><span class=cl>│  └─────────────────┘ └─────────────────┘ └─────────────────┘              │
</span></span><span class=line><span class=cl>└─────────────────────────────────┬───────────────────────────────────────────┘
</span></span><span class=line><span class=cl>                                  │ SpungePcb管理, NetConn管理
</span></span><span class=line><span class=cl>┌─────────────────────────────────┴───────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                        网络抽象层 (Network Layer)                            │
</span></span><span class=line><span class=cl>│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐              │
</span></span><span class=line><span class=cl>│  │     net.c       │ │     pcb.c       │ │ spunge_core.c   │              │
</span></span><span class=line><span class=cl>│  │   (网络连接)     │ │   (PCB管理)     │ │  (核心管理)      │              │
</span></span><span class=line><span class=cl>│  └─────────────────┘ └─────────────────┘ └─────────────────┘              │
</span></span><span class=line><span class=cl>└─────────────────────────────────┬───────────────────────────────────────────┘
</span></span><span class=line><span class=cl>                                  │ SysIoSend(), SysIoRecv()
</span></span><span class=line><span class=cl>┌─────────────────────────────────┴───────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                       系统IO抽象层 (SysIO Layer)                             │
</span></span><span class=line><span class=cl>│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐              │
</span></span><span class=line><span class=cl>│  │    sysio.c      │ │  sysio_udp.c    │ │ spunge_stack.c  │              │
</span></span><span class=line><span class=cl>│  │  (IO抽象接口)    │ │  (UDP封装)      │ │  (协议栈管理)    │              │
</span></span><span class=line><span class=cl>│  └─────────────────┘ └─────────────────┘ └─────────────────┘              │
</span></span><span class=line><span class=cl>└─────────────────────────────────┬───────────────────────────────────────────┘
</span></span><span class=line><span class=cl>                                  │ sendto(), recvfrom()
</span></span><span class=line><span class=cl>┌─────────────────────────────────┴───────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                        操作系统 (Operating System)                           │
</span></span><span class=line><span class=cl>│                          UDP Socket 系统调用                                 │
</span></span><span class=line><span class=cl>└─────────────────────────────────────────────────────────────────────────────┘
</span></span></code></pre></td></tr></table></div></div><h3 id=22-核心组件关系图>2.2 核心组件关系图</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌──────────────────────────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                            FILLP 核心组件关系                                 │
</span></span><span class=line><span class=cl>│                                                                              │
</span></span><span class=line><span class=cl>│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                      │
</span></span><span class=line><span class=cl>│  │  FtSocket   │───→│ FtNetconn   │───→│ SpungePcb   │                      │
</span></span><span class=line><span class=cl>│  │   (Socket)  │    │  (网络连接)  │    │   (PCB)     │                      │
</span></span><span class=line><span class=cl>│  └─────────────┘    └─────────────┘    └─────┬───────┘                      │
</span></span><span class=line><span class=cl>│         │                                    │                              │
</span></span><span class=line><span class=cl>│         │            ┌─────────────┐         │                              │
</span></span><span class=line><span class=cl>│         └───────────→│ EventPoll   │         │                              │
</span></span><span class=line><span class=cl>│                      │ (事件轮询)   │         │                              │
</span></span><span class=line><span class=cl>│                      └─────────────┘         │                              │
</span></span><span class=line><span class=cl>│                                              │                              │
</span></span><span class=line><span class=cl>│                      ┌─────────────┐         │                              │
</span></span><span class=line><span class=cl>│                     │  FillpPcb   │←────────┘                              │
</span></span><span class=line><span class=cl>│                     │ (协议PCB)   │                                         │
</span></span><span class=line><span class=cl>│                     └─────┬───────┘                                         │
</span></span><span class=line><span class=cl>│                           │                                                 │
</span></span><span class=line><span class=cl>│        ┌──────────────────┼──────────────────┐                             │
</span></span><span class=line><span class=cl>│        │                  │                  │                             │
</span></span><span class=line><span class=cl>│  ┌─────▼─────┐    ┌───────▼─────┐    ┌──────▼──────┐                       │
</span></span><span class=line><span class=cl>│  │FillpSendPcb│   │FillpRecvPcb │   │FlowControl  │                       │
</span></span><span class=line><span class=cl>│  │  (发送PCB) │   │  (接收PCB)  │   │  (流量控制) │                       │
</span></span><span class=line><span class=cl>│  └───────────┘    └────────────┘    └─────────────┘                       │
</span></span><span class=line><span class=cl>└──────────────────────────────────────────────────────────────────────────────┘
</span></span></code></pre></td></tr></table></div></div><h3 id=23-线程模型图>2.3 线程模型图</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌─────────────────────────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                            FILLP 线程模型                                    │
</span></span><span class=line><span class=cl>│                                                                             │
</span></span><span class=line><span class=cl>│  ┌─────────────┐          ┌─────────────┐          ┌─────────────┐         │
</span></span><span class=line><span class=cl>│  │ 应用线程    │          │ 协议栈线程  │          │ 定时器线程  │         │
</span></span><span class=line><span class=cl>│  │ (App Thread)│          │(Stack Thread)│          │(Timer Thread)│         │
</span></span><span class=line><span class=cl>│  │             │          │             │          │             │         │
</span></span><span class=line><span class=cl>│  │ FtSend()    │──────────│ SendCycle   │          │ PackTimer   │         │
</span></span><span class=line><span class=cl>│  │ FtRecv()    │          │ RecvCycle   │          │ FcTimer     │         │
</span></span><span class=line><span class=cl>│  │ FtConnect() │          │ PackCycle   │          │KeepAlive    │         │
</span></span><span class=line><span class=cl>│  │             │          │             │          │ ConnRetry   │         │
</span></span><span class=line><span class=cl>│  └─────────────┘          └─────┬───────┘          └─────────────┘         │
</span></span><span class=line><span class=cl>│         │                       │                         │               │
</span></span><span class=line><span class=cl>│         │                       │                         │               │
</span></span><span class=line><span class=cl>│    ┌────▼────┐            ┌─────▼─────┐              ┌────▼────┐          │
</span></span><span class=line><span class=cl>│    │消息队列  │            │ UDP接收   │              │时间轮   │          │
</span></span><span class=line><span class=cl>│    │ (MSG)   │            │(UDP Recv) │              │(Timing  │          │
</span></span><span class=line><span class=cl>│    └─────────┘            │ select()  │              │ Wheel)  │          │
</span></span><span class=line><span class=cl>│                           │recvfrom() │              └─────────┘          │
</span></span><span class=line><span class=cl>│                           │sendto()   │                                   │
</span></span><span class=line><span class=cl>│                           └───────────┘                                   │
</span></span><span class=line><span class=cl>└─────────────────────────────────────────────────────────────────────────────┘
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=3-代码文件结构说明>3. 代码文件结构说明</h2><h3 id=31-主要头文件-include>3.1 主要头文件 (include/)</h3><h4 id=311-核心接口文件>3.1.1 核心接口文件</h4><ul><li><strong>fillpinc.h</strong>: 主要的API接口定义，包含所有外部调用的函数声明</li><li><strong>fillptypes.h</strong>: 核心数据类型和结构体定义</li><li><strong>fillpcallbacks.h</strong>: 系统回调函数类型定义，用于平台抽象</li></ul><h3 id=32-应用层-app_lib>3.2 应用层 (app_lib/)</h3><h4 id=321-头文件-include>3.2.1 头文件 (include/)</h4><ul><li><strong>socket_app.h</strong>: Socket应用层接口定义</li><li><strong>socket_opt.h</strong>: Socket选项设置接口</li><li><strong>epoll_app.h</strong>: Epoll事件管理接口</li><li><strong>spunge_app.h</strong>: Spunge应用层管理接口</li><li><strong>fillp_stack_app_config_in.h</strong>: 应用层配置管理</li><li><strong>fillp_dfx.h</strong>: 诊断和调试功能接口</li></ul><h4 id=322-源码文件-src>3.2.2 源码文件 (src/)</h4><ul><li><strong>api.c</strong>: 外部API接口实现，包含FtSocket、FtSend、FtRecv等</li><li><strong>socket_app.c</strong>: Socket应用层实现，处理用户接口调用</li><li><strong>socket_opt.c</strong>: Socket选项设置实现</li><li><strong>epoll_app.c</strong>: Epoll事件轮询实现</li><li><strong>spunge_app.c</strong>: Spunge应用管理实现</li><li><strong>fillp_stack_app_config.c</strong>: 应用层配置管理实现</li><li><strong>fillp_dfx.c</strong>: 诊断功能实现</li></ul><h3 id=33-协议核心层-fillp_lib>3.3 协议核心层 (fillp_lib/)</h3><h4 id=331-核心协议头文件-include>3.3.1 核心协议头文件 (include/)</h4><p><strong>主要协议文件</strong></p><ul><li><strong>fillp/fillp.h</strong>: FILLP协议核心定义，包含数据包格式、状态定义</li><li><strong>fillp/fillp_pcb.h</strong>: 协议控制块(PCB)定义</li><li><strong>fillp/fillp_flow_control.h</strong>: 流量控制算法接口</li><li><strong>fillp/fillp_algorithm.h</strong>: 流控算法函数定义</li><li><strong>fillp/fillp_frame.h</strong>: 帧处理相关定义</li></ul><p><strong>网络和系统接口</strong></p><ul><li><strong>net.h</strong>: 网络连接管理接口</li><li><strong>pcb.h</strong>: PCB管理接口</li><li><strong>sysio.h</strong>: 系统IO抽象层接口</li><li><strong>res.h</strong>: 资源管理接口</li></ul><p><strong>工具和安全</strong></p><ul><li><strong>hmac.h</strong>: HMAC-SHA256安全认证</li><li><strong>sha256.h</strong>: SHA256哈希算法</li><li><strong>fillp_cookie.h</strong>: Cookie安全机制</li><li><strong>fillp_buf_item.h</strong>: 缓冲区项管理</li></ul><h4 id=332-核心协议源码-src>3.3.2 核心协议源码 (src/)</h4><p><strong>主要协议实现</strong></p><ul><li><strong>fillp/fillp.c</strong>: 协议算法函数注册</li><li><strong>fillp/fillp_common.c</strong>: 协议通用功能实现</li><li><strong>fillp/fillp_conn.c</strong>: 连接建立和管理实现</li><li><strong>fillp/fillp_input.c</strong>: 数据包接收和处理</li><li><strong>fillp/fillp_output.c</strong>: 数据包发送处理</li><li><strong>fillp/fillp_pcb.c</strong>: 协议控制块管理</li><li><strong>fillp/fillp_flow_control.c</strong>: 流量控制实现</li><li><strong>fillp/fillp_flow_control_alg0.c</strong>: 流控算法0实现</li><li><strong>fillp/fillp_frame.c</strong>: 帧处理实现</li><li><strong>fillp/fillp_timer.c</strong>: 定时器管理</li></ul><p><strong>网络和系统层</strong></p><ul><li><strong>net.c</strong>: 网络连接实现</li><li><strong>pcb.c</strong>: PCB管理实现</li><li><strong>sysio.c</strong>: 系统IO抽象实现</li><li><strong>sysio_udp.c</strong>: UDP系统调用封装</li><li><strong>spunge_core.c</strong>: Spunge核心管理</li><li><strong>spunge_stack.c</strong>: Spunge协议栈实现</li></ul><h3 id=34-架构层次关系>3.4 架构层次关系</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用API层 (api.c, socket_app.c)
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>协议核心层 (fillp_conn.c, fillp_input.c, fillp_output.c)
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>网络抽象层 (net.c, pcb.c)
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>系统IO层 (sysio.c, sysio_udp.c)
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>操作系统层 (socket系统调用)
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=4-连接建立流程>4. 连接建立流程</h2><h3 id=41-连接建立状态机>4.1 连接建立状态机</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌─────────┐                                                             
</span></span><span class=line><span class=cl>│  IDLE   │                                                             
</span></span><span class=line><span class=cl>│ (空闲)  │                                                             
</span></span><span class=line><span class=cl>└────┬────┘                                                             
</span></span><span class=line><span class=cl>     │ FtConnect()                                                      
</span></span><span class=line><span class=cl>     ▼                                                                  
</span></span><span class=line><span class=cl>┌──────────────┐  CONN_REQ   ┌──────────────┐  CONN_CONFIRM              
</span></span><span class=line><span class=cl>│ CONNECTING   │────────────→│ REQ_ACK_RCVD │─────────────┐               
</span></span><span class=line><span class=cl>│   (连接中)   │             │ (收到请求应答)│             │               
</span></span><span class=line><span class=cl>└──────┬───────┘             └──────────────┘             │               
</span></span><span class=line><span class=cl>       │                                                  │               
</span></span><span class=line><span class=cl>       │ Timeout/Error                                    │               
</span></span><span class=line><span class=cl>       ▼                                                  ▼               
</span></span><span class=line><span class=cl> ┌──────────┐                                    ┌──────────────┐         
</span></span><span class=line><span class=cl> │  CLOSED  │                                    │ CONFIRM_SENT │         
</span></span><span class=line><span class=cl> │  (关闭)  │                                    │ (确认已发送) │         
</span></span><span class=line><span class=cl> └──────────┘                                    └──────┬───────┘         
</span></span><span class=line><span class=cl>       ▲                                                │                 
</span></span><span class=line><span class=cl>       │                                                │CONFIRM_ACK      
</span></span><span class=line><span class=cl>       │                                                ▼                 
</span></span><span class=line><span class=cl>       │                                      ┌──────────────┐           
</span></span><span class=line><span class=cl>       │                                      │  CONNECTED   │           
</span></span><span class=line><span class=cl>       │                                      │   (已连接)   │           
</span></span><span class=line><span class=cl>       │                                      └──────┬───────┘           
</span></span><span class=line><span class=cl>       │                                             │                   
</span></span><span class=line><span class=cl>       │ FtClose()                                   │ FtClose()         
</span></span><span class=line><span class=cl>       │                                             ▼                   
</span></span><span class=line><span class=cl>       │                                      ┌──────────────┐           
</span></span><span class=line><span class=cl>       │                                      │   CLOSING    │           
</span></span><span class=line><span class=cl>       │                                      │   (关闭中)   │           
</span></span><span class=line><span class=cl>       └──────────────────────────────────────┤              │           
</span></span><span class=line><span class=cl>                                              └──────────────┘           
</span></span></code></pre></td></tr></table></div></div><h3 id=42-客户端连接建立完整调用链>4.2 客户端连接建立完整调用链</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用层调用:
</span></span><span class=line><span class=cl>FtConnect(fd, addr, addrlen)                          // api.c:91
</span></span><span class=line><span class=cl>  └→ SockConnect(sockIndex, name, nameLen)           // socket_app.c:1318
</span></span><span class=line><span class=cl>      └→ SpungeConnectMsg 消息处理                    // 消息机制
</span></span><span class=line><span class=cl>          └→ SpungeSendConnectMsg(conn)               // spunge_stack.c
</span></span><span class=line><span class=cl>              └→ FillpSendConnReq(pcb)                // fillp_conn.c:1375
</span></span><span class=line><span class=cl>                  └→ pcb-&gt;sendFunc(conn, &amp;req, ...)   // 函数指针调用
</span></span><span class=line><span class=cl>                      └→ SysioSendUdp(...)            // sysio_udp.c
</span></span><span class=line><span class=cl>                          └→ sendto(udpSock, buf, len, flags, addr, addrlen)  // 系统调用
</span></span></code></pre></td></tr></table></div></div><h3 id=43-四次握手详细过程>4.3 四次握手详细过程</h3><h4 id=431-第一次握手conn_req>4.3.1 第一次握手：CONN_REQ</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_conn.c:1375 FillpSendConnReq()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpPktConnReq</span> <span class=n>req</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>FillpSendConnReqBuild</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>req</span><span class=p>,</span> <span class=n>curTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ret</span> <span class=o>=</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=nf>sendFunc</span><span class=p>(</span><span class=n>conn</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>req</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPktConnReq</span><span class=p>),</span> <span class=n>conn</span><span class=o>-&gt;</span><span class=n>pcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 最终调用 sendto() 系统调用
</span></span></span></code></pre></td></tr></table></div></div><h4 id=432-第二次握手conn_req_ack>4.3.2 第二次握手：CONN_REQ_ACK</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 服务端接收CONN_REQ后
</span></span></span><span class=line><span class=cl><span class=c1>// fillp_conn.c:91 FillpConnReqInput()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>FillpGenerateCookie</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>req</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>addr</span><span class=p>,</span> <span class=n>serverPort</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stateCookie</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>FillpSendConnReqAck</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stateCookie</span><span class=p>,</span> <span class=n>timestamp</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 最终通过 sendto() 发送CONN_REQ_ACK
</span></span></span></code></pre></td></tr></table></div></div><h4 id=433-第三次握手conn_confirm>4.3.3 第三次握手：CONN_CONFIRM</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 客户端接收CONN_REQ_ACK后
</span></span></span><span class=line><span class=cl><span class=c1>// fillp_conn.c:427 FillpConnReqAckInput()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>FillpSendConnConfirm</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reqAck</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 最终通过 sendto() 发送CONN_CONFIRM
</span></span></span></code></pre></td></tr></table></div></div><h4 id=434-第四次握手conn_confirm_ack>4.3.4 第四次握手：CONN_CONFIRM_ACK</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 服务端接收CONN_CONFIRM后
</span></span></span><span class=line><span class=cl><span class=c1>// fillp_conn.c:748 FillpConnConfirmInput()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>FillpSendConnConfirmAck</span><span class=p>(</span><span class=n>pcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 最终通过 sendto() 发送CONN_CONFIRM_ACK
</span></span></span></code></pre></td></tr></table></div></div><h3 id=44-cookie安全机制>4.4 Cookie安全机制</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Cookie生成和验证
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>FILLP_INT</span> <span class=nf>FillpGenerateCookie</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                    <span class=n>FillpCookieContent</span> <span class=o>*</span><span class=n>cookie</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 基于时间戳、地址等信息生成Cookie
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 使用HMAC-SHA256算法确保安全性
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>FillpHmacSha256Generate</span><span class=p>(</span><span class=cm>/* parameters */</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>FILLP_INT</span> <span class=nf>FillpValidateCookie</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                    <span class=k>const</span> <span class=n>FillpCookieContent</span> <span class=o>*</span><span class=n>cookie</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 验证Cookie有效性
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>FillpHmacSha256Verify</span><span class=p>(</span><span class=cm>/* parameters */</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=5-数据传输流程>5. 数据传输流程</h2><h3 id=51-发送数据流程>5.1 发送数据流程</h3><h4 id=511-发送数据完整调用链>5.1.1 发送数据完整调用链</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用层调用:
</span></span><span class=line><span class=cl>FtSend(fd, data, size, flag)                         // api.c:137
</span></span><span class=line><span class=cl>  └→ SockSend(sockIndex, data, size, flags)          // socket_app.c:155
</span></span><span class=line><span class=cl>      └→ SockSendmsg(sockIndex, &amp;msg, flags)         // socket_app.c:516
</span></span><span class=line><span class=cl>          └→ SockSendmsgDataToBufCache(sock, msg, flags, bufLen)  // socket_app.c:459
</span></span><span class=line><span class=cl>              └→ SockSendReqFpcbItem() 获取缓冲区      // socket_app.c:377
</span></span><span class=line><span class=cl>              └→ FillpPcbSend(fpcb, itemList, itemCnt)  // fillp_pcb.c
</span></span><span class=line><span class=cl>                  └→ FillpSendOne(pcb, totalSendBytes, sendPktNum)  // fillp_output.c
</span></span><span class=line><span class=cl>                      └→ FillpSendItem(item, fpcb)     // fillp_output.c
</span></span><span class=line><span class=cl>                          └→ pcb-&gt;sendFunc()           // 函数指针
</span></span><span class=line><span class=cl>                              └→ SysioSendUdp()        // sysio_udp.c
</span></span><span class=line><span class=cl>                                  └→ sendto()          // 系统调用
</span></span></code></pre></td></tr></table></div></div><h4 id=512-发送数据流程图>5.1.2 发送数据流程图</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用程序
</span></span><span class=line><span class=cl>    │ FtSend(fd, data, len, flag)
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>Socket API层 (api.c)
</span></span><span class=line><span class=cl>    │ 参数验证、socket状态检查
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>Socket应用层 (socket_app.c)  
</span></span><span class=line><span class=cl>    │ SockSendData() - 非阻塞检查、缓冲区管理
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>FILLP协议层 (fillp_common.c)
</span></span><span class=line><span class=cl>    │ FillpSendData() - 数据分片、序列号分配
</span></span><span class=line><span class=cl>    ▼ 
</span></span><span class=line><span class=cl>缓冲区管理 (fillp_buf_item.c)
</span></span><span class=line><span class=cl>    │ FillpCreateSendItem() - 创建数据项、设置序列号
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>发送队列 (fillp_output.c)
</span></span><span class=line><span class=cl>    │ 添加到unSendList → 流控检查 → 获取发送项
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>协议封装 (fillp_output.c)
</span></span><span class=line><span class=cl>    │ FillpBuildDataPacket() - 添加FILLP头部
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>系统I/O层 (sysio_udp.c)
</span></span><span class=line><span class=cl>    │ SysioSendUdp() - UDP socket发送
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>系统调用 (callbacks.c)
</span></span><span class=line><span class=cl>    │ FILLP_SENDTO() → sendto()
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>内核网络栈
</span></span><span class=line><span class=cl>    │ UDP协议处理 → IP路由 → 网络设备发送
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>网络传输
</span></span></code></pre></td></tr></table></div></div><h3 id=52-接收数据流程>5.2 接收数据流程</h3><h4 id=521-接收数据完整调用链>5.2.1 接收数据完整调用链</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>系统层数据到达:
</span></span><span class=line><span class=cl>select() 检测到UDP socket可读                        // sysio.c:78
</span></span><span class=line><span class=cl>  └→ SpungeDoRecvCycle(osSock, inst)               // spunge_stack.c:25
</span></span><span class=line><span class=cl>      └→ SysioFetchPacketUdp(osSock, buf, &amp;count)  // sysio_udp.c:480
</span></span><span class=line><span class=cl>          └→ recvfrom(udpSock, buf, len, 0, ...)    // 系统调用
</span></span><span class=line><span class=cl>              └→ SpungePushRecvdDataToStack(...)    // spunge_core.c
</span></span><span class=line><span class=cl>                  └→ FillpDoInput(pcb, buf, inst)   // fillp_input.c:873
</span></span><span class=line><span class=cl>                      └→ FillpDataInput(pcb, item)  // fillp_input.c:188
</span></span><span class=line><span class=cl>                          └→ FillpDataToStack(pcb, item)  // fillp_common.c:625
</span></span><span class=line><span class=cl>                              └→ 数据推送到接收队列
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>应用层读取:
</span></span><span class=line><span class=cl>FtRecv(fd, mem, len, flag)                          // api.c:124
</span></span><span class=line><span class=cl>  └→ SockRecv(s, mem, len, flags)                  // socket_app.c:558
</span></span><span class=line><span class=cl>      └→ SockRecvmsg(sockIndex, &amp;msg, flags)       // socket_app.c:728
</span></span><span class=line><span class=cl>          └→ SockRecvmsgDataFromBufCache(sock, msg, flags, bufLen)  // socket_app.c:669
</span></span><span class=line><span class=cl>              └→ 从接收队列读取数据到用户缓冲区
</span></span></code></pre></td></tr></table></div></div><h4 id=522-接收数据流程图>5.2.2 接收数据流程图</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>网络传输
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>内核网络栈
</span></span><span class=line><span class=cl>    │ 网络设备接收 → IP处理 → UDP协议处理
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>系统调用 (callbacks.c)
</span></span><span class=line><span class=cl>    │ recvfrom() → FILLP_RECVFROM()
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>系统I/O层 (sysio_udp.c)
</span></span><span class=line><span class=cl>    │ SysioFetchPacketUdp() - 接收UDP数据
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>数据分发 (spunge_core.c)
</span></span><span class=line><span class=cl>    │ SpungePushRecvdDataToStack() - 根据地址查找PCB
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>协议解析 (fillp_input.c)
</span></span><span class=line><span class=cl>    │ FillpDoInput() - 解析FILLP头部、字节序转换
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>消息分类处理 (fillp_input.c)
</span></span><span class=line><span class=cl>    │ 根据消息类型分发：DATA/PACK/NACK/CONN_*
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>数据处理 (fillp_input.c)
</span></span><span class=line><span class=cl>    │ FillpDataInput() - 序列号检查、乱序处理
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>接收缓冲区 (fillp_common.c)
</span></span><span class=line><span class=cl>    │ FillpDataToStack() - 添加到recvList、有序性保证
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>应用层通知 (spunge.c)
</span></span><span class=line><span class=cl>    │ SpungeEpollEventCallback() - 触发EPOLLIN事件
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>Socket API层 (api.c)
</span></span><span class=line><span class=cl>    │ FtRecv() - 从接收缓冲区读取数据
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>应用程序
</span></span></code></pre></td></tr></table></div></div><h3 id=53-数据包格式>5.3 数据包格式</h3><h4 id=531-fillp协议头结构>5.3.1 FILLP协议头结构</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT8</span> <span class=n>flag</span><span class=p>;</span>                 <span class=c1>// 标志位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT8</span> <span class=n>type</span><span class=p>;</span>                 <span class=c1>// 消息类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT16</span> <span class=n>dataLen</span><span class=p>;</span>             <span class=c1>// 数据长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>seqNum</span><span class=p>;</span>              <span class=c1>// 序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>pktNum</span><span class=p>;</span>              <span class=c1>// 包号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define FILLP_HLEN sizeof(struct FillpPktHead)
</span></span></span></code></pre></td></tr></table></div></div><h4 id=532-不同消息类型的包结构>5.3.2 不同消息类型的包结构</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 数据包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpPktData</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>head</span><span class=p>[</span><span class=n>FILLP_HLEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>                     <span class=c1>// 可变长度数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 连接请求包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpPktConnReq</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>head</span><span class=p>[</span><span class=n>FILLP_HLEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>cookiePreserveTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>sendCache</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>recvCache</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_ULLONG</span> <span class=n>timestamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NACK包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpPktNack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>head</span><span class=p>[</span><span class=n>FILLP_HLEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>lastPktNum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// PACK包(确认包)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpPktPack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>head</span><span class=p>[</span><span class=n>FILLP_HLEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT16</span> <span class=n>flag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT16</span> <span class=n>pktLoss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>lostSeq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>rate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>oppositeSetRate</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=54-fillp双编号处理流程>5.4 FILLP双编号处理流程</h3><h4 id=541-双编号机制概述>5.4.1 双编号机制概述</h4><p>FILLP协议采用了创新的双编号机制，同时使用序列号（seqNum）和包号（pktNum）来管理数据传输：</p><ul><li><strong>序列号（seqNum）</strong>：按字节递增，用于数据完整性和顺序保证</li><li><strong>包号（pktNum）</strong>：按数据包递增，用于丢包检测和重传控制</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT8</span> <span class=n>flag</span><span class=p>;</span>                 <span class=c1>// 标志位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT8</span> <span class=n>type</span><span class=p>;</span>                 <span class=c1>// 消息类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT16</span> <span class=n>dataLen</span><span class=p>;</span>             <span class=c1>// 数据长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>seqNum</span><span class=p>;</span>              <span class=c1>// 序列号（字节级）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>pktNum</span><span class=p>;</span>              <span class=c1>// 包号（包级）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=542-发送端双编号处理流程>5.4.2 发送端双编号处理流程</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用数据输入
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>数据分片处理
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>┌─────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│               双编号分配流程                         │
</span></span><span class=line><span class=cl>│                                                     │
</span></span><span class=line><span class=cl>│  ┌─────────────┐    ┌─────────────┐                │
</span></span><span class=line><span class=cl>│  │包号分配     │    │序列号分配   │                │
</span></span><span class=line><span class=cl>│  │pktNum++     │    │seqNum +=    │                │
</span></span><span class=line><span class=cl>│  │(按包递增)   │    │dataLen      │                │
</span></span><span class=line><span class=cl>│  │            │    │(按字节递增) │                │
</span></span><span class=line><span class=cl>│  └─────────────┘    └─────────────┘                │
</span></span><span class=line><span class=cl>│         │                  │                        │
</span></span><span class=line><span class=cl>│         └──────┬──────────┘                        │
</span></span><span class=line><span class=cl>│                ▼                                    │
</span></span><span class=line><span class=cl>│        ┌─────────────┐                              │
</span></span><span class=line><span class=cl>│        │设置包头信息 │                              │
</span></span><span class=line><span class=cl>│        │head-&gt;pktNum │                              │
</span></span><span class=line><span class=cl>│        │head-&gt;seqNum │                              │
</span></span><span class=line><span class=cl>│        └─────────────┘                              │
</span></span><span class=line><span class=cl>└─────────────────────────────────────────────────────┘
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>协议头封装
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>添加到发送队列
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>UDP发送
</span></span></code></pre></td></tr></table></div></div><p><strong>发送端关键代码逻辑：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_output.c 发送数据项时的双编号处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>FillpSetItemNumbers</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=n>item</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 分配包号（按包递增）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>item</span><span class=o>-&gt;</span><span class=n>pktNum</span> <span class=o>=</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>pktNum</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 分配序列号（按数据长度递增）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>item</span><span class=o>-&gt;</span><span class=n>seqNum</span> <span class=o>=</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>seqNum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>seqNum</span> <span class=o>+=</span> <span class=n>item</span><span class=o>-&gt;</span><span class=n>dataLen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 设置协议头
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=o>*</span><span class=n>head</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=o>*</span><span class=p>)</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>.</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>head</span><span class=o>-&gt;</span><span class=n>pktNum</span> <span class=o>=</span> <span class=nf>FILLP_HTONL</span><span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>pktNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>head</span><span class=o>-&gt;</span><span class=n>seqNum</span> <span class=o>=</span> <span class=nf>FILLP_HTONL</span><span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>seqNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>head</span><span class=o>-&gt;</span><span class=n>dataLen</span> <span class=o>=</span> <span class=nf>FILLP_HTONS</span><span class=p>(</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>dataLen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=543-接收端双编号处理流程>5.4.3 接收端双编号处理流程</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>UDP数据包到达
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>协议头解析
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>┌─────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│               双编号验证流程                         │
</span></span><span class=line><span class=cl>│                                                     │
</span></span><span class=line><span class=cl>│  ┌─────────────┐    ┌─────────────┐                │
</span></span><span class=line><span class=cl>│  │包号检查     │    │序列号检查   │                │
</span></span><span class=line><span class=cl>│  │pktNum vs    │    │seqNum vs    │                │
</span></span><span class=line><span class=cl>│  │expectedPkt  │    │expectedSeq  │                │
</span></span><span class=line><span class=cl>│  └─────┬───────┘    └─────┬───────┘                │
</span></span><span class=line><span class=cl>│        │                  │                        │
</span></span><span class=line><span class=cl>│        ▼                  ▼                        │
</span></span><span class=line><span class=cl>│  ┌─────────────┐    ┌─────────────┐                │
</span></span><span class=line><span class=cl>│  │丢包检测     │    │数据完整性   │                │
</span></span><span class=line><span class=cl>│  │Gap检测      │    │检查         │                │
</span></span><span class=line><span class=cl>│  │NACK生成     │    │乱序处理     │                │
</span></span><span class=line><span class=cl>│  └─────────────┘    └─────────────┘                │
</span></span><span class=line><span class=cl>│        │                  │                        │
</span></span><span class=line><span class=cl>│        └──────┬──────────┘                        │
</span></span><span class=line><span class=cl>│               ▼                                    │
</span></span><span class=line><span class=cl>│        ┌─────────────┐                              │
</span></span><span class=line><span class=cl>│        │数据处理决策 │                              │
</span></span><span class=line><span class=cl>│        │- 按序接收   │                              │
</span></span><span class=line><span class=cl>│        │- 乱序缓存   │                              │
</span></span><span class=line><span class=cl>│        │- 重复丢弃   │                              │
</span></span><span class=line><span class=cl>│        └─────────────┘                              │
</span></span><span class=line><span class=cl>└─────────────────────────────────────────────────────┘
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>数据队列管理
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>应用层交付
</span></span></code></pre></td></tr></table></div></div><p><strong>接收端关键代码逻辑：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_input.c 接收数据时的双编号处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>FillpProcessReceivedPacket</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=n>item</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=o>*</span><span class=n>head</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=o>*</span><span class=p>)</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>.</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 解析双编号（网络字节序转换）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>pktNum</span> <span class=o>=</span> <span class=nf>FILLP_NTOHL</span><span class=p>(</span><span class=n>head</span><span class=o>-&gt;</span><span class=n>pktNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>seqNum</span> <span class=o>=</span> <span class=nf>FILLP_NTOHL</span><span class=p>(</span><span class=n>head</span><span class=o>-&gt;</span><span class=n>seqNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT16</span> <span class=n>dataLen</span> <span class=o>=</span> <span class=nf>FILLP_NTOHS</span><span class=p>(</span><span class=n>head</span><span class=o>-&gt;</span><span class=n>dataLen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 包号检查（丢包检测）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>pktNum</span> <span class=o>&gt;</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>expectedPktNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 检测到丢包，发送NACK
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>FillpSendNack</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>expectedPktNum</span><span class=p>,</span> <span class=n>pktNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>statistics</span><span class=p>.</span><span class=n>traffic</span><span class=p>.</span><span class=n>totalRecvLost</span> <span class=o>+=</span> <span class=p>(</span><span class=n>pktNum</span> <span class=o>-</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>expectedPktNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 序列号检查（数据完整性）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>seqNum</span> <span class=o>&lt;</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>expectedSeqNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 重复或过期数据包，丢弃
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>FillpDropDuplicatePacket</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 数据处理决策
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>pktNum</span> <span class=o>==</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>expectedPktNum</span> <span class=o>&amp;&amp;</span> <span class=n>seqNum</span> <span class=o>==</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>expectedSeqNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 按序数据包，直接处理
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>FillpProcessInOrderPacket</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>expectedPktNum</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>expectedSeqNum</span> <span class=o>+=</span> <span class=n>dataLen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 乱序数据包，加入缓存队列
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>FillpCacheOutOfOrderPacket</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=544-双编号协同工作机制>5.4.4 双编号协同工作机制</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌─────────────────────────────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                     双编号协同工作流程图                             │
</span></span><span class=line><span class=cl>│                                                                     │
</span></span><span class=line><span class=cl>│  发送端状态                     网络传输                 接收端状态  │
</span></span><span class=line><span class=cl>│                                                                     │
</span></span><span class=line><span class=cl>│  ┌─────────────┐                                    ┌─────────────┐ │
</span></span><span class=line><span class=cl>│  │send.pktNum  │────────────┐          ┌───────────│recv.pktNum  │ │
</span></span><span class=line><span class=cl>│  │send.seqNum  │            │          │           │recv.seqNum  │ │
</span></span><span class=line><span class=cl>│  └─────────────┘            │          │           └─────────────┘ │
</span></span><span class=line><span class=cl>│         │                   │          │                  │        │
</span></span><span class=line><span class=cl>│         ▼                   ▼          ▼                  ▼        │
</span></span><span class=line><span class=cl>│  ┌─────────────┐      ┌──────────┐ ┌──────────┐   ┌─────────────┐ │
</span></span><span class=line><span class=cl>│  │数据包1      │─────▶│ Network  │─│ Network  │──▶│检查包号     │ │
</span></span><span class=line><span class=cl>│  │pkt=1,seq=0  │      │Transport │ │Transport │   │期望pkt=1    │ │
</span></span><span class=line><span class=cl>│  └─────────────┘      └──────────┘ └──────────┘   │期望seq=0    │ │
</span></span><span class=line><span class=cl>│                                                   └─────────────┘ │
</span></span><span class=line><span class=cl>│  ┌─────────────┐      ┌──────────┐ ┌──────────┐   ┌─────────────┐ │
</span></span><span class=line><span class=cl>│  │数据包2      │─────▶│ Network  │─│   丢失   │──X│Gap检测      │ │
</span></span><span class=line><span class=cl>│  │pkt=2,seq=100│      │Transport │ │          │   │pkt=3&gt;2+1    │ │
</span></span><span class=line><span class=cl>│  └─────────────┘      └──────────┘ └──────────┘   │发送NACK     │ │
</span></span><span class=line><span class=cl>│                                                   └─────────────┘ │
</span></span><span class=line><span class=cl>│  ┌─────────────┐      ┌──────────┐ ┌──────────┐   ┌─────────────┐ │
</span></span><span class=line><span class=cl>│  │数据包3      │─────▶│ Network  │─│ Network  │──▶│乱序缓存     │ │
</span></span><span class=line><span class=cl>│  │pkt=3,seq=200│      │Transport │ │Transport │   │等待pkt=2    │ │
</span></span><span class=line><span class=cl>│  └─────────────┘      └──────────┘ └──────────┘   └─────────────┘ │
</span></span><span class=line><span class=cl>│                                                                     │
</span></span><span class=line><span class=cl>└─────────────────────────────────────────────────────────────────────┘
</span></span></code></pre></td></tr></table></div></div><h4 id=545-双编号在重传中的应用>5.4.5 双编号在重传中的应用</h4><p><strong>NACK重传基于包号：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 基于包号的NACK重传
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpPktNack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>head</span><span class=p>[</span><span class=n>FILLP_HLEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>startPktNum</span><span class=p>;</span>    <span class=c1>// 丢失包起始包号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>endPktNum</span><span class=p>;</span>      <span class=c1>// 丢失包结束包号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 发送端接收NACK后的处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>FillpHandleNack</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>FillpPktNack</span> <span class=o>*</span><span class=n>nack</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>lostStart</span> <span class=o>=</span> <span class=nf>FILLP_NTOHL</span><span class=p>(</span><span class=n>nack</span><span class=o>-&gt;</span><span class=n>startPktNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>lostEnd</span> <span class=o>=</span> <span class=nf>FILLP_NTOHL</span><span class=p>(</span><span class=n>nack</span><span class=o>-&gt;</span><span class=n>endPktNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 根据包号范围查找需要重传的数据包
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>FILLP_UINT32</span> <span class=n>pktNum</span> <span class=o>=</span> <span class=n>lostStart</span><span class=p>;</span> <span class=n>pktNum</span> <span class=o>&lt;</span> <span class=n>lostEnd</span><span class=p>;</span> <span class=n>pktNum</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=n>item</span> <span class=o>=</span> <span class=nf>FillpFindItemByPktNum</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>pktNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>item</span> <span class=o>!=</span> <span class=n>FILLP_NULL_PTR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>FillpRetransmitItem</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>  <span class=c1>// 重传数据包
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>PACK确认基于序列号：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 基于序列号的PACK确认
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpPktPack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>head</span><span class=p>[</span><span class=n>FILLP_HLEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT16</span> <span class=n>flag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT16</span> <span class=n>pktLoss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>ackSeqNum</span><span class=p>;</span>      <span class=c1>// 确认的序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>rate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>oppositeSetRate</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 发送端接收PACK确认的处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>FillpHandlePack</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>FillpPktPack</span> <span class=o>*</span><span class=n>pack</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>ackSeq</span> <span class=o>=</span> <span class=nf>FILLP_NTOHL</span><span class=p>(</span><span class=n>pack</span><span class=o>-&gt;</span><span class=n>ackSeqNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 根据确认的序列号清理已确认的数据包
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>FillpCleanAckedItems</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>ackSeq</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 更新发送窗口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>unAckedSeqNum</span> <span class=o>=</span> <span class=n>ackSeq</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=546-双编号的优势>5.4.6 双编号的优势</h4><ol><li><strong>精确的丢包检测</strong>：包号提供准确的丢包位置信息</li><li><strong>高效的数据完整性保证</strong>：序列号确保数据按字节顺序</li><li><strong>灵活的重传控制</strong>：支持基于包号的选择性重传</li><li><strong>优化的确认机制</strong>：序列号确认减少确认包数量</li><li><strong>乱序处理能力</strong>：双编号支持复杂的乱序数据管理</li></ol><h4 id=547-双编号状态管理>5.4.7 双编号状态管理</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 发送端状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpSendPcb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>pktNum</span><span class=p>;</span>          <span class=c1>// 下一个要分配的包号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>seqNum</span><span class=p>;</span>          <span class=c1>// 下一个要分配的序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>unAckedPktNum</span><span class=p>;</span>   <span class=c1>// 最小未确认包号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>unAckedSeqNum</span><span class=p>;</span>   <span class=c1>// 最小未确认序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 接收端状态  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpRecvPcb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>expectedPktNum</span><span class=p>;</span>  <span class=c1>// 期望接收的包号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>expectedSeqNum</span><span class=p>;</span>  <span class=c1>// 期望接收的序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>maxRecvPktNum</span><span class=p>;</span>   <span class=c1>// 已接收的最大包号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>maxRecvSeqNum</span><span class=p>;</span>   <span class=c1>// 已接收的最大序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=6-流量控制机制>6. 流量控制机制</h2><h3 id=61-流控算法接口>6.1 流控算法接口</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 流控算法结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>FillpFlowControlAlg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>input</span><span class=p>)(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=o>*</span><span class=n>head</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>output</span><span class=p>)(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>FILLP_UINT32</span> <span class=p>(</span><span class=o>*</span><span class=n>getSendRate</span><span class=p>)(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... 其他算法接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 算法选择
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>struct</span> <span class=n>FillpFlowControlAlg</span> <span class=n>g_fillpFlowControlAlg</span><span class=p>[</span><span class=n>FILLP_ALG_MAX</span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=62-流量控制流程图>6.2 流量控制流程图</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>数据发送触发
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>检查流控状态
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ├─ 发送窗口已满？ ──Yes──▶ 等待PACK确认
</span></span><span class=line><span class=cl>    │                           │
</span></span><span class=line><span class=cl>    No                          ▼
</span></span><span class=line><span class=cl>    ▼                      更新发送窗口
</span></span><span class=line><span class=cl>计算发送速率                     │
</span></span><span class=line><span class=cl>    │                           │
</span></span><span class=line><span class=cl>    ▼                      ◀────┘
</span></span><span class=line><span class=cl>获取发送数据项
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>计算包间隔时间
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>发送数据包
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>启动重传定时器
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>更新流控统计信息
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>接收端PACK反馈
</span></span><span class=line><span class=cl>    │
</span></span><span class=line><span class=cl>    ▼
</span></span><span class=line><span class=cl>流控算法调整发送速率
</span></span></code></pre></td></tr></table></div></div><h3 id=63-发送速率控制>6.3 发送速率控制</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 计算发送间隔
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>FILLP_UINT32</span> <span class=nf>FillpCalculatePackInterval</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>rate</span> <span class=o>=</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>fcAlg</span><span class=o>-&gt;</span><span class=nf>getSendRate</span><span class=p>(</span><span class=n>pcb</span><span class=p>);</span>  <span class=c1>// 获取发送速率
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>pktSize</span> <span class=o>=</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>pktSize</span><span class=p>;</span>               <span class=c1>// 包大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// 计算包间隔: interval = (pktSize * 8 * 1000000) / rate (us)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=n>pktSize</span> <span class=o>*</span> <span class=mi>8</span> <span class=o>*</span> <span class=mi>1000000</span><span class=p>)</span> <span class=o>/</span> <span class=n>rate</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=64-pack包处理>6.4 PACK包处理</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_common.c:764 构建和发送PACK包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>FillpBuildAndSendPack</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>FtSocket</span> <span class=o>*</span><span class=n>ftSock</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                          <span class=k>struct</span> <span class=n>FillpPktPack</span> <span class=o>*</span><span class=n>pack</span><span class=p>,</span> <span class=n>FILLP_UINT16</span> <span class=n>dataLen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 设置PACK包头
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=o>*</span><span class=n>pktHead</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>FillpPktHead</span> <span class=o>*</span><span class=p>)</span><span class=n>pack</span><span class=o>-&gt;</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pktHead</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>=</span> <span class=nf>FILLP_HTONS</span><span class=p>(</span><span class=n>FILLP_PKT_TYPE_PACK</span> <span class=o>&lt;&lt;</span> <span class=n>FILLP_PKT_TYPE_OFFSET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 设置确认信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pack</span><span class=o>-&gt;</span><span class=n>lostSeq</span> <span class=o>=</span> <span class=nf>FILLP_HTONL</span><span class=p>(</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>seqNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pack</span><span class=o>-&gt;</span><span class=n>rate</span> <span class=o>=</span> <span class=nf>FILLP_HTONL</span><span class=p>(</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>flowControl</span><span class=p>.</span><span class=n>sendRate</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 发送PACK包（最终调用sendto）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ret</span> <span class=o>=</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=nf>sendFunc</span><span class=p>(</span><span class=nf>FILLP_GET_CONN</span><span class=p>(</span><span class=n>pcb</span><span class=p>),</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>pack</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                        <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPktPack</span><span class=p>),</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>spcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=7-rtt测量机制>7. RTT测量机制</h2><h3 id=71-rtt测量概述>7.1 RTT测量概述</h3><p>FILLP协议采用多种方式测量RTT（往返时延），主要包括：</p><ol><li><strong>连接建立期间的RTT测量</strong> - 基于四次握手过程</li><li><strong>数据传输期间的RTT测量</strong> - 基于PACK包交互</li><li><strong>ADHOC RTT测量</strong> - 主动RTT探测机制</li></ol><h3 id=72-连接建立期间rtt测量>7.2 连接建立期间RTT测量</h3><h4 id=721-四次握手rtt测量流程>7.2.1 四次握手RTT测量流程</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_conn.c:1346 客户端发送CONN_REQ时记录时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>req</span><span class=o>-&gt;</span><span class=n>timestamp</span> <span class=o>=</span> <span class=nf>FILLP_HTONLL</span><span class=p>((</span><span class=n>FILLP_ULLONG</span><span class=p>)</span><span class=n>curTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fillp_conn.c:1432 服务端在CONN_REQ_ACK中回传时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>FillpSendConnReqAck</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                        <span class=n>FILLP_CONST</span> <span class=n>FillpCookieContent</span> <span class=o>*</span><span class=n>stateCookie</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>FILLP_ULLONG</span> <span class=n>timestamp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reqAck</span><span class=o>-&gt;</span><span class=n>timestamp</span> <span class=o>=</span> <span class=nf>FILLP_HTONLL</span><span class=p>(</span><span class=n>timestamp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将客户端的时间戳原样返回
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fillp_conn.c:457 客户端收到CONN_REQ_ACK后计算RTT
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>FILLP_LLONG</span> <span class=n>curTime</span> <span class=o>=</span> <span class=nf>SYS_ARCH_GET_CUR_TIME_LONGLONG</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>FILLP_LLONG</span> <span class=n>rttTime</span> <span class=o>=</span> <span class=n>curTime</span> <span class=o>-</span> <span class=p>(</span><span class=n>FILLP_LLONG</span><span class=p>)</span><span class=n>reqAck</span><span class=p>.</span><span class=n>timestamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>rttTime</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span> <span class=o>=</span> <span class=p>(</span><span class=n>FILLP_ULLONG</span><span class=p>)</span><span class=n>rttTime</span><span class=p>;</span>  <span class=c1>// 保存RTT值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>FILLP_GET_CONN</span><span class=p>(</span><span class=n>pcb</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>calcRttDuringConnect</span> <span class=o>=</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=722-rtt计算公式>7.2.2 RTT计算公式</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>RTT = 当前时间 - 发送CONN_REQ的时间戳
</span></span><span class=line><span class=cl>    = T_recv_ack - T_send_req
</span></span></code></pre></td></tr></table></div></div><h3 id=73-pack包rtt测量机制>7.3 PACK包RTT测量机制</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_output.c:474-477 发送PACK包时携带RTT信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>((</span><span class=o>!</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>statistics</span><span class=p>.</span><span class=n>pack</span><span class=p>.</span><span class=n>peerRtt</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pack</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>|=</span> <span class=n>FILLP_PACK_FLAG_WITH_RTT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pack</span><span class=o>-&gt;</span><span class=n>reserved</span><span class=p>.</span><span class=n>rtt</span> <span class=o>=</span> <span class=p>(</span><span class=n>FILLP_UINT32</span><span class=p>)</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span><span class=p>;</span>  <span class=c1>// 将本端RTT告知对端
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fillp_output.c:480-482 请求对端发送RTT信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pack</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>|=</span> <span class=n>FILLP_PACK_FLAG_REQURE_RTT</span><span class=p>;</span>  <span class=c1>// 请求对端提供RTT
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fillp_input.c:666-672 处理收到的RTT信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>((</span><span class=n>pack</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>&amp;</span> <span class=n>FILLP_PACK_FLAG_WITH_RTT</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=o>!</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pack</span><span class=o>-&gt;</span><span class=n>reserved</span><span class=p>.</span><span class=n>rtt</span> <span class=o>=</span> <span class=nf>FILLP_NTOHL</span><span class=p>(</span><span class=n>pack</span><span class=o>-&gt;</span><span class=n>reserved</span><span class=p>.</span><span class=n>rtt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span> <span class=o>=</span> <span class=n>pack</span><span class=o>-&gt;</span><span class=n>reserved</span><span class=p>.</span><span class=n>rtt</span><span class=p>;</span>  <span class=c1>// 使用对端提供的RTT值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>FillpAdjustFcParamsByRtt</span><span class=p>(</span><span class=n>pcb</span><span class=p>);</span>  <span class=c1>// 根据RTT调整流控参数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=74-adhoc-rtt探测机制>7.4 ADHOC RTT探测机制</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_output.c:442-447 发送RTT探测包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pack</span><span class=p>.</span><span class=n>flag</span> <span class=o>=</span> <span class=n>FILLP_PACK_FLAG_ADHOC</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pack</span><span class=p>.</span><span class=n>flag</span> <span class=o>|=</span> <span class=n>FILLP_PACK_FLAG_REQURE_RTT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>pack</span><span class=p>.</span><span class=n>reserved</span><span class=p>.</span><span class=n>rtt</span> <span class=o>=</span> <span class=p>(</span><span class=n>FILLP_UINT32</span><span class=p>)((</span><span class=n>FILLP_ULLONG</span><span class=p>)</span><span class=n>curTime</span> <span class=o>&amp;</span> <span class=mh>0xFFFFFFFF</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 在ADHOC包中携带当前时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// fillp_input.c:593-612 处理RTT探测请求
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>pack</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>&amp;</span> <span class=n>FILLP_PACK_FLAG_REQURE_RTT</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>FillpPktPack</span> <span class=n>tmpPack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tmpPack</span><span class=p>.</span><span class=n>flag</span> <span class=o>=</span> <span class=n>FILLP_NULL_NUM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tmpPack</span><span class=p>.</span><span class=n>flag</span> <span class=o>|=</span> <span class=n>FILLP_PACK_FLAG_ADHOC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tmpPack</span><span class=p>.</span><span class=n>flag</span> <span class=o>|=</span> <span class=n>FILLP_PACK_FLAG_WITH_RTT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>tmpPack</span><span class=p>.</span><span class=n>reserved</span><span class=p>.</span><span class=n>rtt</span> <span class=o>=</span> <span class=nf>FILLP_NTOHL</span><span class=p>(</span><span class=n>pack</span><span class=o>-&gt;</span><span class=n>reserved</span><span class=p>.</span><span class=n>rtt</span><span class=p>);</span>  <span class=c1>// 回传时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 发送响应包
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>FillpBuildAndSendPack</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>ftSock</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tmpPack</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                         <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPktPack</span><span class=p>)</span> <span class=o>-</span> <span class=n>FILLP_HLEN</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=75-rtt在流量控制中的应用>7.5 RTT在流量控制中的应用</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_common.c:683-704 根据RTT调整尾包保护参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>FillpAjustTlpParameterByRtt</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> <span class=n>FILLP_LLONG</span> <span class=n>rtt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rtt</span> <span class=o>&lt;</span> <span class=n>FILLP_RTT_TIME_LEVEL1</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// RTT &lt; 200ms
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>tailProtect</span><span class=p>.</span><span class=n>minJudgeThreshold</span> <span class=o>=</span> <span class=n>FILLP_ONE_THIRD_OF_RTT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>tailProtect</span><span class=p>.</span><span class=n>maxJudgeThreshold</span> <span class=o>=</span> <span class=n>FILLP_ONE_THIRD_OF_RTT</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>rtt</span> <span class=o>&lt;</span> <span class=n>FILLP_RTT_TIME_LEVEL2</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// RTT &lt; 400ms
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>tailProtect</span><span class=p>.</span><span class=n>minJudgeThreshold</span> <span class=o>=</span> <span class=n>FILLP_ONE_FOURTH_OF_RTT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>tailProtect</span><span class=p>.</span><span class=n>maxJudgeThreshold</span> <span class=o>=</span> <span class=n>FILLP_ONE_FOURTH_OF_RTT</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  <span class=c1>// RTT &gt;= 400ms
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>tailProtect</span><span class=p>.</span><span class=n>minJudgeThreshold</span> <span class=o>=</span> <span class=n>FILLP_ONE_FIFTH_OF_RTT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>.</span><span class=n>tailProtect</span><span class=p>.</span><span class=n>maxJudgeThreshold</span> <span class=o>=</span> <span class=n>FILLP_ONE_FIFTH_OF_RTT</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fillp_common.c:722-726 根据RTT调整流控定时器
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>((</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span> <span class=o>/</span> <span class=n>FILLP_FC_RTT_PACK_RATIO</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>packInterval</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>FcTimerNode</span><span class=p>.</span><span class=n>interval</span> <span class=o>=</span> <span class=n>packInterval</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>FcTimerNode</span><span class=p>.</span><span class=n>interval</span> <span class=o>=</span> <span class=p>(</span><span class=n>FILLP_UINT32</span><span class=p>)(</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>rtt</span> <span class=o>/</span> <span class=n>FILLP_FC_RTT_PACK_RATIO</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=76-为什么fillp的rtt比实际网络时延要低>7.6 为什么FILLP的RTT比实际网络时延要低</h3><h4 id=761-测量粒度问题>7.6.1 测量粒度问题</h4><p><strong>问题1：应用层测量vs网络层真实时延</strong></p><p>FILLP的RTT测量是在应用层协议栈内部进行的，从数据包构建到数据包解析，而不是真正的网络传输时延：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>实际网络时延：
</span></span><span class=line><span class=cl>发送端网卡 → 网络传输 → 接收端网卡
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>FILLP测量的RTT：
</span></span><span class=line><span class=cl>发送端应用层 → UDP socket → 网络传输 → UDP socket → 接收端应用层
</span></span></code></pre></td></tr></table></div></div><h4 id=762-系统时钟精度和同步问题>7.6.2 系统时钟精度和同步问题</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fillp_conn.c:458-461 时间异常检查
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>FILLP_LLONG</span> <span class=n>rttTime</span> <span class=o>=</span> <span class=n>curTime</span> <span class=o>-</span> <span class=p>(</span><span class=n>FILLP_LLONG</span><span class=p>)</span><span class=n>reqAck</span><span class=p>.</span><span class=n>timestamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>rttTime</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>FILLP_LOGWAR</span><span class=p>(</span><span class=s>&#34;System Time has changed;curTime:%lld,reqTime:%llu&#34;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                <span class=n>curTime</span><span class=p>,</span> <span class=n>reqAck</span><span class=p>.</span><span class=n>timestamp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>  <span class=c1>// 系统时间变化导致计算异常
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=763-主要影响因素>7.6.3 主要影响因素</h4><ol><li><strong>测量层次问题</strong>：测量的是应用层到应用层的时延，而不是纯网络传输时延</li><li><strong>系统因素影响</strong>：系统时钟精度、协议栈处理延迟等因素影响测量准确性</li><li><strong>采样偏差</strong>：连接建立时的网络状况可能不代表数据传输时的真实情况</li><li><strong>算法简化</strong>：为了简化实现，可能采用了相对乐观的RTT估计方法</li></ol><hr><h2 id=8-重传和可靠性保证>8. 重传和可靠性保证</h2><h3 id=81-nack机制>8.1 NACK机制</h3><h4 id=811-丢包检测和nack发送>8.1.1 丢包检测和NACK发送</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 检测丢包并发送NACK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>FillpCheckAndSendNack</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                 <span class=n>FILLP_UINT32</span> <span class=n>expectedPktNum</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>FILLP_UINT32</span> <span class=n>receivedPktNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>receivedPktNum</span> <span class=o>&gt;</span> <span class=n>expectedPktNum</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 检测到丢包，发送NACK
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>struct</span> <span class=n>FillpPktNack</span> <span class=n>nack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>nack</span><span class=p>.</span><span class=n>lastPktNum</span> <span class=o>=</span> <span class=n>expectedPktNum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nf>FillpSendNack</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>nack</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 更新统计信息
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>statistics</span><span class=p>.</span><span class=n>traffic</span><span class=p>.</span><span class=n>totalRecvLost</span> <span class=o>+=</span> 
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>receivedPktNum</span> <span class=o>-</span> <span class=n>expectedPktNum</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=812-nack延迟发送机制>8.1.2 NACK延迟发送机制</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// NACK延迟发送机制
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>FillpNackDelayProcess</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>g_appResource</span><span class=p>.</span><span class=n>common</span><span class=p>.</span><span class=n>enableNackDelay</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>FILLP_LLONG</span> <span class=n>currentTime</span> <span class=o>=</span> <span class=nf>SYS_ARCH_GET_CUR_TIME_LONGLONG</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_LLONG</span> <span class=n>delayTimeout</span> <span class=o>=</span> <span class=n>g_appResource</span><span class=p>.</span><span class=n>common</span><span class=p>.</span><span class=n>nackDelayTimeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 检查是否超过延迟时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>((</span><span class=n>currentTime</span> <span class=o>-</span> <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>lastNackTime</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>delayTimeout</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>FillpSendDelayedNack</span><span class=p>(</span><span class=n>pcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=82-快速重传>8.2 快速重传</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 基于NACK的快速重传
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>FillpFastRetransmit</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> <span class=n>FILLP_UINT32</span> <span class=n>lostPktNum</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=n>item</span> <span class=o>=</span> <span class=nf>FillpFindUnackedItem</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>lostPktNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>item</span> <span class=o>!=</span> <span class=n>FILLP_NULL_PTR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 立即重传，不等定时器
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>item</span><span class=o>-&gt;</span><span class=n>sendCount</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>FillpSendItem</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 更新统计信息
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pcb</span><span class=o>-&gt;</span><span class=n>statistics</span><span class=p>.</span><span class=n>traffic</span><span class=p>.</span><span class=n>totalRetryed</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=83-乱序处理机制>8.3 乱序处理机制</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 处理乱序数据包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>FillpHandleOutOfOrderPacket</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                       <span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=n>item</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 插入到接收队列中，保持有序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>SkipListInsert</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>recv</span><span class=p>.</span><span class=n>recvList</span><span class=p>,</span> <span class=n>item</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>item</span><span class=o>-&gt;</span><span class=n>skipListNode</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                      <span class=n>FILLP_TRUE</span><span class=p>)</span> <span class=o>!=</span> <span class=n>ERR_OK</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>FILLP_LOGERR</span><span class=p>(</span><span class=s>&#34;Failed to insert out-of-order packet&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>FillpRecvDropItem</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 检查是否可以提交连续数据给应用层
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>FillpTryDeliverContinuousData</span><span class=p>(</span><span class=n>pcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=9-系统调用和性能优化>9. 系统调用和性能优化</h2><h3 id=91-udp系统调用封装>9.1 UDP系统调用封装</h3><h4 id=911-发送路径分析>9.1.1 发送路径分析</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// UDP发送函数实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>int</span> <span class=nf>SysioSendUdp</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=n>FILLP_CONST</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>FILLP_SIZE_T</span> <span class=n>size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>FILLP_SOCKADDR</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=n>FILLP_UINT16</span> <span class=n>destAddrLen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SysIoUdpSock</span> <span class=o>*</span><span class=n>udpSock</span> <span class=o>=</span> <span class=p>(</span><span class=n>SysIoUdpSock</span> <span class=o>*</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=cp>#if defined(FILLP_LINUX) &amp;&amp; !defined(FILLP_MAC)
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>FILLP_INT</span> <span class=n>flg</span> <span class=o>=</span> <span class=n>MSG_NOSIGNAL</span><span class=p>;</span>  <span class=c1>// 避免SIGPIPE信号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>FILLP_INT</span> <span class=n>flg</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>udpSock</span><span class=o>-&gt;</span><span class=n>connected</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 已连接socket使用send
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ret</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=nf>FILLP_SEND</span><span class=p>(</span><span class=n>udpSock</span><span class=o>-&gt;</span><span class=n>udpSock</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=p>(</span><span class=n>FILLP_INT</span><span class=p>)</span><span class=n>size</span><span class=p>,</span> <span class=n>flg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 未连接socket使用sendto
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ret</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=nf>FILLP_SENDTO</span><span class=p>(</span><span class=n>udpSock</span><span class=o>-&gt;</span><span class=n>udpSock</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>flg</span><span class=p>,</span> <span class=n>dest</span><span class=p>,</span> <span class=n>destAddrLen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=912-系统调用函数指针>9.1.2 系统调用函数指针</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 系统函数指针结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>FILLP_INT</span> <span class=p>(</span><span class=o>*</span><span class=n>sendtoCallbackFunc</span><span class=p>)(</span><span class=n>FILLP_INT</span> <span class=n>sockFd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                   <span class=n>FILLP_SIZE_T</span> <span class=n>len</span><span class=p>,</span> <span class=n>FILLP_INT</span> <span class=n>flags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>to</span><span class=p>,</span> <span class=n>FILLP_SIZE_T</span> <span class=n>toLen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>FILLP_INT</span> <span class=p>(</span><span class=o>*</span><span class=n>recvFromCallbackFunc</span><span class=p>)(</span><span class=n>FILLP_INT</span> <span class=n>sockFd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                     <span class=n>FILLP_SIZE_T</span> <span class=n>len</span><span class=p>,</span> <span class=n>FILLP_INT</span> <span class=n>flags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=kt>void</span> <span class=o>*</span><span class=n>from</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>fromLen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... 其他系统调用函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>FillpSysLibCallbackFuncSt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=n>FillpSysLibCallbackFuncSt</span> <span class=n>g_fillpOsSocketLibFun</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 宏定义简化调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define FILLP_SENDTO    (g_fillpOsSocketLibFun.sendtoCallbackFunc)
</span></span></span><span class=line><span class=cl><span class=cp>#define FILLP_RECVFROM  (g_fillpOsSocketLibFun.recvFromCallbackFunc)
</span></span></span></code></pre></td></tr></table></div></div><h3 id=92-性能优化要点>9.2 性能优化要点</h3><h4 id=921-零拷贝优化>9.2.1 零拷贝优化</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 使用内存池避免频繁分配释放
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>DympoolType</span> <span class=o>*</span><span class=n>g_fillpItemPool</span> <span class=o>=</span> <span class=n>FILLP_NULL_PTR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=nf>FillpAllocBufItem</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=p>)</span><span class=nf>DympoolAlloc</span><span class=p>(</span><span class=n>g_fillpItemPool</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FillpFreeBufItem</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=n>item</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>DympoolFree</span><span class=p>(</span><span class=n>g_fillpItemPool</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=922-无锁数据结构>9.2.2 无锁数据结构</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 使用无锁环形队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>LfRing</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SysArchAtomic</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SysArchAtomic</span> <span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_UINT32</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>**</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 原子操作保证线程安全
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>FILLP_BOOL</span> <span class=nf>LfRingPush</span><span class=p>(</span><span class=k>struct</span> <span class=n>LfRing</span> <span class=o>*</span><span class=n>ring</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>LfRingPop</span><span class=p>(</span><span class=k>struct</span> <span class=n>LfRing</span> <span class=o>*</span><span class=n>ring</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=923-批量发送优化>9.2.3 批量发送优化</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 批量处理减少系统调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>FillpBatchSend</span><span class=p>(</span><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>FillpPcbItem</span> <span class=o>*</span><span class=n>items</span><span class=p>[</span><span class=n>MAX_BATCH_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 批量获取发送项
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>&lt;</span> <span class=n>MAX_BATCH_SIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>items</span><span class=p>[</span><span class=n>count</span><span class=p>]</span> <span class=o>=</span> <span class=nf>FillpGetSendItem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pcb</span><span class=o>-&gt;</span><span class=n>send</span><span class=p>,</span> <span class=n>pcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>items</span><span class=p>[</span><span class=n>count</span><span class=p>]</span> <span class=o>==</span> <span class=n>FILLP_NULL_PTR</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 批量发送
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>FillpSendItem</span><span class=p>(</span><span class=n>pcb</span><span class=p>,</span> <span class=n>items</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=10-关键数据结构>10. 关键数据结构</h2><h3 id=101-socket相关结构>10.1 Socket相关结构</h3><h4 id=1011-ftsocket结构>10.1.1 FtSocket结构</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FtSocket</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_INT</span> <span class=n>index</span><span class=p>;</span>                    <span class=c1>// Socket索引
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_INT</span> <span class=n>allocState</span><span class=p>;</span>              <span class=c1>// 分配状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>FtNetconn</span> <span class=o>*</span><span class=n>netconn</span><span class=p>;</span>         <span class=c1>// 网络连接
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>errCode</span><span class=p>;</span>              <span class=c1>// 错误码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT16</span> <span class=n>dataOptionFlag</span><span class=p>;</span>       <span class=c1>// 数据选项标志
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_BOOL</span> <span class=n>isListenSock</span><span class=p>;</span>           <span class=c1>// 是否为监听socket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>HlistNode</span> <span class=n>listenNode</span><span class=p>;</span>       <span class=c1>// 监听节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SysArchAtomic</span> <span class=n>sendEventCount</span><span class=p>;</span>      <span class=c1>// 发送事件计数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SysArchAtomic</span> <span class=n>rcvEvent</span><span class=p>;</span>            <span class=c1>// 接收事件计数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ... 其他字段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=1012-ftnetconn结构>10.1.2 FtNetconn结构</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FtNetconn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>FtSocket</span> <span class=o>*</span><span class=n>sock</span><span class=p>;</span>             <span class=c1>// 关联的socket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>SpungePcb</span> <span class=o>*</span><span class=n>pcb</span><span class=p>;</span>             <span class=c1>// 协议控制块
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>SockOsSocket</span> <span class=o>*</span><span class=n>osSocket</span><span class=p>[</span><span class=n>MAX_SPUNGEINSTANCE_NUM</span><span class=p>];</span> <span class=c1>// 系统socket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT8</span> <span class=n>state</span><span class=p>;</span>                 <span class=c1>// 连接状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_BOOL</span> <span class=n>shutdownRdSet</span><span class=p>;</span>          <span class=c1>// 读关闭标志
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_BOOL</span> <span class=n>shutdownWrSet</span><span class=p>;</span>          <span class=c1>// 写关闭标志
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ... 其他字段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=102-协议控制块结构>10.2 协议控制块结构</h3><h4 id=1021-fillppcb主结构>10.2.1 FillpPcb主结构</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FillpPcb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>FillpSendPcb</span> <span class=n>send</span><span class=p>;</span>          <span class=c1>// 发送控制块
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>FillpRecvPcb</span> <span class=n>recv</span><span class=p>;</span>          <span class=c1>// 接收控制块
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>FillpFlowControl</span> <span class=n>fc</span><span class=p>;</span>        <span class=c1>// 流量控制
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>FillpTimers</span> <span class=n>timers</span><span class=p>;</span>         <span class=c1>// 定时器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>FillpStatisticsPcb</span> <span class=n>statistics</span><span class=p>;</span> <span class=c1>// 统计信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>sockaddr</span> <span class=n>remoteAddr</span><span class=p>;</span>       <span class=c1>// 远程地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>sockaddr</span> <span class=n>localAddr</span><span class=p>;</span>        <span class=c1>// 本地地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT16</span> <span class=n>pktSize</span><span class=p>;</span>             <span class=c1>// 包大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ... 流控算法相关字段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=1022-发送控制块>10.2.2 发送控制块</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FillpSendPcb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Hlist</span> <span class=n>unSendList</span><span class=p>;</span>           <span class=c1>// 未发送队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>SkipList</span> <span class=n>unrecvList</span><span class=p>;</span>        <span class=c1>// 未确认队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>SkipList</span> <span class=n>redunList</span><span class=p>;</span>         <span class=c1>// 冗余队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>seqNum</span><span class=p>;</span>              <span class=c1>// 当前序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>pktNum</span><span class=p>;</span>              <span class=c1>// 当前包号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>maxSendCache</span><span class=p>;</span>        <span class=c1>// 最大发送缓存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>unSendListBytes</span><span class=p>;</span>     <span class=c1>// 未发送字节数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>unrecvListBytes</span><span class=p>;</span>     <span class=c1>// 未确认字节数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ... 流控相关字段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=1023-接收控制块>10.2.3 接收控制块</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FillpRecvPcb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>SkipList</span> <span class=n>recvList</span><span class=p>;</span>          <span class=c1>// 接收队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>seqNum</span><span class=p>;</span>              <span class=c1>// 期望序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>pktNum</span><span class=p>;</span>              <span class=c1>// 期望包号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_UINT32</span> <span class=n>maxRecvCache</span><span class=p>;</span>        <span class=c1>// 最大接收缓存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>NackDelayList</span> <span class=n>nackList</span><span class=p>;</span>     <span class=c1>// NACK延迟列表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_LLONG</span> <span class=n>lastNackTime</span><span class=p>;</span>         <span class=c1>// 最后NACK时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ... 其他接收相关字段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=11-fillp传输协议流程总结>11. FILLP传输协议流程总结</h2><h3 id=111-完整传输流程概览>11.1 完整传输流程概览</h3><p>FILLP传输协议是一个基于UDP的可靠传输协议，其完整流程包括以下主要阶段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 协议栈初始化 → 2. 连接建立 → 3. 数据传输 → 4. 流量控制 → 5. 错误处理和重传 → 6. 连接关闭
</span></span></code></pre></td></tr></table></div></div><h3 id=112-详细流程分析>11.2 详细流程分析</h3><h4 id=1121-第一阶段协议栈初始化>11.2.1 第一阶段：协议栈初始化</h4><p><strong>关键步骤：</strong></p><ol><li><strong>资源初始化</strong>：<code>FtInit()</code> - 初始化全局资源、内存池、定时器等</li><li><strong>Socket创建</strong>：<code>FtSocket()</code> - 创建应用层socket，分配FtSocket结构</li><li><strong>PCB分配</strong>：分配FillpPcb协议控制块，初始化发送/接收队列</li><li><strong>系统Socket绑定</strong>：创建UDP socket，绑定到指定端口</li></ol><p><strong>关键数据结构初始化：</strong></p><ul><li>UnSendList（未发送队列）- 使用HList</li><li>UnAckList（未确认队列）- 使用SkipList</li><li>RecvList（接收队列）- 使用SkipList</li><li>时间轮定时器系统</li></ul><h4 id=1122-第二阶段连接建立四次握手>11.2.2 第二阶段：连接建立（四次握手）</h4><p><strong>客户端流程：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>FtConnect() → CONN_REQ → 等待CONN_REQ_ACK → CONN_CONFIRM → 等待CONN_CONFIRM_ACK → CONNECTED
</span></span></code></pre></td></tr></table></div></div><p><strong>服务端流程：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>FtListen() → 接收CONN_REQ → Cookie生成 → CONN_REQ_ACK → 接收CONN_CONFIRM → Cookie验证 → CONN_CONFIRM_ACK → CONNECTED
</span></span></code></pre></td></tr></table></div></div><p><strong>安全机制：</strong></p><ul><li>使用HMAC-SHA256生成Cookie防止SYN洪水攻击</li><li>时间戳机制用于RTT初始测量</li><li>连接参数协商（缓冲区大小、超时时间等）</li></ul><h4 id=1123-第三阶段数据传输>11.2.3 第三阶段：数据传输</h4><p><strong>发送流程：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用数据 → 分片处理 → 序列号分配 → FILLP头部封装 → 发送队列 → 流控检查 → UDP发送 → 重传管理
</span></span></code></pre></td></tr></table></div></div><p><strong>接收流程：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>UDP接收 → FILLP头部解析 → 序列号检查 → 乱序处理 → 接收队列 → 数据重组 → 应用层交付
</span></span></code></pre></td></tr></table></div></div><p><strong>关键机制：</strong></p><ul><li><strong>双编号系统</strong>：序列号（按字节）+ 包号（按包）</li><li><strong>乱序处理</strong>：接收队列维护数据包顺序</li><li><strong>数据完整性</strong>：基于序列号的数据完整性检查</li></ul><h4 id=1124-第四阶段流量控制>11.2.4 第四阶段：流量控制</h4><p><strong>流控算法选择：</strong></p><ul><li>ALG0-ALG3多种流控算法</li><li>根据网络条件自适应选择</li><li>支持带宽探测和拥塞避免</li></ul><p><strong>关键参数：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>发送速率</span> <span class=o>=</span> <span class=nf>f</span><span class=p>(</span><span class=n>RTT</span><span class=p>,</span> <span class=err>丢包率</span><span class=p>,</span> <span class=err>缓冲区状态</span><span class=p>,</span> <span class=err>对端反馈</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>包间隔时间</span> <span class=o>=</span> <span class=p>(</span><span class=err>包大小</span> <span class=o>*</span> <span class=mi>8</span> <span class=o>*</span> <span class=mi>1000000</span><span class=p>)</span> <span class=o>/</span> <span class=err>发送速率</span>
</span></span><span class=line><span class=cl><span class=err>窗口大小</span> <span class=o>=</span> <span class=nf>min</span><span class=p>(</span><span class=err>本地缓冲区</span><span class=p>,</span> <span class=err>对端接收窗口</span><span class=p>,</span> <span class=err>拥塞窗口</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>PACK包机制：</strong></p><ul><li>定期发送PACK包进行流控反馈</li><li>携带接收窗口、速率建议、RTT信息</li><li>用于发送端动态调整发送速率</li></ul><h4 id=1125-第五阶段错误处理和重传>11.2.5 第五阶段：错误处理和重传</h4><p><strong>丢包检测：</strong></p><ul><li>基于包号的gap检测</li><li>超时检测机制</li><li>重复确认检测</li></ul><p><strong>NACK重传：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>丢包检测 → NACK生成 → NACK发送（含延迟机制）→ 发送端接收NACK → 快速重传
</span></span></code></pre></td></tr></table></div></div><p><strong>重传策略：</strong></p><ul><li>快速重传：立即重传NACK指示的丢失包</li><li>超时重传：基于RTO的超时重传</li><li>冗余重传：关键数据的主动冗余发送</li></ul><h4 id=1126-第六阶段连接管理和监控>11.2.6 第六阶段：连接管理和监控</h4><p><strong>连接保活：</strong></p><ul><li>Keep-Alive定时器</li><li>PACK包心跳机制</li><li>连接状态监控</li></ul><p><strong>性能监控：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FillpStatisticsPcb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>FILLP_ULLONG</span> <span class=n>totalSend</span><span class=p>;</span>           <span class=c1>// 总发送包数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_ULLONG</span> <span class=n>totalSendBytes</span><span class=p>;</span>      <span class=c1>// 总发送字节数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_ULLONG</span> <span class=n>totalRecv</span><span class=p>;</span>           <span class=c1>// 总接收包数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_ULLONG</span> <span class=n>totalRecvBytes</span><span class=p>;</span>      <span class=c1>// 总接收字节数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_ULLONG</span> <span class=n>totalRetryed</span><span class=p>;</span>        <span class=c1>// 总重传次数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FILLP_ULLONG</span> <span class=n>totalRecvLost</span><span class=p>;</span>       <span class=c1>// 总丢包数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ... 更多统计信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=113-核心算法总结>11.3 核心算法总结</h3><h4 id=1131-rtt测量算法>11.3.1 RTT测量算法</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 连接建立RTT：基于握手时间戳
</span></span><span class=line><span class=cl>2. 数据传输RTT：基于PACK包反馈
</span></span><span class=line><span class=cl>3. 主动探测RTT：ADHOC机制
</span></span><span class=line><span class=cl>4. RTT平滑：可配置的平滑算法
</span></span></code></pre></td></tr></table></div></div><h4 id=1132-流量控制算法>11.3.2 流量控制算法</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 带宽探测：逐步增加发送速率
</span></span><span class=line><span class=cl>2. 拥塞检测：基于丢包率和RTT变化
</span></span><span class=line><span class=cl>3. 速率调整：根据网络反馈动态调整
</span></span><span class=line><span class=cl>4. 公平性保证：多连接间带宽公平分配
</span></span></code></pre></td></tr></table></div></div><h4 id=1133-可靠性保证算法>11.3.3 可靠性保证算法</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 序列号机制：保证数据顺序和完整性
</span></span><span class=line><span class=cl>2. 确认机制：PACK包确认已接收数据
</span></span><span class=line><span class=cl>3. 重传机制：NACK快速重传 + 超时重传
</span></span><span class=line><span class=cl>4. 流控集成：重传与流控的协调机制
</span></span></code></pre></td></tr></table></div></div><h3 id=114-系统调用映射>11.4 系统调用映射</h3><p><strong>发送路径系统调用：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>FtSend() → SockSendData() → FillpSendData() → FillpOutput() → SysioSendUdp() → sendto()
</span></span></code></pre></td></tr></table></div></div><p><strong>接收路径系统调用：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>recvfrom() → SysioFetchPacketUdp() → SpungePushRecvdDataToStack() → FillpDoInput() → FtRecv()
</span></span></code></pre></td></tr></table></div></div><p><strong>事件驱动：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>select()/epoll() → SpungeDoRecvCycle() → 数据包处理 → 应用层事件通知
</span></span></code></pre></td></tr></table></div></div><h3 id=115-传输协议特色>11.5 传输协议特色</h3><ol><li><p><strong>高性能设计</strong>：</p><ul><li>零拷贝优化</li><li>无锁数据结构</li><li>批量I/O处理</li><li>CPU亲和性优化</li></ul></li><li><p><strong>高可靠性</strong>：</p><ul><li>多层次错误检测</li><li>快速重传机制</li><li>连接状态管理</li><li>数据完整性保证</li></ul></li><li><p><strong>自适应性</strong>：</p><ul><li>动态流控算法</li><li>网络状况感知</li><li>参数自动调整</li><li>多场景适配</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li>Cookie防护机制</li><li>连接验证</li><li>防重放攻击</li><li>状态机保护</li></ul></li></ol><hr><h2 id=12-总结和展望>12. 总结和展望</h2><h3 id=121-fillp协议优势总结>12.1 FILLP协议优势总结</h3><h4 id=1211-技术优势>12.1.1 技术优势</h4><ol><li><p><strong>分层架构设计</strong>：</p><ul><li>应用API层提供标准Socket接口</li><li>协议实现层处理可靠性和流控</li><li>系统I/O层抽象底层网络操作</li><li>良好的模块化和可扩展性</li></ul></li><li><p><strong>可靠性保证机制</strong>：</p><ul><li>序列号和包号双重编号系统</li><li>NACK快速重传机制</li><li>基于Cookie的安全连接建立</li><li>乱序数据包缓存和重排</li></ul></li><li><p><strong>高性能优化</strong>：</p><ul><li>无锁数据结构和原子操作</li><li>内存池管理避免频繁分配</li><li>批量I/O操作减少系统调用</li><li>支持GSO等硬件加速特性</li></ul></li><li><p><strong>流量控制算法</strong>：</p><ul><li>多种流控算法支持(ALG0-ALG3)</li><li>自适应带宽探测</li><li>基于RTT和丢包率的动态调整</li><li>拥塞避免和控制机制</li></ul></li></ol><h4 id=1212-关键性能数据>12.1.2 关键性能数据</h4><ul><li><strong>最大连接数</strong>：可配置，默认64个并发连接</li><li><strong>缓冲区大小</strong>：发送/接收缓存可动态配置</li><li><strong>重传机制</strong>：基于NACK的快速重传，支持冗余传输</li><li><strong>流控精度</strong>：支持Kbps到Gbps级别的速率控制</li></ul><h4 id=1213-技术创新点>12.1.3 技术创新点</h4><ol><li><strong>双编号机制</strong>：序列号(按字节)和包号(按包)的双重编号</li><li><strong>Cookie安全机制</strong>：基于HMAC-SHA256的连接安全验证</li><li><strong>多层次流控</strong>：应用层、协议层、系统层的多级流量控制</li><li><strong>自适应算法</strong>：根据网络状况动态调整传输参数</li></ol><h3 id=122-适用场景分析>12.2 适用场景分析</h3><p>FILLP协议特别适用于以下场景：</p><ol><li><strong>高带宽长距离传输</strong>：卫星通信、跨洋数据传输</li><li><strong>实时音视频传输</strong>：支持帧级别的数据标识和优先级</li><li><strong>文件传输系统</strong>：大文件高效可靠传输</li><li><strong>分布式存储</strong>：数据复制和同步</li><li><strong>物联网通信</strong>：设备间高效数据交换</li><li><strong>边缘计算</strong>：边缘节点与云端的数据传输</li></ol><h3 id=123-局限性和挑战>12.3 局限性和挑战</h3><h4 id=1231-当前局限性>12.3.1 当前局限性</h4><ol><li><p><strong>RTT测量精度</strong>：</p><ul><li>受系统时钟和协议栈处理延迟影响</li><li>连接建立时RTT可能不代表传输时真实RTT</li><li>缺乏持续的RTT监测机制</li></ul></li><li><p><strong>资源消耗</strong>：</p><ul><li>维护多个队列和状态信息的内存开销</li><li>复杂的流控算法带来的CPU开销</li><li>多线程协调的同步开销</li></ul></li><li><p><strong>网络适应性</strong>：</p><ul><li>对网络质量变化的响应速度有限</li><li>在极端网络条件下的性能表现需要验证</li><li>跨网络类型（WiFi/4G/5G）的适应性</li></ul></li></ol><h4 id=1232-技术挑战>12.3.2 技术挑战</h4><ol><li><strong>多路径支持</strong>：当前主要基于单路径传输</li><li><strong>移动性支持</strong>：网络切换时的连接保持能力</li><li><strong>QoS保证</strong>：不同业务类型的服务质量保证</li><li><strong>大规模并发</strong>：超大规模连接的性能优化</li></ol><h3 id=124-改进建议和发展方向>12.4 改进建议和发展方向</h3><h4 id=1241-短期改进建议>12.4.1 短期改进建议</h4><ol><li><p><strong>RTT测量优化</strong>：</p><ul><li>引入持续RTT监测机制</li><li>使用指数加权移动平均平滑RTT抖动</li><li>区分应用RTT和网络RTT测量</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>更智能的内存池管理策略</li><li>增强批量操作支持</li><li>CPU亲和性和NUMA优化</li></ul></li><li><p><strong>可靠性增强</strong>：</p><ul><li>更完善的错误检测和恢复机制</li><li>增强的统计信息和调试功能</li><li>连接迁移和故障转移支持</li></ul></li></ol><h4 id=1242-长期发展方向>12.4.2 长期发展方向</h4><ol><li><p><strong>多路径传输</strong>：</p><ul><li>支持MPTCP类似的多路径并发传输</li><li>路径质量感知和动态路径选择</li><li>负载均衡和冗余传输</li></ul></li><li><p><strong>智能流控</strong>：</p><ul><li>基于机器学习的流控算法</li><li>网络状况预测和主动调整</li><li>业务感知的QoS保证</li></ul></li><li><p><strong>边缘计算支持</strong>：</p><ul><li>支持边缘节点的动态发现和连接</li><li>计算任务迁移时的连接保持</li><li>边缘缓存和数据预取优化</li></ul></li><li><p><strong>标准化和生态</strong>：</p><ul><li>推动FILLP协议的标准化</li><li>构建完善的开发工具链</li><li>建立性能测试和验证体系</li></ul></li></ol><h3 id=125-总结>12.5 总结</h3><p>FILLP协议作为一个基于UDP的高性能可靠传输协议，在设计上充分考虑了现代网络环境的特点和需求。通过本次深入分析，我们全面了解了：</p><ol><li><strong>完整的实现架构</strong>：从应用API到系统调用的五层架构设计</li><li><strong>详细的工作流程</strong>：连接建立、数据传输、流量控制的完整流程</li><li><strong>关键技术机制</strong>：RTT测量、重传机制、安全保证等核心技术</li><li><strong>性能优化策略</strong>：零拷贝、无锁结构、批量处理等优化手段</li></ol><p>FILLP协议在华为DSoftBus框架中发挥着重要作用，为分布式软总线提供了高效可靠的传输基础。随着5G、物联网、边缘计算等新兴技术的发展，FILLP协议有望在更多场景中发挥重要作用。</p><p>通过持续的技术创新和优化改进，FILLP协议将能够更好地适应未来网络环境的挑战，为构建高效、可靠、安全的分布式通信系统提供强有力的技术支撑。</p><hr><p><strong>文档信息</strong></p><ul><li><strong>文档版本</strong>: 1.0</li><li><strong>分析对象</strong>: OpenHarmony 5.0.2 DSoftBus FILLP协议实现</li><li><strong>代码路径</strong>: <code>components/nstackx/fillp/</code></li><li><strong>文档类型</strong>: 技术分析文档</li></ul><p>本文档基于对DSoftBus项目中FILLP协议源码的深度分析和多个专项文档的整合，全面展现了FILLP协议的设计思想、实现机制和传输流程，为理解和使用FILLP协议提供了完整的技术参考。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E5%8D%8F%E8%AE%AE/>协议</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2025 二进制</section><section class=powerby></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>