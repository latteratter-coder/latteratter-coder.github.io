<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='加电复位：CPU的"本能" 当按下开机键，CPU获得电力后，其行为由硬件设计预先决定：\n重置寄存器：将所有内部寄存器设置为已知的初始状态。\n进入实模式：x86架构CPU会进入实模式（Real Mode），在此模式下可直接访问最初的1MB内存，无内存保护或权限分级。\n执行第一条指令：CPU的程序计数器（CS:IP寄存器）被硬编码指向内存地址 0xFFFF0。该地址位于主板的BIOS（或现代计算机的UEFI）固件芯片中。\n至此，CPU只是机械地执行硬件设计好的步骤，对"内核"一无所知。\n第一棒：固件（BIOS/UEFI） CPU开始执行固件中的代码，其主要任务是：\n硬件自检（POST）：检查关键硬件（内存、显卡、键盘等）是否正常工作。\n初始化硬件：配置主板芯片组、磁盘控制器等。\n寻找引导程序：\nBIOS：按照预设顺序（如：U盘->硬盘）读取存储设备的第一个扇区（512字节），即主引导记录（MBR），并将其加载到内存地址 0x7C00 处。\nUEFI：更先进，直接从EFI系统分区中查找并加载扩展性更强的引导程序文件。\n移交控制权：CPU跳转到 0x7C00（或UEFI加载的引导程序地址），开始执行引导程序代码。\n第二棒：引导程序（Bootloader） MBR中的空间很小，通常只存放引导程序的第一阶段。其核心任务是加载功能更全的第二阶段引导程序（如GRUB、Windows Boot Manager）。\n第二阶段引导程序的工作：\n提供菜单：允许用户选择要启动的操作系统（如果有多个）。\n识别文件系统：具备解析磁盘文件系统（如EXT4, NTFS）的能力，而不仅仅是读写原始扇区。\n加载内核映像：根据配置，从文件系统中找到内核文件（如Linux的 /boot/vmlinuz-xxx），并将其读取到内存中合适的位置。\n准备内核运行环境：设置启动参数（如根文件系统位置、分辨率）。\n切换CPU模式：将CPU从实模式切换到现代的保护模式（Protected Mode） 或 长模式（Long Mode, 64位），以启用虚拟内存、权限保护等关键特性。\n跳转到内核：最后，引导程序跳转（jump） 到内核在内存中的入口地址，将控制权彻底交给内核。\n引导程序是内核的"引路人"，完成了从"找扇区"到"找文件"的关键跨越。\n第三棒：内核启动与初始化 内核启动是一个复杂的过程，可分为两个主要阶段：\n第一阶段：架构相关初始化（汇编） 这是内核最先执行的代码，直接与CPU硬件交互，通常用汇编语言编写：\n设置初始堆栈\n清除BSS段：将未初始化的全局变量区域清零。\n解压内核（如果需要）：许多发行版的内核映像是压缩过的（如vmlinuz），此阶段会进行自解压。\n启用分页（Paging）：建立初始页表，开启MMU（内存管理单元），让CPU使用虚拟内存地址。这是现代操作系统的基石。\n设置中断描述符表（IDT）：为处理硬件中断、异常和系统调用做好准备。\n跳转到主入口点：最终跳转到如 start_kernel() 这样的C语言函数，进入内核主体。\n第二阶段：通用内核初始化（C语言） start_kernel() 是内核初始化的"主函数"，它调用一系列初始化函数来构建整个操作系统：\nsched_init(): 初始化调度器，创建0号进程（idle进程）。\nmm_init(): 初始化内存管理系统（伙伴系统、slab分配器）。\ntrap_init() / init_IRQ(): 完善中断和异常处理机制。\ntime_init(): 初始化系统时钟，内核开始感知时间。\nvfs_caches_init(): 初始化虚拟文件系统（VFS），为挂载根文件系统做准备。\n挂载根文件系统：可能先挂载内存中的initramfs（临时根文件系统）来加载必要驱动，再挂载真正的根文件系统。\n启动第一个用户空间进程：这是内核初始化的最后一步。内核线程会尝试执行用户空间的 /sbin/init（或其链接，如 /lib/systemd/systemd）。这个进程成为所有用户进程的祖先（PID 1）。\n'><title>Linux内核启动流程</title><link rel=canonical href=https://latteratter-coder.github.io/p/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Linux内核启动流程"><meta property='og:description' content='加电复位：CPU的"本能" 当按下开机键，CPU获得电力后，其行为由硬件设计预先决定：\n重置寄存器：将所有内部寄存器设置为已知的初始状态。\n进入实模式：x86架构CPU会进入实模式（Real Mode），在此模式下可直接访问最初的1MB内存，无内存保护或权限分级。\n执行第一条指令：CPU的程序计数器（CS:IP寄存器）被硬编码指向内存地址 0xFFFF0。该地址位于主板的BIOS（或现代计算机的UEFI）固件芯片中。\n至此，CPU只是机械地执行硬件设计好的步骤，对"内核"一无所知。\n第一棒：固件（BIOS/UEFI） CPU开始执行固件中的代码，其主要任务是：\n硬件自检（POST）：检查关键硬件（内存、显卡、键盘等）是否正常工作。\n初始化硬件：配置主板芯片组、磁盘控制器等。\n寻找引导程序：\nBIOS：按照预设顺序（如：U盘->硬盘）读取存储设备的第一个扇区（512字节），即主引导记录（MBR），并将其加载到内存地址 0x7C00 处。\nUEFI：更先进，直接从EFI系统分区中查找并加载扩展性更强的引导程序文件。\n移交控制权：CPU跳转到 0x7C00（或UEFI加载的引导程序地址），开始执行引导程序代码。\n第二棒：引导程序（Bootloader） MBR中的空间很小，通常只存放引导程序的第一阶段。其核心任务是加载功能更全的第二阶段引导程序（如GRUB、Windows Boot Manager）。\n第二阶段引导程序的工作：\n提供菜单：允许用户选择要启动的操作系统（如果有多个）。\n识别文件系统：具备解析磁盘文件系统（如EXT4, NTFS）的能力，而不仅仅是读写原始扇区。\n加载内核映像：根据配置，从文件系统中找到内核文件（如Linux的 /boot/vmlinuz-xxx），并将其读取到内存中合适的位置。\n准备内核运行环境：设置启动参数（如根文件系统位置、分辨率）。\n切换CPU模式：将CPU从实模式切换到现代的保护模式（Protected Mode） 或 长模式（Long Mode, 64位），以启用虚拟内存、权限保护等关键特性。\n跳转到内核：最后，引导程序跳转（jump） 到内核在内存中的入口地址，将控制权彻底交给内核。\n引导程序是内核的"引路人"，完成了从"找扇区"到"找文件"的关键跨越。\n第三棒：内核启动与初始化 内核启动是一个复杂的过程，可分为两个主要阶段：\n第一阶段：架构相关初始化（汇编） 这是内核最先执行的代码，直接与CPU硬件交互，通常用汇编语言编写：\n设置初始堆栈\n清除BSS段：将未初始化的全局变量区域清零。\n解压内核（如果需要）：许多发行版的内核映像是压缩过的（如vmlinuz），此阶段会进行自解压。\n启用分页（Paging）：建立初始页表，开启MMU（内存管理单元），让CPU使用虚拟内存地址。这是现代操作系统的基石。\n设置中断描述符表（IDT）：为处理硬件中断、异常和系统调用做好准备。\n跳转到主入口点：最终跳转到如 start_kernel() 这样的C语言函数，进入内核主体。\n第二阶段：通用内核初始化（C语言） start_kernel() 是内核初始化的"主函数"，它调用一系列初始化函数来构建整个操作系统：\nsched_init(): 初始化调度器，创建0号进程（idle进程）。\nmm_init(): 初始化内存管理系统（伙伴系统、slab分配器）。\ntrap_init() / init_IRQ(): 完善中断和异常处理机制。\ntime_init(): 初始化系统时钟，内核开始感知时间。\nvfs_caches_init(): 初始化虚拟文件系统（VFS），为挂载根文件系统做准备。\n挂载根文件系统：可能先挂载内存中的initramfs（临时根文件系统）来加载必要驱动，再挂载真正的根文件系统。\n启动第一个用户空间进程：这是内核初始化的最后一步。内核线程会尝试执行用户空间的 /sbin/init（或其链接，如 /lib/systemd/systemd）。这个进程成为所有用户进程的祖先（PID 1）。\n'><meta property='og:url' content='https://latteratter-coder.github.io/p/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/'><meta property='og:site_name' content='二进制'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='进程'><meta property='article:published_time' content='2025-09-06T00:00:00+00:00'><meta property='article:modified_time' content='2025-09-06T00:00:00+00:00'><meta name=twitter:title content="Linux内核启动流程"><meta name=twitter:description content='加电复位：CPU的"本能" 当按下开机键，CPU获得电力后，其行为由硬件设计预先决定：\n重置寄存器：将所有内部寄存器设置为已知的初始状态。\n进入实模式：x86架构CPU会进入实模式（Real Mode），在此模式下可直接访问最初的1MB内存，无内存保护或权限分级。\n执行第一条指令：CPU的程序计数器（CS:IP寄存器）被硬编码指向内存地址 0xFFFF0。该地址位于主板的BIOS（或现代计算机的UEFI）固件芯片中。\n至此，CPU只是机械地执行硬件设计好的步骤，对"内核"一无所知。\n第一棒：固件（BIOS/UEFI） CPU开始执行固件中的代码，其主要任务是：\n硬件自检（POST）：检查关键硬件（内存、显卡、键盘等）是否正常工作。\n初始化硬件：配置主板芯片组、磁盘控制器等。\n寻找引导程序：\nBIOS：按照预设顺序（如：U盘->硬盘）读取存储设备的第一个扇区（512字节），即主引导记录（MBR），并将其加载到内存地址 0x7C00 处。\nUEFI：更先进，直接从EFI系统分区中查找并加载扩展性更强的引导程序文件。\n移交控制权：CPU跳转到 0x7C00（或UEFI加载的引导程序地址），开始执行引导程序代码。\n第二棒：引导程序（Bootloader） MBR中的空间很小，通常只存放引导程序的第一阶段。其核心任务是加载功能更全的第二阶段引导程序（如GRUB、Windows Boot Manager）。\n第二阶段引导程序的工作：\n提供菜单：允许用户选择要启动的操作系统（如果有多个）。\n识别文件系统：具备解析磁盘文件系统（如EXT4, NTFS）的能力，而不仅仅是读写原始扇区。\n加载内核映像：根据配置，从文件系统中找到内核文件（如Linux的 /boot/vmlinuz-xxx），并将其读取到内存中合适的位置。\n准备内核运行环境：设置启动参数（如根文件系统位置、分辨率）。\n切换CPU模式：将CPU从实模式切换到现代的保护模式（Protected Mode） 或 长模式（Long Mode, 64位），以启用虚拟内存、权限保护等关键特性。\n跳转到内核：最后，引导程序跳转（jump） 到内核在内存中的入口地址，将控制权彻底交给内核。\n引导程序是内核的"引路人"，完成了从"找扇区"到"找文件"的关键跨越。\n第三棒：内核启动与初始化 内核启动是一个复杂的过程，可分为两个主要阶段：\n第一阶段：架构相关初始化（汇编） 这是内核最先执行的代码，直接与CPU硬件交互，通常用汇编语言编写：\n设置初始堆栈\n清除BSS段：将未初始化的全局变量区域清零。\n解压内核（如果需要）：许多发行版的内核映像是压缩过的（如vmlinuz），此阶段会进行自解压。\n启用分页（Paging）：建立初始页表，开启MMU（内存管理单元），让CPU使用虚拟内存地址。这是现代操作系统的基石。\n设置中断描述符表（IDT）：为处理硬件中断、异常和系统调用做好准备。\n跳转到主入口点：最终跳转到如 start_kernel() 这样的C语言函数，进入内核主体。\n第二阶段：通用内核初始化（C语言） start_kernel() 是内核初始化的"主函数"，它调用一系列初始化函数来构建整个操作系统：\nsched_init(): 初始化调度器，创建0号进程（idle进程）。\nmm_init(): 初始化内存管理系统（伙伴系统、slab分配器）。\ntrap_init() / init_IRQ(): 完善中断和异常处理机制。\ntime_init(): 初始化系统时钟，内核开始感知时间。\nvfs_caches_init(): 初始化虚拟文件系统（VFS），为挂载根文件系统做准备。\n挂载根文件系统：可能先挂载内存中的initramfs（临时根文件系统）来加载必要驱动，再挂载真正的根文件系统。\n启动第一个用户空间进程：这是内核初始化的最后一步。内核线程会尝试执行用户空间的 /sbin/init（或其链接，如 /lib/systemd/systemd）。这个进程成为所有用户进程的祖先（PID 1）。\n'><link rel="shortcut icon" href=/favicon.svg></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><div class=site-meta><h1 class=site-name><a href=/>二进制</a></h1><h2 class=site-description>学无止境</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#第一阶段架构相关初始化汇编>第一阶段：架构相关初始化（汇编）</a></li><li><a href=#第二阶段通用内核初始化c语言>第二阶段：通用内核初始化（C语言）</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%BF%9B%E7%A8%8B/ style=background-color:#00acc1;color:#fff>进程</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/>Linux内核启动流程</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Sep 06, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>1 minute read</time></div></footer></div></header><section class=article-content><h1 id=加电复位cpu的本能>加电复位：CPU的"本能"</h1><p>当按下开机键，CPU获得电力后，其行为由硬件设计预先决定：</p><ol><li><p><strong>重置寄存器</strong>：将所有内部寄存器设置为已知的初始状态。</p></li><li><p><strong>进入实模式</strong>：x86架构CPU会进入<strong>实模式（Real Mode）</strong>，在此模式下可直接访问最初的1MB内存，无内存保护或权限分级。</p></li><li><p><strong>执行第一条指令</strong>：CPU的程序计数器（CS:IP寄存器）被硬编码指向内存地址 <strong><code>0xFFFF0</code></strong>。该地址位于主板的<strong>BIOS</strong>（或现代计算机的<strong>UEFI</strong>）固件芯片中。</p></li></ol><blockquote><p><strong>至此，CPU只是机械地执行硬件设计好的步骤，对"内核"一无所知。</strong></p></blockquote><h1 id=第一棒固件biosuefi>第一棒：固件（BIOS/UEFI）</h1><p>CPU开始执行固件中的代码，其主要任务是：</p><ol><li><p><strong>硬件自检（POST）</strong>：检查关键硬件（内存、显卡、键盘等）是否正常工作。</p></li><li><p><strong>初始化硬件</strong>：配置主板芯片组、磁盘控制器等。</p></li><li><p><strong>寻找引导程序</strong>：</p><ul><li><p><strong>BIOS</strong>：按照预设顺序（如：U盘->硬盘）读取存储设备的<strong>第一个扇区（512字节）</strong>，即<strong>主引导记录（MBR）</strong>，并将其加载到内存地址 <strong><code>0x7C00</code></strong> 处。</p></li><li><p><strong>UEFI</strong>：更先进，直接从<strong>EFI系统分区</strong>中查找并加载扩展性更强的引导程序文件。</p></li></ul></li><li><p><strong>移交控制权</strong>：CPU跳转到 <code>0x7C00</code>（或UEFI加载的引导程序地址），开始执行引导程序代码。</p></li></ol><h1 id=第二棒引导程序bootloader>第二棒：引导程序（Bootloader）</h1><p>MBR中的空间很小，通常只存放引导程序的<strong>第一阶段</strong>。其核心任务是加载功能更全的<strong>第二阶段</strong>引导程序（如GRUB、Windows Boot Manager）。</p><p>第二阶段引导程序的工作：</p><ol><li><p><strong>提供菜单</strong>：允许用户选择要启动的操作系统（如果有多个）。</p></li><li><p><strong>识别文件系统</strong>：具备解析磁盘文件系统（如EXT4, NTFS）的能力，而不仅仅是读写原始扇区。</p></li><li><p><strong>加载内核映像</strong>：根据配置，从文件系统中找到<strong>内核文件</strong>（如Linux的 <code>/boot/vmlinuz-xxx</code>），并将其读取到内存中合适的位置。</p></li><li><p><strong>准备内核运行环境</strong>：设置启动参数（如根文件系统位置、分辨率）。</p></li><li><p><strong>切换CPU模式</strong>：将CPU从<strong>实模式</strong>切换到现代的<strong>保护模式（Protected Mode）</strong> 或 <strong>长模式（Long Mode, 64位）</strong>，以启用虚拟内存、权限保护等关键特性。</p></li><li><p><strong>跳转到内核</strong>：最后，引导程序<strong>跳转（jump）</strong> 到内核在内存中的入口地址，将控制权彻底交给内核。</p></li></ol><blockquote><p><strong>引导程序是内核的"引路人"，完成了从"找扇区"到"找文件"的关键跨越。</strong></p></blockquote><h1 id=第三棒内核启动与初始化>第三棒：内核启动与初始化</h1><p>内核启动是一个复杂的过程，可分为两个主要阶段：</p><h2 id=第一阶段架构相关初始化汇编>第一阶段：架构相关初始化（汇编）</h2><p>这是内核最先执行的代码，直接与CPU硬件交互，通常用汇编语言编写：</p><ul><li><p><strong>设置初始堆栈</strong></p></li><li><p><strong>清除BSS段</strong>：将未初始化的全局变量区域清零。</p></li><li><p><strong>解压内核</strong>（如果需要）：许多发行版的内核映像是压缩过的（如<code>vmlinuz</code>），此阶段会进行自解压。</p></li><li><p><strong>启用分页（Paging）</strong>：建立初始页表，开启MMU（内存管理单元），让CPU使用<strong>虚拟内存地址</strong>。这是现代操作系统的基石。</p></li><li><p><strong>设置中断描述符表（IDT）</strong>：为处理硬件中断、异常和系统调用做好准备。</p></li><li><p><strong>跳转到主入口点</strong>：最终跳转到如 <code>start_kernel()</code> 这样的C语言函数，进入内核主体。</p></li></ul><h2 id=第二阶段通用内核初始化c语言>第二阶段：通用内核初始化（C语言）</h2><p><code>start_kernel()</code> 是内核初始化的"主函数"，它调用一系列初始化函数来构建整个操作系统：</p><ul><li><p><code>sched_init()</code>: 初始化<strong>调度器</strong>，创建0号进程（<code>idle</code>进程）。</p></li><li><p><code>mm_init()</code>: 初始化<strong>内存管理</strong>系统（伙伴系统、slab分配器）。</p></li><li><p><code>trap_init()</code> / <code>init_IRQ()</code>: 完善<strong>中断和异常处理</strong>机制。</p></li><li><p><code>time_init()</code>: 初始化<strong>系统时钟</strong>，内核开始感知时间。</p></li><li><p><code>vfs_caches_init()</code>: 初始化<strong>虚拟文件系统（VFS）</strong>，为挂载根文件系统做准备。</p></li><li><p><strong>挂载根文件系统</strong>：可能先挂载内存中的<code>initramfs</code>（临时根文件系统）来加载必要驱动，再挂载真正的根文件系统。</p></li><li><p><strong>启动第一个用户空间进程</strong>：这是内核初始化的<strong>最后一步</strong>。内核线程会尝试执行用户空间的 <code>/sbin/init</code>（或其链接，如 <code>/lib/systemd/systemd</code>）。这个进程成为所有用户进程的祖先（PID 1）。</p></li></ul><blockquote><p><strong>一旦 <code>/sbin/init</code> 被执行，内核的启动过程就正式结束，控制权交给了用户空间。</strong></p></blockquote><h1 id=内核启动后它是后台运行吗>内核启动后，它是后台运行吗？</h1><p><strong>答案是：否。内核不是一个在"后台"运行的进程。</strong></p><p>这是一个关键区别。内核的运行方式与普通程序（前台或后台）有本质不同：</p><p><strong>内核是：</strong></p><ol><li><p><strong>常驻内存的代码和数据</strong>：内核始终驻留在物理内存的受保护区域（内核空间）。</p></li><li><p><strong>被动的执行环境和服务提供者</strong>：内核自身不会主动持续运行。它的代码在以下三种情况下被<strong>被动调用</strong>：</p><ul><li><p><strong>系统调用（Syscall）</strong>：应用程序主动请求操作系统服务（如读写文件），通过指令（如<code>syscall</code>）陷入内核。</p></li><li><p><strong>硬件中断（Interrupt）</strong>：硬件设备需要CPU关注（如网卡收到数据、时钟滴答），触发CPU执行对应的<strong>中断处理程序</strong>。</p></li><li><p><strong>异常（Exception）</strong>：CPU执行指令时发生错误（如除零），由内核的异常处理程序处理。</p></li></ul></li><li><p><strong>所有进程的"底层"</strong>：每个用户进程都像是在内核这个"地基"上建立的"房子"。当需要执行特权操作时，进程就"陷入"地基（内核）中寻求帮助。</p></li></ol><div class=table-wrapper><table><thead><tr><th>特征</th><th>用户进程（前台/后台）</th><th>内核</th><th></th></tr></thead><tbody><tr><td><strong>运行方式</strong></td><td>主动执行自己的代码流</td><td>被动响应（系统调用、中断、异常）</td><td></td></tr><tr><td><strong>存在形式</strong></td><td>进程列表中的一个实体</td><td>常驻内存的代码和数据结构，是进程运行的<strong>环境</strong></td><td></td></tr><tr><td><strong>CPU模式</strong></td><td>用户态</td><td>内核态（当被调用时）</td><td></td></tr><tr><td><strong>如何结束</strong></td><td>调用<code>exit()</code>或被杀掉</td><td><strong>永不结束</strong>，直到计算机关机</td><td></td></tr></tbody></table></div><h1 id=总结与类比>总结与类比</h1><p>计算机启动过程就像一场精心设计的接力赛：</p><ul><li><p><strong>CPU</strong>：是运动员，只有跑步的本能。</p></li><li><p><strong>BIOS/UEFI</strong>：是第一棒教练（接生婆），确保运动员健康并把他交给下一棒。</p></li><li><p><strong>引导程序（GRUB等）</strong>：是第二棒领跑员（家庭教师），带领运动员到正确的位置并交棒。</p></li><li><p><strong>内核</strong>：是第三棒运动员兼体育场建筑师（大学），它接管比赛，并首先建造整个体育场（初始化系统），然后制定规则（系统调用），裁判比赛（调度进程）。</p></li><li><p><strong><code>init</code> / <code>systemd</code></strong>：是赛后活动组织者，根据规则启动各种游戏和服务（用户进程）。</p></li></ul><p>内核并非后台守护进程，而是<strong>系统的基石</strong>。它静默地存在于内存中，等待被应用程序和硬件事件调用，从而为所有程序提供安全、可靠、统一的硬件访问和管理服务。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E8%BF%9B%E7%A8%8B/>进程</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E7%9A%84/><div class=article-details><h2 class=article-title>内核是如何管理进程的</h2></div></a></article><article><a href=/p/%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%96%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B/><div class=article-details><h2 class=article-title>加载一个新程序的过程</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2025 二进制</section><section class=powerby></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>