<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="内存踩踏现象分析报告 - A操作B内存但A不崩溃，B访问时崩溃 📋 目录 问题背景 现象分析 测试验证 技术原理 实际案例 检测方法 防护措施 完整测试代码 问题背景 🔍 核心问题 是否存在A、B两个变量，A操作了B的内存，但是A没有崩溃，而B去正常访问自己的内容时崩溃的情况？\n这个问题指向了一个非常重要的内存安全概念：**内存踩踏（Memory Corruption）**的延迟效应。\n🎯 问题的实际意义 这种现象在实际软件开发中经常遇到，特别是：\n系统崩溃难以定位：崩溃点不是真正的问题根源 间歇性bug：同样的操作有时崩溃有时不崩溃 多线程环境：一个线程的错误导致另一个线程崩溃 现象分析 ✅ 答案：确实存在这种情况！ 这种现象不仅存在，而且在实际开发中相当常见。主要原因包括：\n内存布局的特殊性 操作系统内存保护的延迟性 内存管理机制的复杂性 编译器优化的影响 📊 典型场景分析 场景类型 A的操作 A的结果 B的操作 B的结果 堆内存踩踏 越界写入32字节 ✅ 不崩溃 realloc() 💥 崩溃 栈帧破坏 栈溢出 ✅ 不崩溃 函数返回 💥 崩溃 函数指针篡改 修改函数指针表 ✅ 不崩溃 调用函数指针 💥 执行错误代码 多线程竞争 越界写共享内存 ✅ 不崩溃 读取被踩踏区域 💥 崩溃 测试验证 🧪 实验设计 我们设计了5个测试场景来验证这种现象：\n"><title>内存踩踏现象</title><link rel=canonical href=https://latteratter-coder.github.io/p/%E5%86%85%E5%AD%98%E8%B8%A9%E8%B8%8F%E7%8E%B0%E8%B1%A1/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="内存踩踏现象"><meta property='og:description' content="内存踩踏现象分析报告 - A操作B内存但A不崩溃，B访问时崩溃 📋 目录 问题背景 现象分析 测试验证 技术原理 实际案例 检测方法 防护措施 完整测试代码 问题背景 🔍 核心问题 是否存在A、B两个变量，A操作了B的内存，但是A没有崩溃，而B去正常访问自己的内容时崩溃的情况？\n这个问题指向了一个非常重要的内存安全概念：**内存踩踏（Memory Corruption）**的延迟效应。\n🎯 问题的实际意义 这种现象在实际软件开发中经常遇到，特别是：\n系统崩溃难以定位：崩溃点不是真正的问题根源 间歇性bug：同样的操作有时崩溃有时不崩溃 多线程环境：一个线程的错误导致另一个线程崩溃 现象分析 ✅ 答案：确实存在这种情况！ 这种现象不仅存在，而且在实际开发中相当常见。主要原因包括：\n内存布局的特殊性 操作系统内存保护的延迟性 内存管理机制的复杂性 编译器优化的影响 📊 典型场景分析 场景类型 A的操作 A的结果 B的操作 B的结果 堆内存踩踏 越界写入32字节 ✅ 不崩溃 realloc() 💥 崩溃 栈帧破坏 栈溢出 ✅ 不崩溃 函数返回 💥 崩溃 函数指针篡改 修改函数指针表 ✅ 不崩溃 调用函数指针 💥 执行错误代码 多线程竞争 越界写共享内存 ✅ 不崩溃 读取被踩踏区域 💥 崩溃 测试验证 🧪 实验设计 我们设计了5个测试场景来验证这种现象：\n"><meta property='og:url' content='https://latteratter-coder.github.io/p/%E5%86%85%E5%AD%98%E8%B8%A9%E8%B8%8F%E7%8E%B0%E8%B1%A1/'><meta property='og:site_name' content='二进制'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='内存'><meta property='article:published_time' content='2025-09-12T00:00:00+00:00'><meta property='article:modified_time' content='2025-09-12T00:00:00+00:00'><meta name=twitter:title content="内存踩踏现象"><meta name=twitter:description content="内存踩踏现象分析报告 - A操作B内存但A不崩溃，B访问时崩溃 📋 目录 问题背景 现象分析 测试验证 技术原理 实际案例 检测方法 防护措施 完整测试代码 问题背景 🔍 核心问题 是否存在A、B两个变量，A操作了B的内存，但是A没有崩溃，而B去正常访问自己的内容时崩溃的情况？\n这个问题指向了一个非常重要的内存安全概念：**内存踩踏（Memory Corruption）**的延迟效应。\n🎯 问题的实际意义 这种现象在实际软件开发中经常遇到，特别是：\n系统崩溃难以定位：崩溃点不是真正的问题根源 间歇性bug：同样的操作有时崩溃有时不崩溃 多线程环境：一个线程的错误导致另一个线程崩溃 现象分析 ✅ 答案：确实存在这种情况！ 这种现象不仅存在，而且在实际开发中相当常见。主要原因包括：\n内存布局的特殊性 操作系统内存保护的延迟性 内存管理机制的复杂性 编译器优化的影响 📊 典型场景分析 场景类型 A的操作 A的结果 B的操作 B的结果 堆内存踩踏 越界写入32字节 ✅ 不崩溃 realloc() 💥 崩溃 栈帧破坏 栈溢出 ✅ 不崩溃 函数返回 💥 崩溃 函数指针篡改 修改函数指针表 ✅ 不崩溃 调用函数指针 💥 执行错误代码 多线程竞争 越界写共享内存 ✅ 不崩溃 读取被踩踏区域 💥 崩溃 测试验证 🧪 实验设计 我们设计了5个测试场景来验证这种现象：\n"><link rel="shortcut icon" href=/favicon.svg></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><div class=site-meta><h1 class=site-name><a href=/>二进制</a></h1><h2 class=site-description>学无止境</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#-目录>📋 目录</a></li><li><a href=#问题背景>问题背景</a><ol><li><a href=#-核心问题>🔍 <strong>核心问题</strong></a></li><li><a href=#-问题的实际意义>🎯 <strong>问题的实际意义</strong></a></li></ol></li><li><a href=#现象分析>现象分析</a><ol><li><a href=#-答案确实存在这种情况>✅ <strong>答案：确实存在这种情况！</strong></a></li><li><a href=#-典型场景分析>📊 <strong>典型场景分析</strong></a></li></ol></li><li><a href=#测试验证>测试验证</a><ol><li><a href=#-实验设计>🧪 <strong>实验设计</strong></a><ol><li><a href=#1-相邻全局数组测试>1. <strong>相邻全局数组测试</strong></a></li><li><a href=#2-堆内存踩踏测试->2. <strong>堆内存踩踏测试</strong> ⭐</a></li><li><a href=#3-栈内存踩踏测试>3. <strong>栈内存踩踏测试</strong></a></li><li><a href=#4-函数指针表踩踏>4. <strong>函数指针表踩踏</strong></a></li><li><a href=#5-多线程内存踩踏>5. <strong>多线程内存踩踏</strong></a></li></ol></li><li><a href=#-实际测试结果>📈 <strong>实际测试结果</strong></a></li></ol></li><li><a href=#技术原理>技术原理</a><ol><li><a href=#-为什么a不崩溃>🔬 <strong>为什么A不崩溃？</strong></a><ol><li><a href=#1-内存保护的粒度限制>1. <strong>内存保护的粒度限制</strong></a></li><li><a href=#2-堆管理结构的位置>2. <strong>堆管理结构的位置</strong></a></li><li><a href=#3-写入操作的特性>3. <strong>写入操作的特性</strong></a></li></ol></li><li><a href=#-为什么b会崩溃>💥 <strong>为什么B会崩溃？</strong></a><ol><li><a href=#1-堆管理结构被破坏>1. <strong>堆管理结构被破坏</strong></a></li><li><a href=#2-数据结构一致性检查>2. <strong>数据结构一致性检查</strong></a></li><li><a href=#3-延迟的内存访问>3. <strong>延迟的内存访问</strong></a></li></ol></li></ol></li><li><a href=#实际案例>实际案例</a><ol><li><a href=#-你提到的softbus_>🔍 <strong>你提到的softbus_server崩溃</strong></a></li><li><a href=#-排查建议>🔧 <strong>排查建议</strong></a></li></ol></li><li><a href=#检测方法>检测方法</a><ol><li><a href=#-编译时检测>🛠️ <strong>编译时检测</strong></a><ol><li><a href=#1-addresssanitizer>1. <strong>AddressSanitizer</strong></a></li><li><a href=#2-valgrind>2. <strong>Valgrind</strong></a></li><li><a href=#3-静态分析工具>3. <strong>静态分析工具</strong></a></li></ol></li><li><a href=#-运行时检测>🕵️ <strong>运行时检测</strong></a><ol><li><a href=#1-内存模式检测>1. <strong>内存模式检测</strong></a></li><li><a href=#2-函数指针有效性检查>2. <strong>函数指针有效性检查</strong></a></li><li><a href=#3-内存分配跟踪>3. <strong>内存分配跟踪</strong></a></li></ol></li></ol></li><li><a href=#防护措施>防护措施</a><ol><li><a href=#-编程实践>🛡️ <strong>编程实践</strong></a><ol><li><a href=#1-边界检查>1. <strong>边界检查</strong></a></li><li><a href=#2-使用安全的api>2. <strong>使用安全的API</strong></a></li><li><a href=#3-raii和智能指针c>3. <strong>RAII和智能指针（C++）</strong></a></li></ol></li><li><a href=#-系统级防护>🔒 <strong>系统级防护</strong></a><ol><li><a href=#1-栈保护>1. <strong>栈保护</strong></a></li><li><a href=#2-aslr地址空间布局随机化>2. <strong>ASLR（地址空间布局随机化）</strong></a></li><li><a href=#3-depnx-bit数据执行保护>3. <strong>DEP/NX bit（数据执行保护）</strong></a></li></ol></li><li><a href=#-测试策略>🧪 <strong>测试策略</strong></a><ol><li><a href=#1-模糊测试fuzzing>1. <strong>模糊测试（Fuzzing）</strong></a></li><li><a href=#2-压力测试>2. <strong>压力测试</strong></a></li><li><a href=#3-代码审查重点>3. <strong>代码审查重点</strong></a></li></ol></li></ol></li><li><a href=#完整测试代码>完整测试代码</a><ol><li><a href=#-文件结构>📁 <strong>文件结构</strong></a></li><li><a href=#-核心测试代码>💻 <strong>核心测试代码</strong></a></li><li><a href=#-编译和运行>🚀 <strong>编译和运行</strong></a></li><li><a href=#-预期输出>📊 <strong>预期输出</strong></a></li></ol></li><li><a href=#-结论>📝 结论</a><ol><li><a href=#-核心发现>🎯 <strong>核心发现</strong></a></li><li><a href=#-技术总结>🔬 <strong>技术总结</strong></a></li><li><a href=#-对你的softbus_>⚠️ <strong>对你的softbus_server问题的启示</strong></a></li><li><a href=#-防护建议>💡 <strong>防护建议</strong></a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E5%86%85%E5%AD%98/ style=background-color:#4285f4;color:#fff>内存</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E5%86%85%E5%AD%98%E8%B8%A9%E8%B8%8F%E7%8E%B0%E8%B1%A1/>内存踩踏现象</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Sep 12, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>6 minute read</time></div></footer></div></header><section class=article-content><h1 id=内存踩踏现象分析报告---a操作b内存但a不崩溃b访问时崩溃>内存踩踏现象分析报告 - A操作B内存但A不崩溃，B访问时崩溃</h1><h2 id=-目录>📋 目录</h2><ul><li><a class=link href=#%e9%97%ae%e9%a2%98%e8%83%8c%e6%99%af>问题背景</a></li><li><a class=link href=#%e7%8e%b0%e8%b1%a1%e5%88%86%e6%9e%90>现象分析</a></li><li><a class=link href=#%e6%b5%8b%e8%af%95%e9%aa%8c%e8%af%81>测试验证</a></li><li><a class=link href=#%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86>技术原理</a></li><li><a class=link href=#%e5%ae%9e%e9%99%85%e6%a1%88%e4%be%8b>实际案例</a></li><li><a class=link href=#%e6%a3%80%e6%b5%8b%e6%96%b9%e6%b3%95>检测方法</a></li><li><a class=link href=#%e9%98%b2%e6%8a%a4%e6%8e%aa%e6%96%bd>防护措施</a></li><li><a class=link href=#%e5%ae%8c%e6%95%b4%e6%b5%8b%e8%af%95%e4%bb%a3%e7%a0%81>完整测试代码</a></li></ul><hr><h2 id=问题背景>问题背景</h2><h3 id=-核心问题>🔍 <strong>核心问题</strong></h3><blockquote><p>是否存在A、B两个变量，A操作了B的内存，但是A没有崩溃，而B去正常访问自己的内容时崩溃的情况？</p></blockquote><p>这个问题指向了一个非常重要的内存安全概念：**内存踩踏（Memory Corruption）**的延迟效应。</p><h3 id=-问题的实际意义>🎯 <strong>问题的实际意义</strong></h3><p>这种现象在实际软件开发中经常遇到，特别是：</p><ul><li><strong>系统崩溃难以定位</strong>：崩溃点不是真正的问题根源</li><li><strong>间歇性bug</strong>：同样的操作有时崩溃有时不崩溃</li><li><strong>多线程环境</strong>：一个线程的错误导致另一个线程崩溃</li></ul><hr><h2 id=现象分析>现象分析</h2><h3 id=-答案确实存在这种情况>✅ <strong>答案：确实存在这种情况！</strong></h3><p>这种现象不仅存在，而且在实际开发中相当常见。主要原因包括：</p><ol><li><strong>内存布局的特殊性</strong></li><li><strong>操作系统内存保护的延迟性</strong></li><li><strong>内存管理机制的复杂性</strong></li><li><strong>编译器优化的影响</strong></li></ol><h3 id=-典型场景分析>📊 <strong>典型场景分析</strong></h3><div class=table-wrapper><table><thead><tr><th>场景类型</th><th>A的操作</th><th>A的结果</th><th>B的操作</th><th>B的结果</th></tr></thead><tbody><tr><td><strong>堆内存踩踏</strong></td><td>越界写入32字节</td><td>✅ 不崩溃</td><td>realloc()</td><td>💥 崩溃</td></tr><tr><td><strong>栈帧破坏</strong></td><td>栈溢出</td><td>✅ 不崩溃</td><td>函数返回</td><td>💥 崩溃</td></tr><tr><td><strong>函数指针篡改</strong></td><td>修改函数指针表</td><td>✅ 不崩溃</td><td>调用函数指针</td><td>💥 执行错误代码</td></tr><tr><td><strong>多线程竞争</strong></td><td>越界写共享内存</td><td>✅ 不崩溃</td><td>读取被踩踏区域</td><td>💥 崩溃</td></tr></tbody></table></div><hr><h2 id=测试验证>测试验证</h2><h3 id=-实验设计>🧪 <strong>实验设计</strong></h3><p>我们设计了5个测试场景来验证这种现象：</p><h4 id=1-相邻全局数组测试>1. <strong>相邻全局数组测试</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>global_A</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>global_B</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A通过越界访问修改B的内存
</span></span></span><span class=line><span class=cl><span class=c1>// B正常访问自己的内存时可能崩溃
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-堆内存踩踏测试->2. <strong>堆内存踩踏测试</strong> ⭐</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>heap_A</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>heap_B</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A越界写入32字节，破坏堆管理结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>memset</span><span class=p>(</span><span class=n>heap_A</span><span class=p>,</span> <span class=sc>&#39;X&#39;</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>  <span class=c1>// A不崩溃
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// B进行正常内存操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>heap_B</span> <span class=o>=</span> <span class=nf>realloc</span><span class=p>(</span><span class=n>heap_B</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>  <span class=c1>// B崩溃！
</span></span></span></code></pre></td></tr></table></div></div><h4 id=3-栈内存踩踏测试>3. <strong>栈内存踩踏测试</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>function_A</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 栈溢出，破坏其他栈帧
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>overflow</span><span class=p>[</span><span class=mi>2048</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>overflow</span><span class=p>,</span> <span class=sc>&#39;X&#39;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>overflow</span><span class=p>));</span>  <span class=c1>// A不崩溃
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>function_B</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>local_data</span><span class=p>[</span><span class=mi>16</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 正常访问栈数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>local_data</span><span class=p>);</span>  <span class=c1>// 可能崩溃
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=4-函数指针表踩踏>4. <strong>函数指针表踩踏</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>FunctionPtr</span> <span class=n>function_table</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A修改函数指针表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>function_table</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>corrupted_function</span><span class=p>;</span>  <span class=c1>// A不崩溃
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// B调用函数指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>function_table</span><span class=p>[</span><span class=mi>2</span><span class=p>]();</span>  <span class=c1>// B执行了错误的函数
</span></span></span></code></pre></td></tr></table></div></div><h4 id=5-多线程内存踩踏>5. <strong>多线程内存踩踏</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 线程A：越界写入共享数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>150</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>shared_data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xDEADBEEF</span><span class=p>;</span>  <span class=c1>// 超出100的范围
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 线程B：正常访问数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>shared_data</span><span class=p>[</span><span class=mi>99</span><span class=p>]</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>value</span> <span class=o>=</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>  <span class=c1>// 可能访问被踩踏的内存
</span></span></span></code></pre></td></tr></table></div></div><h3 id=-实际测试结果>📈 <strong>实际测试结果</strong></h3><p>运行我们的测试程序得到以下结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>=== 测试场景2：堆内存踩踏 ===
</span></span><span class=line><span class=cl>heap_A地址: 0x55d2ef0d86b0
</span></span><span class=line><span class=cl>heap_B地址: 0x55d2ef0d86d0
</span></span><span class=line><span class=cl>距离: 32 字节
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>步骤1：A进行越界写入操作...
</span></span><span class=line><span class=cl>✅ A的越界写入操作完成，A没有崩溃
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>步骤2：B进行正常的内存操作...
</span></span><span class=line><span class=cl>realloc(): invalid old size
</span></span><span class=line><span class=cl>[程序崩溃]
</span></span></code></pre></td></tr></table></div></div><p><strong>✅ 验证成功！</strong> A的越界写入没有崩溃，但B的正常realloc操作崩溃了！</p><hr><h2 id=技术原理>技术原理</h2><h3 id=-为什么a不崩溃>🔬 <strong>为什么A不崩溃？</strong></h3><h4 id=1-内存保护的粒度限制>1. <strong>内存保护的粒度限制</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>操作系统内存保护以页为单位（通常4KB）
</span></span><span class=line><span class=cl>┌─────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│              4KB 页面                    │
</span></span><span class=line><span class=cl>│  heap_A[16]  │  heap_B[16]  │  其他数据   │
</span></span><span class=line><span class=cl>└─────────────────────────────────────────┘
</span></span><span class=line><span class=cl>     ↑              ↑
</span></span><span class=line><span class=cl>   A越界写入32字节，仍在同一页面内
</span></span><span class=line><span class=cl>   操作系统不会触发段错误
</span></span></code></pre></td></tr></table></div></div><h4 id=2-堆管理结构的位置>2. <strong>堆管理结构的位置</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>典型的堆内存布局：
</span></span><span class=line><span class=cl>┌──────────┬──────────┬──────────┬──────────┐
</span></span><span class=line><span class=cl>│ 管理头部  │  heap_A  │ 管理头部  │  heap_B  │
</span></span><span class=line><span class=cl>│ (8字节)  │ (16字节)  │ (8字节)  │ (16字节)  │
</span></span><span class=line><span class=cl>└──────────┴──────────┴──────────┴──────────┘
</span></span><span class=line><span class=cl>                ↑              ↑
</span></span><span class=line><span class=cl>             A越界写入破坏了B的管理头部
</span></span><span class=line><span class=cl>             但A的写入操作本身不会崩溃
</span></span></code></pre></td></tr></table></div></div><h4 id=3-写入操作的特性>3. <strong>写入操作的特性</strong></h4><ul><li>内存写入通常只检查页面权限</li><li>不检查具体的对象边界</li><li>只要地址可写，操作就会成功</li></ul><h3 id=-为什么b会崩溃>💥 <strong>为什么B会崩溃？</strong></h3><h4 id=1-堆管理结构被破坏>1. <strong>堆管理结构被破坏</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 正常的堆块头部信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>heap_chunk</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>size</span><span class=p>;</span>        <span class=c1>// 块大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>size_t</span> <span class=n>prev_size</span><span class=p>;</span>   <span class=c1>// 前一块大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 其他管理信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A的越界写入破坏了这些信息
</span></span></span><span class=line><span class=cl><span class=c1>// 当B调用realloc时，堆管理器读取到错误的信息
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-数据结构一致性检查>2. <strong>数据结构一致性检查</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// realloc内部会进行一致性检查
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>chunk</span><span class=o>-&gt;</span><span class=n>size</span> <span class=o>!=</span> <span class=n>expected_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>abort</span><span class=p>();</span>  <span class=c1>// 检测到数据损坏，主动崩溃
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=3-延迟的内存访问>3. <strong>延迟的内存访问</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// A的破坏是&#34;定时炸弹&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>A_corrupts_memory</span><span class=p>();</span>  <span class=c1>// 埋下炸弹，不爆炸
</span></span></span><span class=line><span class=cl><span class=c1>// ... 其他操作 ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>B_accesses_memory</span><span class=p>();</span>  <span class=c1>// 触发炸弹，崩溃
</span></span></span></code></pre></td></tr></table></div></div><hr><h2 id=实际案例>实际案例</h2><h3 id=-你提到的softbus_>🔍 <strong>你提到的softbus_server崩溃</strong></h3><p>根据你提供的崩溃信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Pid:700, Uid:1024, Process name:softbus_server
</span></span><span class=line><span class=cl>Tid:1193, Name:nStackXDFinder
</span></span><span class=line><span class=cl>#00 pc 0000000000308720 Not mapped
</span></span><span class=line><span class=cl>#01 pc 000000000015272c PostAuthEvent.cfi
</span></span><span class=line><span class=cl>#02 pc 000000000001884c libnstackx_ctrl.z.so
</span></span></code></pre></td></tr></table></div></div><p><strong>分析</strong>：</p><ol><li><strong>线程1193本不应该调用PostAuthEvent</strong></li><li><strong>但崩溃堆栈显示确实调用了</strong></li><li><strong>访问了未映射的内存地址0x308720</strong></li></ol><p><strong>可能的内存踩踏场景</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 场景1：函数指针被踩踏
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>EventHandler</span><span class=p>)(</span><span class=kt>int</span> <span class=n>event</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>EventHandler</span> <span class=n>handler</span> <span class=o>=</span> <span class=n>normal_handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 其他线程的内存操作意外修改了handler
</span></span></span><span class=line><span class=cl><span class=c1>// handler现在指向了PostAuthEvent
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 当nStackXDFinder调用handler时
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>handler</span><span class=p>(</span><span class=n>event</span><span class=p>,</span> <span class=n>data</span><span class=p>);</span>  <span class=c1>// 实际调用了PostAuthEvent
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 场景2：回调函数表被破坏
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>callback_table</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>EventHandler</span> <span class=n>handlers</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 某个越界写入操作修改了回调表
</span></span></span><span class=line><span class=cl><span class=c1>// handlers[5] = PostAuthEvent;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// nStackXDFinder调用回调
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>callbacks</span><span class=p>.</span><span class=n>handlers</span><span class=p>[</span><span class=mi>5</span><span class=p>](</span><span class=n>event</span><span class=p>,</span> <span class=n>data</span><span class=p>);</span>  <span class=c1>// 意外调用PostAuthEvent
</span></span></span></code></pre></td></tr></table></div></div><h3 id=-排查建议>🔧 <strong>排查建议</strong></h3><ol><li><strong>检查nStackXDFinder线程中的函数指针</strong></li><li><strong>查看共享数据结构是否被其他线程踩踏</strong></li><li><strong>使用AddressSanitizer检测内存踩踏</strong></li><li><strong>添加函数指针有效性检查</strong></li></ol><hr><h2 id=检测方法>检测方法</h2><h3 id=-编译时检测>🛠️ <strong>编译时检测</strong></h3><h4 id=1-addresssanitizer>1. <strong>AddressSanitizer</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gcc -fsanitize<span class=o>=</span>address -fno-omit-frame-pointer -o program program.c
</span></span></code></pre></td></tr></table></div></div><p><strong>优点</strong>：</p><ul><li>能检测大部分堆栈越界</li><li>提供详细的错误报告</li><li>性能开销相对较小</li></ul><p><strong>局限性</strong>：</p><ul><li>可能漏检小范围越界</li><li>对全局变量检测不够敏感</li></ul><h4 id=2-valgrind>2. <strong>Valgrind</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>valgrind --tool<span class=o>=</span>memcheck --leak-check<span class=o>=</span>full ./program
</span></span></code></pre></td></tr></table></div></div><h4 id=3-静态分析工具>3. <strong>静态分析工具</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>clang-static-analyzer program.c
</span></span><span class=line><span class=cl>cppcheck --enable<span class=o>=</span>all program.c
</span></span></code></pre></td></tr></table></div></div><h3 id=-运行时检测>🕵️ <strong>运行时检测</strong></h3><h4 id=1-内存模式检测>1. <strong>内存模式检测</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 在关键位置添加魔数检查
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define MAGIC_NUMBER 0xDEADBEEF
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>protected_data</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>magic_start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>actual_data</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>magic_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>check_integrity</span><span class=p>(</span><span class=k>struct</span> <span class=n>protected_data</span><span class=o>*</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>data</span><span class=o>-&gt;</span><span class=n>magic_start</span> <span class=o>!=</span> <span class=n>MAGIC_NUMBER</span> <span class=o>||</span> 
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=o>-&gt;</span><span class=n>magic_end</span> <span class=o>!=</span> <span class=n>MAGIC_NUMBER</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;内存被踩踏！</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>abort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=2-函数指针有效性检查>2. <strong>函数指针有效性检查</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>is_valid_function_pointer</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 检查指针是否在合法的代码段范围内
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>extern</span> <span class=kt>char</span> <span class=n>_text_start</span><span class=p>,</span> <span class=n>_text_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&gt;=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>_text_start</span> <span class=o>&amp;&amp;</span> <span class=n>ptr</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>_text_end</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>safe_call_function</span><span class=p>(</span><span class=n>FunctionPtr</span> <span class=n>func</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>is_valid_function_pointer</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>func</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;无效的函数指针：%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>func</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=3-内存分配跟踪>3. <strong>内存分配跟踪</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 重写malloc/free来添加边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span><span class=o>*</span> <span class=nf>debug_malloc</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>total_size</span> <span class=o>=</span> <span class=n>size</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span><span class=o>*</span> <span class=n>ptr</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>total_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>ptr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>MAGIC_NUMBER</span><span class=p>;</span>  <span class=c1>// 前哨兵
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ptr</span><span class=p>[(</span><span class=n>size</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>))</span> <span class=o>/</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>)]</span> <span class=o>=</span> <span class=n>MAGIC_NUMBER</span><span class=p>;</span>  <span class=c1>// 后哨兵
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ptr</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>// 返回实际数据区域
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=防护措施>防护措施</h2><h3 id=-编程实践>🛡️ <strong>编程实践</strong></h3><h4 id=1-边界检查>1. <strong>边界检查</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 安全的字符串复制
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>safe_strcpy</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>src</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>dest_size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>dest_size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>strncpy</span><span class=p>(</span><span class=n>dest</span><span class=p>,</span> <span class=n>src</span><span class=p>,</span> <span class=n>dest_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>dest</span><span class=p>[</span><span class=n>dest_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 安全的数组访问
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>safe_array_access</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>array</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>index</span><span class=p>,</span> <span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>array</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;数组越界：索引%zu超出范围[0, %zu)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>index</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=2-使用安全的api>2. <strong>使用安全的API</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 推荐使用的安全函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>strcpy</span>  <span class=err>→</span> <span class=n>strncpy</span> <span class=err>或</span> <span class=n>strlcpy</span>
</span></span><span class=line><span class=cl><span class=n>sprintf</span> <span class=err>→</span> <span class=n>snprintf</span>
</span></span><span class=line><span class=cl><span class=n>gets</span>    <span class=err>→</span> <span class=n>fgets</span>
</span></span><span class=line><span class=cl><span class=n>memcpy</span>  <span class=err>→</span> <span class=err>带长度检查的版本</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=3-raii和智能指针c>3. <strong>RAII和智能指针（C++）</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 使用智能指针避免手动内存管理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>[]</span><span class=o>&gt;</span> <span class=n>buffer</span><span class=p>(</span><span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>size</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=n>safe_array</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>  <span class=c1>// 自动边界检查
</span></span></span></code></pre></td></tr></table></div></div><h3 id=-系统级防护>🔒 <strong>系统级防护</strong></h3><h4 id=1-栈保护>1. <strong>栈保护</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 编译时启用栈保护</span>
</span></span><span class=line><span class=cl>gcc -fstack-protector-all -o program program.c
</span></span></code></pre></td></tr></table></div></div><h4 id=2-aslr地址空间布局随机化>2. <strong>ASLR（地址空间布局随机化）</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 检查ASLR状态</span>
</span></span><span class=line><span class=cl>cat /proc/sys/kernel/randomize_va_space
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 启用ASLR</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>2</span> &gt; /proc/sys/kernel/randomize_va_space
</span></span></code></pre></td></tr></table></div></div><h4 id=3-depnx-bit数据执行保护>3. <strong>DEP/NX bit（数据执行保护）</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 编译时启用</span>
</span></span><span class=line><span class=cl>gcc -Wl,-z,noexecstack -o program program.c
</span></span></code></pre></td></tr></table></div></div><h3 id=-测试策略>🧪 <strong>测试策略</strong></h3><h4 id=1-模糊测试fuzzing>1. <strong>模糊测试（Fuzzing）</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 使用AFL进行模糊测试</span>
</span></span><span class=line><span class=cl>afl-gcc -o program program.c
</span></span><span class=line><span class=cl>afl-fuzz -i input_dir -o output_dir ./program
</span></span></code></pre></td></tr></table></div></div><h4 id=2-压力测试>2. <strong>压力测试</strong></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 多线程压力测试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>stress_test</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1000000</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 进行大量内存操作
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 观察是否出现内存踩踏
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=3-代码审查重点>3. <strong>代码审查重点</strong></h4><ul><li><input disabled type=checkbox> 所有数组访问都有边界检查</li><li><input disabled type=checkbox> 指针运算有范围验证</li><li><input disabled type=checkbox> 字符串操作使用安全函数</li><li><input disabled type=checkbox> 动态内存分配后检查返回值</li><li><input disabled type=checkbox> 多线程访问共享数据有同步保护</li></ul><hr><h2 id=完整测试代码>完整测试代码</h2><h3 id=-文件结构>📁 <strong>文件结构</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>test/
</span></span><span class=line><span class=cl>├── memory_corruption_test.c    # 主测试程序
</span></span><span class=line><span class=cl>├── Makefile                   # 编译脚本
</span></span><span class=line><span class=cl>└── 内存踩踏分析报告.md         # 本文档
</span></span></code></pre></td></tr></table></div></div><h3 id=-核心测试代码>💻 <strong>核心测试代码</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;setjmp.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 全局变量用于段错误处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>jmp_buf</span> <span class=n>segfault_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>segfault_occurred</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>segfault_handler</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>segfault_occurred</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>longjmp</span><span class=p>(</span><span class=n>segfault_buf</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 测试场景：堆内存踩踏
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>test_heap_memory_corruption</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;=== 堆内存踩踏测试 ===</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>heap_A</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>heap_B</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;heap_A地址: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>heap_A</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;heap_B地址: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>heap_B</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// A的恶意操作：越界写入
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGSEGV</span><span class=p>,</span> <span class=n>segfault_handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>setjmp</span><span class=p>(</span><span class=n>segfault_buf</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=n>heap_A</span><span class=p>,</span> <span class=sc>&#39;X&#39;</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>  <span class=c1>// 写入32字节，超出16字节分配
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;✅ A的越界写入完成，A没有崩溃</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;❌ A越界写入时崩溃</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// B的正常操作：重新分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>setjmp</span><span class=p>(</span><span class=n>segfault_buf</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>heap_B</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=nf>realloc</span><span class=p>(</span><span class=n>heap_B</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;✅ B的内存操作成功</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;💥 B在进行正常内存操作时崩溃！</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 清理
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>setjmp</span><span class=p>(</span><span class=n>segfault_buf</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>heap_A</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>heap_B</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;内存清理成功</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;💥 清理内存时崩溃！</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;内存踩踏测试 - A操作B内存但A不崩溃，B访问时崩溃</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;================================================</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>test_heap_memory_corruption</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 其他测试场景...
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=-编译和运行>🚀 <strong>编译和运行</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 编译</span>
</span></span><span class=line><span class=cl>make run-corruption
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 或者手动编译</span>
</span></span><span class=line><span class=cl>gcc -Wall -Wextra -g -O0 -pthread -o memory_corruption_test memory_corruption_test.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 运行</span>
</span></span><span class=line><span class=cl>./memory_corruption_test
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用AddressSanitizer检测</span>
</span></span><span class=line><span class=cl>gcc -fsanitize<span class=o>=</span>address -pthread -o memory_corruption_test_asan memory_corruption_test.c
</span></span><span class=line><span class=cl>./memory_corruption_test_asan
</span></span></code></pre></td></tr></table></div></div><h3 id=-预期输出>📊 <strong>预期输出</strong></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>内存踩踏测试 - A操作B内存但A不崩溃，B访问时崩溃
</span></span><span class=line><span class=cl>================================================
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>=== 测试场景1：相邻全局数组内存踩踏 ===
</span></span><span class=line><span class=cl>[结果根据内存布局而定]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>=== 测试场景2：堆内存踩踏 ===
</span></span><span class=line><span class=cl>heap_A地址: 0x55f8a1b0a6b0
</span></span><span class=line><span class=cl>heap_B地址: 0x55f8a1b0a6d0
</span></span><span class=line><span class=cl>距离: 32 字节
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>步骤1：A进行越界写入操作...
</span></span><span class=line><span class=cl>✅ A的越界写入操作完成，A没有崩溃
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>步骤2：B进行正常的内存操作...
</span></span><span class=line><span class=cl>realloc(): invalid old size
</span></span><span class=line><span class=cl>[程序异常终止 - 证明了我们的假设]
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-结论>📝 结论</h2><h3 id=-核心发现>🎯 <strong>核心发现</strong></h3><p><strong>✅ 确实存在A操作B内存但A不崩溃，B访问时崩溃的情况！</strong></p><h3 id=-技术总结>🔬 <strong>技术总结</strong></h3><ol><li><strong>现象普遍性</strong>：这种内存踩踏现象在实际开发中很常见</li><li><strong>根本原因</strong>：操作系统内存保护的粒度和内存管理的复杂性</li><li><strong>危险性</strong>：增加了调试难度，容易误导问题定位</li><li><strong>可检测性</strong>：需要专门的工具和方法才能有效检测</li></ol><h3 id=-对你的softbus_>⚠️ <strong>对你的softbus_server问题的启示</strong></h3><ol><li><strong>nStackXDFinder线程很可能是受害者，而不是肇事者</strong></li><li><strong>真正的问题可能在其他线程的内存操作</strong></li><li><strong>函数指针或回调表可能被其他代码踩踏</strong></li><li><strong>需要全面检查共享数据结构的完整性</strong></li></ol><h3 id=-防护建议>💡 <strong>防护建议</strong></h3><ol><li><strong>启用编译器安全选项</strong></li><li><strong>使用内存检测工具</strong></li><li><strong>实施防御性编程</strong></li><li><strong>加强代码审查</strong></li><li><strong>建立内存安全测试流程</strong></li></ol><p>这种内存踩踏现象是C/C++程序中最隐蔽和危险的bug类型之一，需要开发者保持高度警惕并采取多层防护措施。</p><hr><p><em>报告生成时间：2025年9月12日</em><br><em>测试环境：Linux x86_64, GCC编译器</em></p></section><footer class=article-footer><section class=article-tags><a href=/tags/%E5%86%85%E5%AD%98/>内存</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/%E5%85%A8%E5%B1%80%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/><div class=article-details><h2 class=article-title>全局数组越界访问行为分析</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2025 二进制</section><section class=powerby></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>