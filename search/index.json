[{"content":"FILLP协议 目录 概述与背景 FILLP协议架构设计 代码文件结构说明 连接建立流程 数据传输流程 流量控制机制 RTT测量机制 重传和可靠性保证 系统调用和性能优化 关键数据结构 FILLP传输协议流程总结 总结和展望 1. 概述与背景 1.1 FILLP协议介绍 FILLP（Fast Internet Low Latency Protocol）是华为开发的一种基于UDP的可靠传输协议，专门为高带宽、长距离网络环境设计。在DSoftBus通信框架中，FILLP作为核心传输协议，提供了高性能的数据传输能力。\n1.2 核心特性 基于UDP的可靠传输：在UDP基础上实现可靠性保障 流控算法：支持多种流控算法(ALG0-ALG3) 快速重传：基于NACK的快速重传机制 高并发支持：支持多连接并发处理 安全机制：基于HMAC-SHA256的Cookie验证 跨平台：支持Linux、Windows等多平台 1.3 适用场景 高带宽长距离传输：卫星通信、跨洋数据传输 实时音视频传输：支持帧级别的数据标识和优先级 文件传输系统：大文件高效可靠传输 分布式存储：数据复制和同步 2. FILLP协议架构设计 2.1 分层架构图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ┌─────────────────────────────────────────────────────────────────────────────┐ │ 应用程序 (Application) │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ FtSocket(), FtSend(), FtRecv() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 应用层API (app_lib) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ api.c │ │ socket_app.c │ │ epoll_app.c │ │ │ │ (外部接口) │ │ (Socket实现) │ │ (事件管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SockSend(), SockRecv(), SockConnect() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ FILLP协议核心层 (fillp_lib) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ fillp_conn.c │ │ fillp_input.c │ │ fillp_output.c │ │ │ │ (连接管理) │ │ (数据接收) │ │ (数据发送) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │fillp_flow_ctrl.c│ │ fillp_pcb.c │ │ fillp_frame.c │ │ │ │ (流量控制) │ │ (PCB管理) │ │ (帧处理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SpungePcb管理, NetConn管理 ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 网络抽象层 (Network Layer) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ net.c │ │ pcb.c │ │ spunge_core.c │ │ │ │ (网络连接) │ │ (PCB管理) │ │ (核心管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ SysIoSend(), SysIoRecv() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 系统IO抽象层 (SysIO Layer) │ │ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ │ │ sysio.c │ │ sysio_udp.c │ │ spunge_stack.c │ │ │ │ (IO抽象接口) │ │ (UDP封装) │ │ (协议栈管理) │ │ │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ └─────────────────────────────────┬───────────────────────────────────────────┘ │ sendto(), recvfrom() ┌─────────────────────────────────┴───────────────────────────────────────────┐ │ 操作系统 (Operating System) │ │ UDP Socket 系统调用 │ └─────────────────────────────────────────────────────────────────────────────┘ 2.2 核心组件关系图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ┌──────────────────────────────────────────────────────────────────────────────┐ │ FILLP 核心组件关系 │ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ FtSocket │───→│ FtNetconn │───→│ SpungePcb │ │ │ │ (Socket) │ │ (网络连接) │ │ (PCB) │ │ │ └─────────────┘ └─────────────┘ └─────┬───────┘ │ │ │ │ │ │ │ ┌─────────────┐ │ │ │ └───────────→│ EventPoll │ │ │ │ │ (事件轮询) │ │ │ │ └─────────────┘ │ │ │ │ │ │ ┌─────────────┐ │ │ │ │ FillpPcb │←────────┘ │ │ │ (协议PCB) │ │ │ └─────┬───────┘ │ │ │ │ │ ┌──────────────────┼──────────────────┐ │ │ │ │ │ │ │ ┌─────▼─────┐ ┌───────▼─────┐ ┌──────▼──────┐ │ │ │FillpSendPcb│ │FillpRecvPcb │ │FlowControl │ │ │ │ (发送PCB) │ │ (接收PCB) │ │ (流量控制) │ │ │ └───────────┘ └────────────┘ └─────────────┘ │ └──────────────────────────────────────────────────────────────────────────────┘ 2.3 线程模型图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ┌─────────────────────────────────────────────────────────────────────────────┐ │ FILLP 线程模型 │ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ 应用线程 │ │ 协议栈线程 │ │ 定时器线程 │ │ │ │ (App Thread)│ │(Stack Thread)│ │(Timer Thread)│ │ │ │ │ │ │ │ │ │ │ │ FtSend() │──────────│ SendCycle │ │ PackTimer │ │ │ │ FtRecv() │ │ RecvCycle │ │ FcTimer │ │ │ │ FtConnect() │ │ PackCycle │ │KeepAlive │ │ │ │ │ │ │ │ ConnRetry │ │ │ └─────────────┘ └─────┬───────┘ └─────────────┘ │ │ │ │ │ │ │ │ │ │ │ │ ┌────▼────┐ ┌─────▼─────┐ ┌────▼────┐ │ │ │消息队列 │ │ UDP接收 │ │时间轮 │ │ │ │ (MSG) │ │(UDP Recv) │ │(Timing │ │ │ └─────────┘ │ select() │ │ Wheel) │ │ │ │recvfrom() │ └─────────┘ │ │ │sendto() │ │ │ └───────────┘ │ └─────────────────────────────────────────────────────────────────────────────┘ 3. 代码文件结构说明 3.1 主要头文件 (include/) 3.1.1 核心接口文件 fillpinc.h: 主要的API接口定义，包含所有外部调用的函数声明 fillptypes.h: 核心数据类型和结构体定义 fillpcallbacks.h: 系统回调函数类型定义，用于平台抽象 3.2 应用层 (app_lib/) 3.2.1 头文件 (include/) socket_app.h: Socket应用层接口定义 socket_opt.h: Socket选项设置接口 epoll_app.h: Epoll事件管理接口 spunge_app.h: Spunge应用层管理接口 fillp_stack_app_config_in.h: 应用层配置管理 fillp_dfx.h: 诊断和调试功能接口 3.2.2 源码文件 (src/) api.c: 外部API接口实现，包含FtSocket、FtSend、FtRecv等 socket_app.c: Socket应用层实现，处理用户接口调用 socket_opt.c: Socket选项设置实现 epoll_app.c: Epoll事件轮询实现 spunge_app.c: Spunge应用管理实现 fillp_stack_app_config.c: 应用层配置管理实现 fillp_dfx.c: 诊断功能实现 3.3 协议核心层 (fillp_lib/) 3.3.1 核心协议头文件 (include/) 主要协议文件\nfillp/fillp.h: FILLP协议核心定义，包含数据包格式、状态定义 fillp/fillp_pcb.h: 协议控制块(PCB)定义 fillp/fillp_flow_control.h: 流量控制算法接口 fillp/fillp_algorithm.h: 流控算法函数定义 fillp/fillp_frame.h: 帧处理相关定义 网络和系统接口\nnet.h: 网络连接管理接口 pcb.h: PCB管理接口 sysio.h: 系统IO抽象层接口 res.h: 资源管理接口 工具和安全\nhmac.h: HMAC-SHA256安全认证 sha256.h: SHA256哈希算法 fillp_cookie.h: Cookie安全机制 fillp_buf_item.h: 缓冲区项管理 3.3.2 核心协议源码 (src/) 主要协议实现\nfillp/fillp.c: 协议算法函数注册 fillp/fillp_common.c: 协议通用功能实现 fillp/fillp_conn.c: 连接建立和管理实现 fillp/fillp_input.c: 数据包接收和处理 fillp/fillp_output.c: 数据包发送处理 fillp/fillp_pcb.c: 协议控制块管理 fillp/fillp_flow_control.c: 流量控制实现 fillp/fillp_flow_control_alg0.c: 流控算法0实现 fillp/fillp_frame.c: 帧处理实现 fillp/fillp_timer.c: 定时器管理 网络和系统层\nnet.c: 网络连接实现 pcb.c: PCB管理实现 sysio.c: 系统IO抽象实现 sysio_udp.c: UDP系统调用封装 spunge_core.c: Spunge核心管理 spunge_stack.c: Spunge协议栈实现 3.4 架构层次关系 1 2 3 4 5 6 7 8 9 应用API层 (api.c, socket_app.c) ↓ 协议核心层 (fillp_conn.c, fillp_input.c, fillp_output.c) ↓ 网络抽象层 (net.c, pcb.c) ↓ 系统IO层 (sysio.c, sysio_udp.c) ↓ 操作系统层 (socket系统调用) 4. 连接建立流程 4.1 连接建立状态机 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ┌─────────┐ │ IDLE │ │ (空闲) │ └────┬────┘ │ FtConnect() ▼ ┌──────────────┐ CONN_REQ ┌──────────────┐ CONN_CONFIRM │ CONNECTING │────────────→│ REQ_ACK_RCVD │─────────────┐ │ (连接中) │ │ (收到请求应答)│ │ └──────┬───────┘ └──────────────┘ │ │ │ │ Timeout/Error │ ▼ ▼ ┌──────────┐ ┌──────────────┐ │ CLOSED │ │ CONFIRM_SENT │ │ (关闭) │ │ (确认已发送) │ └──────────┘ └──────┬───────┘ ▲ │ │ │CONFIRM_ACK │ ▼ │ ┌──────────────┐ │ │ CONNECTED │ │ │ (已连接) │ │ └──────┬───────┘ │ │ │ FtClose() │ FtClose() │ ▼ │ ┌──────────────┐ │ │ CLOSING │ │ │ (关闭中) │ └──────────────────────────────────────┤ │ └──────────────┘ 4.2 客户端连接建立完整调用链 1 2 3 4 5 6 7 8 9 应用层调用: FtConnect(fd, addr, addrlen) // api.c:91 └→ SockConnect(sockIndex, name, nameLen) // socket_app.c:1318 └→ SpungeConnectMsg 消息处理 // 消息机制 └→ SpungeSendConnectMsg(conn) // spunge_stack.c └→ FillpSendConnReq(pcb) // fillp_conn.c:1375 └→ pcb-\u0026gt;sendFunc(conn, \u0026amp;req, ...) // 函数指针调用 └→ SysioSendUdp(...) // sysio_udp.c └→ sendto(udpSock, buf, len, flags, addr, addrlen) // 系统调用 4.3 四次握手详细过程 4.3.1 第一次握手：CONN_REQ 1 2 3 4 5 // fillp_conn.c:1375 FillpSendConnReq() struct FillpPktConnReq req; FillpSendConnReqBuild(pcb, \u0026amp;req, curTime); ret = pcb-\u0026gt;sendFunc(conn, (char *)\u0026amp;req, sizeof(struct FillpPktConnReq), conn-\u0026gt;pcb); // 最终调用 sendto() 系统调用 4.3.2 第二次握手：CONN_REQ_ACK 1 2 3 4 5 // 服务端接收CONN_REQ后 // fillp_conn.c:91 FillpConnReqInput() FillpGenerateCookie(pcb, req, \u0026amp;p-\u0026gt;addr, serverPort, \u0026amp;stateCookie); FillpSendConnReqAck(pcb, \u0026amp;stateCookie, timestamp); // 最终通过 sendto() 发送CONN_REQ_ACK 4.3.3 第三次握手：CONN_CONFIRM 1 2 3 4 // 客户端接收CONN_REQ_ACK后 // fillp_conn.c:427 FillpConnReqAckInput() FillpSendConnConfirm(pcb, \u0026amp;reqAck); // 最终通过 sendto() 发送CONN_CONFIRM 4.3.4 第四次握手：CONN_CONFIRM_ACK 1 2 3 4 // 服务端接收CONN_CONFIRM后 // fillp_conn.c:748 FillpConnConfirmInput() FillpSendConnConfirmAck(pcb); // 最终通过 sendto() 发送CONN_CONFIRM_ACK 4.4 Cookie安全机制 1 2 3 4 5 6 7 8 9 10 11 12 13 // Cookie生成和验证 static FILLP_INT FillpGenerateCookie(struct FillpPcb *pcb, FillpCookieContent *cookie) { // 基于时间戳、地址等信息生成Cookie // 使用HMAC-SHA256算法确保安全性 return FillpHmacSha256Generate(/* parameters */); } static FILLP_INT FillpValidateCookie(struct FillpPcb *pcb, const FillpCookieContent *cookie) { // 验证Cookie有效性 return FillpHmacSha256Verify(/* parameters */); } 5. 数据传输流程 5.1 发送数据流程 5.1.1 发送数据完整调用链 1 2 3 4 5 6 7 8 9 10 11 12 应用层调用: FtSend(fd, data, size, flag) // api.c:137 └→ SockSend(sockIndex, data, size, flags) // socket_app.c:155 └→ SockSendmsg(sockIndex, \u0026amp;msg, flags) // socket_app.c:516 └→ SockSendmsgDataToBufCache(sock, msg, flags, bufLen) // socket_app.c:459 └→ SockSendReqFpcbItem() 获取缓冲区 // socket_app.c:377 └→ FillpPcbSend(fpcb, itemList, itemCnt) // fillp_pcb.c └→ FillpSendOne(pcb, totalSendBytes, sendPktNum) // fillp_output.c └→ FillpSendItem(item, fpcb) // fillp_output.c └→ pcb-\u0026gt;sendFunc() // 函数指针 └→ SysioSendUdp() // sysio_udp.c └→ sendto() // 系统调用 5.1.2 发送数据流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 应用程序 │ FtSend(fd, data, len, flag) ▼ Socket API层 (api.c) │ 参数验证、socket状态检查 ▼ Socket应用层 (socket_app.c) │ SockSendData() - 非阻塞检查、缓冲区管理 ▼ FILLP协议层 (fillp_common.c) │ FillpSendData() - 数据分片、序列号分配 ▼ 缓冲区管理 (fillp_buf_item.c) │ FillpCreateSendItem() - 创建数据项、设置序列号 ▼ 发送队列 (fillp_output.c) │ 添加到unSendList → 流控检查 → 获取发送项 ▼ 协议封装 (fillp_output.c) │ FillpBuildDataPacket() - 添加FILLP头部 ▼ 系统I/O层 (sysio_udp.c) │ SysioSendUdp() - UDP socket发送 ▼ 系统调用 (callbacks.c) │ FILLP_SENDTO() → sendto() ▼ 内核网络栈 │ UDP协议处理 → IP路由 → 网络设备发送 ▼ 网络传输 5.2 接收数据流程 5.2.1 接收数据完整调用链 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 系统层数据到达: select() 检测到UDP socket可读 // sysio.c:78 └→ SpungeDoRecvCycle(osSock, inst) // spunge_stack.c:25 └→ SysioFetchPacketUdp(osSock, buf, \u0026amp;count) // sysio_udp.c:480 └→ recvfrom(udpSock, buf, len, 0, ...) // 系统调用 └→ SpungePushRecvdDataToStack(...) // spunge_core.c └→ FillpDoInput(pcb, buf, inst) // fillp_input.c:873 └→ FillpDataInput(pcb, item) // fillp_input.c:188 └→ FillpDataToStack(pcb, item) // fillp_common.c:625 └→ 数据推送到接收队列 应用层读取: FtRecv(fd, mem, len, flag) // api.c:124 └→ SockRecv(s, mem, len, flags) // socket_app.c:558 └→ SockRecvmsg(sockIndex, \u0026amp;msg, flags) // socket_app.c:728 └→ SockRecvmsgDataFromBufCache(sock, msg, flags, bufLen) // socket_app.c:669 └→ 从接收队列读取数据到用户缓冲区 5.2.2 接收数据流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 网络传输 ▼ 内核网络栈 │ 网络设备接收 → IP处理 → UDP协议处理 ▼ 系统调用 (callbacks.c) │ recvfrom() → FILLP_RECVFROM() ▼ 系统I/O层 (sysio_udp.c) │ SysioFetchPacketUdp() - 接收UDP数据 ▼ 数据分发 (spunge_core.c) │ SpungePushRecvdDataToStack() - 根据地址查找PCB ▼ 协议解析 (fillp_input.c) │ FillpDoInput() - 解析FILLP头部、字节序转换 ▼ 消息分类处理 (fillp_input.c) │ 根据消息类型分发：DATA/PACK/NACK/CONN_* ▼ 数据处理 (fillp_input.c) │ FillpDataInput() - 序列号检查、乱序处理 ▼ 接收缓冲区 (fillp_common.c) │ FillpDataToStack() - 添加到recvList、有序性保证 ▼ 应用层通知 (spunge.c) │ SpungeEpollEventCallback() - 触发EPOLLIN事件 ▼ Socket API层 (api.c) │ FtRecv() - 从接收缓冲区读取数据 ▼ 应用程序 5.3 数据包格式 5.3.1 FILLP协议头结构 1 2 3 4 5 6 7 8 9 struct FillpPktHead { FILLP_UINT8 flag; // 标志位 FILLP_UINT8 type; // 消息类型 FILLP_UINT16 dataLen; // 数据长度 FILLP_UINT32 seqNum; // 序列号 FILLP_UINT32 pktNum; // 包号 }; #define FILLP_HLEN sizeof(struct FillpPktHead) 5.3.2 不同消息类型的包结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 数据包 struct FillpPktData { char head[FILLP_HLEN]; char data[0]; // 可变长度数据 }; // 连接请求包 struct FillpPktConnReq { char head[FILLP_HLEN]; FILLP_UINT32 cookiePreserveTime; FILLP_UINT32 sendCache; FILLP_UINT32 recvCache; FILLP_ULLONG timestamp; }; // NACK包 struct FillpPktNack { char head[FILLP_HLEN]; FILLP_UINT32 lastPktNum; }; // PACK包(确认包) struct FillpPktPack { char head[FILLP_HLEN]; FILLP_UINT16 flag; FILLP_UINT16 pktLoss; FILLP_UINT32 lostSeq; FILLP_UINT32 rate; FILLP_UINT32 oppositeSetRate; }; 5.4 FILLP双编号处理流程 5.4.1 双编号机制概述 FILLP协议采用了创新的双编号机制，同时使用序列号（seqNum）和包号（pktNum）来管理数据传输：\n序列号（seqNum）：按字节递增，用于数据完整性和顺序保证 包号（pktNum）：按数据包递增，用于丢包检测和重传控制 1 2 3 4 5 6 7 struct FillpPktHead { FILLP_UINT8 flag; // 标志位 FILLP_UINT8 type; // 消息类型 FILLP_UINT16 dataLen; // 数据长度 FILLP_UINT32 seqNum; // 序列号（字节级） FILLP_UINT32 pktNum; // 包号（包级） }; 5.4.2 发送端双编号处理流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 应用数据输入 ↓ 数据分片处理 ↓ ┌─────────────────────────────────────────────────────┐ │ 双编号分配流程 │ │ │ │ ┌─────────────┐ ┌─────────────┐ │ │ │包号分配 │ │序列号分配 │ │ │ │pktNum++ │ │seqNum += │ │ │ │(按包递增) │ │dataLen │ │ │ │ │ │(按字节递增) │ │ │ └─────────────┘ └─────────────┘ │ │ │ │ │ │ └──────┬──────────┘ │ │ ▼ │ │ ┌─────────────┐ │ │ │设置包头信息 │ │ │ │head-\u0026gt;pktNum │ │ │ │head-\u0026gt;seqNum │ │ │ └─────────────┘ │ └─────────────────────────────────────────────────────┘ ↓ 协议头封装 ↓ 添加到发送队列 ↓ UDP发送 发送端关键代码逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // fillp_output.c 发送数据项时的双编号处理 static void FillpSetItemNumbers(struct FillpPcb *pcb, struct FillpPcbItem *item) { // 1. 分配包号（按包递增） item-\u0026gt;pktNum = pcb-\u0026gt;send.pktNum++; // 2. 分配序列号（按数据长度递增） item-\u0026gt;seqNum = pcb-\u0026gt;send.seqNum; pcb-\u0026gt;send.seqNum += item-\u0026gt;dataLen; // 3. 设置协议头 struct FillpPktHead *head = (struct FillpPktHead *)item-\u0026gt;buf.p; head-\u0026gt;pktNum = FILLP_HTONL(item-\u0026gt;pktNum); head-\u0026gt;seqNum = FILLP_HTONL(item-\u0026gt;seqNum); head-\u0026gt;dataLen = FILLP_HTONS(item-\u0026gt;dataLen); } 5.4.3 接收端双编号处理流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 UDP数据包到达 ↓ 协议头解析 ↓ ┌─────────────────────────────────────────────────────┐ │ 双编号验证流程 │ │ │ │ ┌─────────────┐ ┌─────────────┐ │ │ │包号检查 │ │序列号检查 │ │ │ │pktNum vs │ │seqNum vs │ │ │ │expectedPkt │ │expectedSeq │ │ │ └─────┬───────┘ └─────┬───────┘ │ │ │ │ │ │ ▼ ▼ │ │ ┌─────────────┐ ┌─────────────┐ │ │ │丢包检测 │ │数据完整性 │ │ │ │Gap检测 │ │检查 │ │ │ │NACK生成 │ │乱序处理 │ │ │ └─────────────┘ └─────────────┘ │ │ │ │ │ │ └──────┬──────────┘ │ │ ▼ │ │ ┌─────────────┐ │ │ │数据处理决策 │ │ │ │- 按序接收 │ │ │ │- 乱序缓存 │ │ │ │- 重复丢弃 │ │ │ └─────────────┘ │ └─────────────────────────────────────────────────────┘ ↓ 数据队列管理 ↓ 应用层交付 接收端关键代码逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // fillp_input.c 接收数据时的双编号处理 static void FillpProcessReceivedPacket(struct FillpPcb *pcb, struct FillpPcbItem *item) { struct FillpPktHead *head = (struct FillpPktHead *)item-\u0026gt;buf.p; // 1. 解析双编号（网络字节序转换） FILLP_UINT32 pktNum = FILLP_NTOHL(head-\u0026gt;pktNum); FILLP_UINT32 seqNum = FILLP_NTOHL(head-\u0026gt;seqNum); FILLP_UINT16 dataLen = FILLP_NTOHS(head-\u0026gt;dataLen); // 2. 包号检查（丢包检测） if (pktNum \u0026gt; pcb-\u0026gt;recv.expectedPktNum) { // 检测到丢包，发送NACK FillpSendNack(pcb, pcb-\u0026gt;recv.expectedPktNum, pktNum); pcb-\u0026gt;statistics.traffic.totalRecvLost += (pktNum - pcb-\u0026gt;recv.expectedPktNum); } // 3. 序列号检查（数据完整性） if (seqNum \u0026lt; pcb-\u0026gt;recv.expectedSeqNum) { // 重复或过期数据包，丢弃 FillpDropDuplicatePacket(pcb, item); return; } // 4. 数据处理决策 if (pktNum == pcb-\u0026gt;recv.expectedPktNum \u0026amp;\u0026amp; seqNum == pcb-\u0026gt;recv.expectedSeqNum) { // 按序数据包，直接处理 FillpProcessInOrderPacket(pcb, item); pcb-\u0026gt;recv.expectedPktNum++; pcb-\u0026gt;recv.expectedSeqNum += dataLen; } else { // 乱序数据包，加入缓存队列 FillpCacheOutOfOrderPacket(pcb, item); } } 5.4.4 双编号协同工作机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ┌─────────────────────────────────────────────────────────────────────┐ │ 双编号协同工作流程图 │ │ │ │ 发送端状态 网络传输 接收端状态 │ │ │ │ ┌─────────────┐ ┌─────────────┐ │ │ │send.pktNum │────────────┐ ┌───────────│recv.pktNum │ │ │ │send.seqNum │ │ │ │recv.seqNum │ │ │ └─────────────┘ │ │ └─────────────┘ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ │ │ ┌─────────────┐ ┌──────────┐ ┌──────────┐ ┌─────────────┐ │ │ │数据包1 │─────▶│ Network │─│ Network │──▶│检查包号 │ │ │ │pkt=1,seq=0 │ │Transport │ │Transport │ │期望pkt=1 │ │ │ └─────────────┘ └──────────┘ └──────────┘ │期望seq=0 │ │ │ └─────────────┘ │ │ ┌─────────────┐ ┌──────────┐ ┌──────────┐ ┌─────────────┐ │ │ │数据包2 │─────▶│ Network │─│ 丢失 │──X│Gap检测 │ │ │ │pkt=2,seq=100│ │Transport │ │ │ │pkt=3\u0026gt;2+1 │ │ │ └─────────────┘ └──────────┘ └──────────┘ │发送NACK │ │ │ └─────────────┘ │ │ ┌─────────────┐ ┌──────────┐ ┌──────────┐ ┌─────────────┐ │ │ │数据包3 │─────▶│ Network │─│ Network │──▶│乱序缓存 │ │ │ │pkt=3,seq=200│ │Transport │ │Transport │ │等待pkt=2 │ │ │ └─────────────┘ └──────────┘ └──────────┘ └─────────────┘ │ │ │ └─────────────────────────────────────────────────────────────────────┘ 5.4.5 双编号在重传中的应用 NACK重传基于包号：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 基于包号的NACK重传 struct FillpPktNack { char head[FILLP_HLEN]; FILLP_UINT32 startPktNum; // 丢失包起始包号 FILLP_UINT32 endPktNum; // 丢失包结束包号 }; // 发送端接收NACK后的处理 void FillpHandleNack(struct FillpPcb *pcb, struct FillpPktNack *nack) { FILLP_UINT32 lostStart = FILLP_NTOHL(nack-\u0026gt;startPktNum); FILLP_UINT32 lostEnd = FILLP_NTOHL(nack-\u0026gt;endPktNum); // 根据包号范围查找需要重传的数据包 for (FILLP_UINT32 pktNum = lostStart; pktNum \u0026lt; lostEnd; pktNum++) { struct FillpPcbItem *item = FillpFindItemByPktNum(pcb, pktNum); if (item != FILLP_NULL_PTR) { FillpRetransmitItem(pcb, item); // 重传数据包 } } } PACK确认基于序列号：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 基于序列号的PACK确认 struct FillpPktPack { char head[FILLP_HLEN]; FILLP_UINT16 flag; FILLP_UINT16 pktLoss; FILLP_UINT32 ackSeqNum; // 确认的序列号 FILLP_UINT32 rate; FILLP_UINT32 oppositeSetRate; }; // 发送端接收PACK确认的处理 void FillpHandlePack(struct FillpPcb *pcb, struct FillpPktPack *pack) { FILLP_UINT32 ackSeq = FILLP_NTOHL(pack-\u0026gt;ackSeqNum); // 根据确认的序列号清理已确认的数据包 FillpCleanAckedItems(pcb, ackSeq); // 更新发送窗口 pcb-\u0026gt;send.unAckedSeqNum = ackSeq; } 5.4.6 双编号的优势 精确的丢包检测：包号提供准确的丢包位置信息 高效的数据完整性保证：序列号确保数据按字节顺序 灵活的重传控制：支持基于包号的选择性重传 优化的确认机制：序列号确认减少确认包数量 乱序处理能力：双编号支持复杂的乱序数据管理 5.4.7 双编号状态管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 发送端状态 struct FillpSendPcb { FILLP_UINT32 pktNum; // 下一个要分配的包号 FILLP_UINT32 seqNum; // 下一个要分配的序列号 FILLP_UINT32 unAckedPktNum; // 最小未确认包号 FILLP_UINT32 unAckedSeqNum; // 最小未确认序列号 // ... }; // 接收端状态 struct FillpRecvPcb { FILLP_UINT32 expectedPktNum; // 期望接收的包号 FILLP_UINT32 expectedSeqNum; // 期望接收的序列号 FILLP_UINT32 maxRecvPktNum; // 已接收的最大包号 FILLP_UINT32 maxRecvSeqNum; // 已接收的最大序列号 // ... }; 6. 流量控制机制 6.1 流控算法接口 1 2 3 4 5 6 7 8 9 10 // 流控算法结构 struct FillpFlowControlAlg { void (*input)(struct FillpPcb *pcb, struct FillpPktHead *head); void (*output)(struct FillpPcb *pcb); FILLP_UINT32 (*getSendRate)(struct FillpPcb *pcb); // ... 其他算法接口 }; // 算法选择 extern struct FillpFlowControlAlg g_fillpFlowControlAlg[FILLP_ALG_MAX]; 6.2 流量控制流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 数据发送触发 ▼ 检查流控状态 │ ├─ 发送窗口已满？ ──Yes──▶ 等待PACK确认 │ │ No ▼ ▼ 更新发送窗口 计算发送速率 │ │ │ ▼ ◀────┘ 获取发送数据项 │ ▼ 计算包间隔时间 │ ▼ 发送数据包 │ ▼ 启动重传定时器 │ ▼ 更新流控统计信息 │ ▼ 接收端PACK反馈 │ ▼ 流控算法调整发送速率 6.3 发送速率控制 1 2 3 4 5 6 7 8 // 计算发送间隔 static FILLP_UINT32 FillpCalculatePackInterval(struct FillpPcb *pcb) { FILLP_UINT32 rate = pcb-\u0026gt;fcAlg-\u0026gt;getSendRate(pcb); // 获取发送速率 FILLP_UINT32 pktSize = pcb-\u0026gt;pktSize; // 包大小 // 计算包间隔: interval = (pktSize * 8 * 1000000) / rate (us) return (pktSize * 8 * 1000000) / rate; } 6.4 PACK包处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // fillp_common.c:764 构建和发送PACK包 void FillpBuildAndSendPack(struct FillpPcb *pcb, struct FtSocket *ftSock, struct FillpPktPack *pack, FILLP_UINT16 dataLen) { // 1. 设置PACK包头 struct FillpPktHead *pktHead = (struct FillpPktHead *)pack-\u0026gt;head; pktHead-\u0026gt;flag = FILLP_HTONS(FILLP_PKT_TYPE_PACK \u0026lt;\u0026lt; FILLP_PKT_TYPE_OFFSET); // 2. 设置确认信息 pack-\u0026gt;lostSeq = FILLP_HTONL(pcb-\u0026gt;recv.seqNum); pack-\u0026gt;rate = FILLP_HTONL(pcb-\u0026gt;send.flowControl.sendRate); // 3. 发送PACK包（最终调用sendto） ret = pcb-\u0026gt;sendFunc(FILLP_GET_CONN(pcb), (char *)pack, sizeof(struct FillpPktPack), pcb-\u0026gt;spcb); } 7. RTT测量机制 7.1 RTT测量概述 FILLP协议采用多种方式测量RTT（往返时延），主要包括：\n连接建立期间的RTT测量 - 基于四次握手过程 数据传输期间的RTT测量 - 基于PACK包交互 ADHOC RTT测量 - 主动RTT探测机制 7.2 连接建立期间RTT测量 7.2.1 四次握手RTT测量流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // fillp_conn.c:1346 客户端发送CONN_REQ时记录时间戳 req-\u0026gt;timestamp = FILLP_HTONLL((FILLP_ULLONG)curTime); // fillp_conn.c:1432 服务端在CONN_REQ_ACK中回传时间戳 void FillpSendConnReqAck(struct FillpPcb *pcb, FILLP_CONST FillpCookieContent *stateCookie, FILLP_ULLONG timestamp) { reqAck-\u0026gt;timestamp = FILLP_HTONLL(timestamp); // 将客户端的时间戳原样返回 } // fillp_conn.c:457 客户端收到CONN_REQ_ACK后计算RTT FILLP_LLONG curTime = SYS_ARCH_GET_CUR_TIME_LONGLONG(); FILLP_LLONG rttTime = curTime - (FILLP_LLONG)reqAck.timestamp; if (rttTime \u0026gt; 0) { pcb-\u0026gt;rtt = (FILLP_ULLONG)rttTime; // 保存RTT值 FILLP_GET_CONN(pcb)-\u0026gt;calcRttDuringConnect = pcb-\u0026gt;rtt; } 7.2.2 RTT计算公式 1 2 RTT = 当前时间 - 发送CONN_REQ的时间戳 = T_recv_ack - T_send_req 7.3 PACK包RTT测量机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // fillp_output.c:474-477 发送PACK包时携带RTT信息 if ((!pcb-\u0026gt;statistics.pack.peerRtt) \u0026amp;\u0026amp; pcb-\u0026gt;rtt) { pack-\u0026gt;flag |= FILLP_PACK_FLAG_WITH_RTT; pack-\u0026gt;reserved.rtt = (FILLP_UINT32)pcb-\u0026gt;rtt; // 将本端RTT告知对端 } // fillp_output.c:480-482 请求对端发送RTT信息 if (!pcb-\u0026gt;rtt) { pack-\u0026gt;flag |= FILLP_PACK_FLAG_REQURE_RTT; // 请求对端提供RTT } // fillp_input.c:666-672 处理收到的RTT信息 if ((pack-\u0026gt;flag \u0026amp; FILLP_PACK_FLAG_WITH_RTT) \u0026amp;\u0026amp; (!pcb-\u0026gt;rtt)) { pack-\u0026gt;reserved.rtt = FILLP_NTOHL(pack-\u0026gt;reserved.rtt); pcb-\u0026gt;rtt = pack-\u0026gt;reserved.rtt; // 使用对端提供的RTT值 if (pcb-\u0026gt;rtt \u0026gt; 0) { FillpAdjustFcParamsByRtt(pcb); // 根据RTT调整流控参数 } } 7.4 ADHOC RTT探测机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // fillp_output.c:442-447 发送RTT探测包 pack.flag = FILLP_PACK_FLAG_ADHOC; pack.flag |= FILLP_PACK_FLAG_REQURE_RTT; pack.reserved.rtt = (FILLP_UINT32)((FILLP_ULLONG)curTime \u0026amp; 0xFFFFFFFF); // 在ADHOC包中携带当前时间戳 // fillp_input.c:593-612 处理RTT探测请求 if (pack-\u0026gt;flag \u0026amp; FILLP_PACK_FLAG_REQURE_RTT) { struct FillpPktPack tmpPack; tmpPack.flag = FILLP_NULL_NUM; tmpPack.flag |= FILLP_PACK_FLAG_ADHOC; tmpPack.flag |= FILLP_PACK_FLAG_WITH_RTT; tmpPack.reserved.rtt = FILLP_NTOHL(pack-\u0026gt;reserved.rtt); // 回传时间戳 // 发送响应包 FillpBuildAndSendPack(pcb, ftSock, \u0026amp;tmpPack, sizeof(struct FillpPktPack) - FILLP_HLEN); } 7.5 RTT在流量控制中的应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // fillp_common.c:683-704 根据RTT调整尾包保护参数 void FillpAjustTlpParameterByRtt(struct FillpPcb *pcb, FILLP_LLONG rtt) { if (rtt \u0026lt; FILLP_RTT_TIME_LEVEL1) { // RTT \u0026lt; 200ms pcb-\u0026gt;send.tailProtect.minJudgeThreshold = FILLP_ONE_THIRD_OF_RTT; pcb-\u0026gt;send.tailProtect.maxJudgeThreshold = FILLP_ONE_THIRD_OF_RTT + 1; } else if (rtt \u0026lt; FILLP_RTT_TIME_LEVEL2) { // RTT \u0026lt; 400ms pcb-\u0026gt;send.tailProtect.minJudgeThreshold = FILLP_ONE_FOURTH_OF_RTT; pcb-\u0026gt;send.tailProtect.maxJudgeThreshold = FILLP_ONE_FOURTH_OF_RTT + 1; } else { // RTT \u0026gt;= 400ms pcb-\u0026gt;send.tailProtect.minJudgeThreshold = FILLP_ONE_FIFTH_OF_RTT; pcb-\u0026gt;send.tailProtect.maxJudgeThreshold = FILLP_ONE_FIFTH_OF_RTT + 1; } } // fillp_common.c:722-726 根据RTT调整流控定时器 if ((pcb-\u0026gt;rtt / FILLP_FC_RTT_PACK_RATIO) \u0026lt; packInterval) { pcb-\u0026gt;FcTimerNode.interval = packInterval; } else { pcb-\u0026gt;FcTimerNode.interval = (FILLP_UINT32)(pcb-\u0026gt;rtt / FILLP_FC_RTT_PACK_RATIO); } 7.6 为什么FILLP的RTT比实际网络时延要低 7.6.1 测量粒度问题 问题1：应用层测量vs网络层真实时延\nFILLP的RTT测量是在应用层协议栈内部进行的，从数据包构建到数据包解析，而不是真正的网络传输时延：\n1 2 3 4 5 实际网络时延： 发送端网卡 → 网络传输 → 接收端网卡 FILLP测量的RTT： 发送端应用层 → UDP socket → 网络传输 → UDP socket → 接收端应用层 7.6.2 系统时钟精度和同步问题 1 2 3 4 5 6 7 // fillp_conn.c:458-461 时间异常检查 FILLP_LLONG rttTime = curTime - (FILLP_LLONG)reqAck.timestamp; if (rttTime \u0026lt;= 0) { FILLP_LOGWAR(\u0026#34;System Time has changed;curTime:%lld,reqTime:%llu\u0026#34;, curTime, reqAck.timestamp); return; // 系统时间变化导致计算异常 } 7.6.3 主要影响因素 测量层次问题：测量的是应用层到应用层的时延，而不是纯网络传输时延 系统因素影响：系统时钟精度、协议栈处理延迟等因素影响测量准确性 采样偏差：连接建立时的网络状况可能不代表数据传输时的真实情况 算法简化：为了简化实现，可能采用了相对乐观的RTT估计方法 8. 重传和可靠性保证 8.1 NACK机制 8.1.1 丢包检测和NACK发送 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 检测丢包并发送NACK static void FillpCheckAndSendNack(struct FillpPcb *pcb, FILLP_UINT32 expectedPktNum, FILLP_UINT32 receivedPktNum) { if (receivedPktNum \u0026gt; expectedPktNum + 1) { // 检测到丢包，发送NACK struct FillpPktNack nack; nack.lastPktNum = expectedPktNum; FillpSendNack(pcb, \u0026amp;nack); // 更新统计信息 pcb-\u0026gt;statistics.traffic.totalRecvLost += (receivedPktNum - expectedPktNum - 1); } } 8.1.2 NACK延迟发送机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // NACK延迟发送机制 static void FillpNackDelayProcess(struct FillpPcb *pcb) { if (!g_appResource.common.enableNackDelay) { return; } FILLP_LLONG currentTime = SYS_ARCH_GET_CUR_TIME_LONGLONG(); FILLP_LLONG delayTimeout = g_appResource.common.nackDelayTimeout; // 检查是否超过延迟时间 if ((currentTime - pcb-\u0026gt;recv.lastNackTime) \u0026gt; delayTimeout) { FillpSendDelayedNack(pcb); } } 8.2 快速重传 1 2 3 4 5 6 7 8 9 10 11 12 // 基于NACK的快速重传 static void FillpFastRetransmit(struct FillpPcb *pcb, FILLP_UINT32 lostPktNum) { struct FillpPcbItem *item = FillpFindUnackedItem(pcb, lostPktNum); if (item != FILLP_NULL_PTR) { // 立即重传，不等定时器 item-\u0026gt;sendCount++; FillpSendItem(pcb, item); // 更新统计信息 pcb-\u0026gt;statistics.traffic.totalRetryed++; } } 8.3 乱序处理机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 处理乱序数据包 static void FillpHandleOutOfOrderPacket(struct FillpPcb *pcb, struct FillpPcbItem *item) { // 插入到接收队列中，保持有序 if (SkipListInsert(\u0026amp;pcb-\u0026gt;recv.recvList, item, \u0026amp;item-\u0026gt;skipListNode, FILLP_TRUE) != ERR_OK) { FILLP_LOGERR(\u0026#34;Failed to insert out-of-order packet\u0026#34;); FillpRecvDropItem(pcb, item); return; } // 检查是否可以提交连续数据给应用层 FillpTryDeliverContinuousData(pcb); } 9. 系统调用和性能优化 9.1 UDP系统调用封装 9.1.1 发送路径分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // UDP发送函数实现 static int SysioSendUdp(void *arg, FILLP_CONST char *buf, FILLP_SIZE_T size, FILLP_SOCKADDR *dest, FILLP_UINT16 destAddrLen) { int ret; SysIoUdpSock *udpSock = (SysIoUdpSock *)arg; #if defined(FILLP_LINUX) \u0026amp;\u0026amp; !defined(FILLP_MAC) FILLP_INT flg = MSG_NOSIGNAL; // 避免SIGPIPE信号 #else FILLP_INT flg = 0; #endif if (udpSock-\u0026gt;connected) { // 已连接socket使用send ret = (int)FILLP_SEND(udpSock-\u0026gt;udpSock, buf, (FILLP_INT)size, flg); } else { // 未连接socket使用sendto ret = (int)FILLP_SENDTO(udpSock-\u0026gt;udpSock, buf, size, flg, dest, destAddrLen); } return ret; } 9.1.2 系统调用函数指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 系统函数指针结构 typedef struct { FILLP_INT (*sendtoCallbackFunc)(FILLP_INT sockFd, const void *buf, FILLP_SIZE_T len, FILLP_INT flags, const void *to, FILLP_SIZE_T toLen); FILLP_INT (*recvFromCallbackFunc)(FILLP_INT sockFd, void *buf, FILLP_SIZE_T len, FILLP_INT flags, void *from, void *fromLen); // ... 其他系统调用函数指针 } FillpSysLibCallbackFuncSt; extern FillpSysLibCallbackFuncSt g_fillpOsSocketLibFun; // 宏定义简化调用 #define FILLP_SENDTO (g_fillpOsSocketLibFun.sendtoCallbackFunc) #define FILLP_RECVFROM (g_fillpOsSocketLibFun.recvFromCallbackFunc) 9.2 性能优化要点 9.2.1 零拷贝优化 1 2 3 4 5 6 7 8 9 10 // 使用内存池避免频繁分配释放 static DympoolType *g_fillpItemPool = FILLP_NULL_PTR; struct FillpPcbItem *FillpAllocBufItem(void) { return (struct FillpPcbItem *)DympoolAlloc(g_fillpItemPool); } void FillpFreeBufItem(struct FillpPcbItem *item) { DympoolFree(g_fillpItemPool, item); } 9.2.2 无锁数据结构 1 2 3 4 5 6 7 8 9 10 11 // 使用无锁环形队列 struct LfRing { SysArchAtomic head; SysArchAtomic tail; FILLP_UINT32 size; void **data; }; // 原子操作保证线程安全 FILLP_BOOL LfRingPush(struct LfRing *ring, void *data); void *LfRingPop(struct LfRing *ring); 9.2.3 批量发送优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 批量处理减少系统调用 static void FillpBatchSend(struct FillpPcb *pcb) { struct FillpPcbItem *items[MAX_BATCH_SIZE]; int count = 0; // 批量获取发送项 while (count \u0026lt; MAX_BATCH_SIZE) { items[count] = FillpGetSendItem(\u0026amp;pcb-\u0026gt;send, pcb); if (items[count] == FILLP_NULL_PTR) { break; } count++; } // 批量发送 for (int i = 0; i \u0026lt; count; i++) { FillpSendItem(pcb, items[i]); } } 10. 关键数据结构 10.1 Socket相关结构 10.1.1 FtSocket结构 1 2 3 4 5 6 7 8 9 10 11 12 struct FtSocket { FILLP_INT index; // Socket索引 FILLP_INT allocState; // 分配状态 struct FtNetconn *netconn; // 网络连接 FILLP_UINT32 errCode; // 错误码 FILLP_UINT16 dataOptionFlag; // 数据选项标志 FILLP_BOOL isListenSock; // 是否为监听socket struct HlistNode listenNode; // 监听节点 SysArchAtomic sendEventCount; // 发送事件计数 SysArchAtomic rcvEvent; // 接收事件计数 // ... 其他字段 }; 10.1.2 FtNetconn结构 1 2 3 4 5 6 7 8 9 struct FtNetconn { struct FtSocket *sock; // 关联的socket struct SpungePcb *pcb; // 协议控制块 struct SockOsSocket *osSocket[MAX_SPUNGEINSTANCE_NUM]; // 系统socket FILLP_UINT8 state; // 连接状态 FILLP_BOOL shutdownRdSet; // 读关闭标志 FILLP_BOOL shutdownWrSet; // 写关闭标志 // ... 其他字段 }; 10.2 协议控制块结构 10.2.1 FillpPcb主结构 1 2 3 4 5 6 7 8 9 10 11 struct FillpPcb { struct FillpSendPcb send; // 发送控制块 struct FillpRecvPcb recv; // 接收控制块 struct FillpFlowControl fc; // 流量控制 struct FillpTimers timers; // 定时器 struct FillpStatisticsPcb statistics; // 统计信息 struct sockaddr remoteAddr; // 远程地址 struct sockaddr localAddr; // 本地地址 FILLP_UINT16 pktSize; // 包大小 // ... 流控算法相关字段 }; 10.2.2 发送控制块 1 2 3 4 5 6 7 8 9 10 11 struct FillpSendPcb { struct Hlist unSendList; // 未发送队列 struct SkipList unrecvList; // 未确认队列 struct SkipList redunList; // 冗余队列 FILLP_UINT32 seqNum; // 当前序列号 FILLP_UINT32 pktNum; // 当前包号 FILLP_UINT32 maxSendCache; // 最大发送缓存 FILLP_UINT32 unSendListBytes; // 未发送字节数 FILLP_UINT32 unrecvListBytes; // 未确认字节数 // ... 流控相关字段 }; 10.2.3 接收控制块 1 2 3 4 5 6 7 8 9 struct FillpRecvPcb { struct SkipList recvList; // 接收队列 FILLP_UINT32 seqNum; // 期望序列号 FILLP_UINT32 pktNum; // 期望包号 FILLP_UINT32 maxRecvCache; // 最大接收缓存 struct NackDelayList nackList; // NACK延迟列表 FILLP_LLONG lastNackTime; // 最后NACK时间 // ... 其他接收相关字段 }; 11. FILLP传输协议流程总结 11.1 完整传输流程概览 FILLP传输协议是一个基于UDP的可靠传输协议，其完整流程包括以下主要阶段：\n1 1. 协议栈初始化 → 2. 连接建立 → 3. 数据传输 → 4. 流量控制 → 5. 错误处理和重传 → 6. 连接关闭 11.2 详细流程分析 11.2.1 第一阶段：协议栈初始化 关键步骤：\n资源初始化：FtInit() - 初始化全局资源、内存池、定时器等 Socket创建：FtSocket() - 创建应用层socket，分配FtSocket结构 PCB分配：分配FillpPcb协议控制块，初始化发送/接收队列 系统Socket绑定：创建UDP socket，绑定到指定端口 关键数据结构初始化：\nUnSendList（未发送队列）- 使用HList UnAckList（未确认队列）- 使用SkipList RecvList（接收队列）- 使用SkipList 时间轮定时器系统 11.2.2 第二阶段：连接建立（四次握手） 客户端流程：\n1 FtConnect() → CONN_REQ → 等待CONN_REQ_ACK → CONN_CONFIRM → 等待CONN_CONFIRM_ACK → CONNECTED 服务端流程：\n1 FtListen() → 接收CONN_REQ → Cookie生成 → CONN_REQ_ACK → 接收CONN_CONFIRM → Cookie验证 → CONN_CONFIRM_ACK → CONNECTED 安全机制：\n使用HMAC-SHA256生成Cookie防止SYN洪水攻击 时间戳机制用于RTT初始测量 连接参数协商（缓冲区大小、超时时间等） 11.2.3 第三阶段：数据传输 发送流程：\n1 应用数据 → 分片处理 → 序列号分配 → FILLP头部封装 → 发送队列 → 流控检查 → UDP发送 → 重传管理 接收流程：\n1 UDP接收 → FILLP头部解析 → 序列号检查 → 乱序处理 → 接收队列 → 数据重组 → 应用层交付 关键机制：\n双编号系统：序列号（按字节）+ 包号（按包） 乱序处理：接收队列维护数据包顺序 数据完整性：基于序列号的数据完整性检查 11.2.4 第四阶段：流量控制 流控算法选择：\nALG0-ALG3多种流控算法 根据网络条件自适应选择 支持带宽探测和拥塞避免 关键参数：\n1 2 3 发送速率 = f(RTT, 丢包率, 缓冲区状态, 对端反馈) 包间隔时间 = (包大小 * 8 * 1000000) / 发送速率 窗口大小 = min(本地缓冲区, 对端接收窗口, 拥塞窗口) PACK包机制：\n定期发送PACK包进行流控反馈 携带接收窗口、速率建议、RTT信息 用于发送端动态调整发送速率 11.2.5 第五阶段：错误处理和重传 丢包检测：\n基于包号的gap检测 超时检测机制 重复确认检测 NACK重传：\n1 丢包检测 → NACK生成 → NACK发送（含延迟机制）→ 发送端接收NACK → 快速重传 重传策略：\n快速重传：立即重传NACK指示的丢失包 超时重传：基于RTO的超时重传 冗余重传：关键数据的主动冗余发送 11.2.6 第六阶段：连接管理和监控 连接保活：\nKeep-Alive定时器 PACK包心跳机制 连接状态监控 性能监控：\n1 2 3 4 5 6 7 8 9 struct FillpStatisticsPcb { FILLP_ULLONG totalSend; // 总发送包数 FILLP_ULLONG totalSendBytes; // 总发送字节数 FILLP_ULLONG totalRecv; // 总接收包数 FILLP_ULLONG totalRecvBytes; // 总接收字节数 FILLP_ULLONG totalRetryed; // 总重传次数 FILLP_ULLONG totalRecvLost; // 总丢包数 // ... 更多统计信息 }; 11.3 核心算法总结 11.3.1 RTT测量算法 1 2 3 4 1. 连接建立RTT：基于握手时间戳 2. 数据传输RTT：基于PACK包反馈 3. 主动探测RTT：ADHOC机制 4. RTT平滑：可配置的平滑算法 11.3.2 流量控制算法 1 2 3 4 1. 带宽探测：逐步增加发送速率 2. 拥塞检测：基于丢包率和RTT变化 3. 速率调整：根据网络反馈动态调整 4. 公平性保证：多连接间带宽公平分配 11.3.3 可靠性保证算法 1 2 3 4 1. 序列号机制：保证数据顺序和完整性 2. 确认机制：PACK包确认已接收数据 3. 重传机制：NACK快速重传 + 超时重传 4. 流控集成：重传与流控的协调机制 11.4 系统调用映射 发送路径系统调用：\n1 FtSend() → SockSendData() → FillpSendData() → FillpOutput() → SysioSendUdp() → sendto() 接收路径系统调用：\n1 recvfrom() → SysioFetchPacketUdp() → SpungePushRecvdDataToStack() → FillpDoInput() → FtRecv() 事件驱动：\n1 select()/epoll() → SpungeDoRecvCycle() → 数据包处理 → 应用层事件通知 11.5 传输协议特色 高性能设计：\n零拷贝优化 无锁数据结构 批量I/O处理 CPU亲和性优化 高可靠性：\n多层次错误检测 快速重传机制 连接状态管理 数据完整性保证 自适应性：\n动态流控算法 网络状况感知 参数自动调整 多场景适配 安全性：\nCookie防护机制 连接验证 防重放攻击 状态机保护 12. 总结和展望 12.1 FILLP协议优势总结 12.1.1 技术优势 分层架构设计：\n应用API层提供标准Socket接口 协议实现层处理可靠性和流控 系统I/O层抽象底层网络操作 良好的模块化和可扩展性 可靠性保证机制：\n序列号和包号双重编号系统 NACK快速重传机制 基于Cookie的安全连接建立 乱序数据包缓存和重排 高性能优化：\n无锁数据结构和原子操作 内存池管理避免频繁分配 批量I/O操作减少系统调用 支持GSO等硬件加速特性 流量控制算法：\n多种流控算法支持(ALG0-ALG3) 自适应带宽探测 基于RTT和丢包率的动态调整 拥塞避免和控制机制 12.1.2 关键性能数据 最大连接数：可配置，默认64个并发连接 缓冲区大小：发送/接收缓存可动态配置 重传机制：基于NACK的快速重传，支持冗余传输 流控精度：支持Kbps到Gbps级别的速率控制 12.1.3 技术创新点 双编号机制：序列号(按字节)和包号(按包)的双重编号 Cookie安全机制：基于HMAC-SHA256的连接安全验证 多层次流控：应用层、协议层、系统层的多级流量控制 自适应算法：根据网络状况动态调整传输参数 12.2 适用场景分析 FILLP协议特别适用于以下场景：\n高带宽长距离传输：卫星通信、跨洋数据传输 实时音视频传输：支持帧级别的数据标识和优先级 文件传输系统：大文件高效可靠传输 分布式存储：数据复制和同步 物联网通信：设备间高效数据交换 边缘计算：边缘节点与云端的数据传输 12.3 局限性和挑战 12.3.1 当前局限性 RTT测量精度：\n受系统时钟和协议栈处理延迟影响 连接建立时RTT可能不代表传输时真实RTT 缺乏持续的RTT监测机制 资源消耗：\n维护多个队列和状态信息的内存开销 复杂的流控算法带来的CPU开销 多线程协调的同步开销 网络适应性：\n对网络质量变化的响应速度有限 在极端网络条件下的性能表现需要验证 跨网络类型（WiFi/4G/5G）的适应性 12.3.2 技术挑战 多路径支持：当前主要基于单路径传输 移动性支持：网络切换时的连接保持能力 QoS保证：不同业务类型的服务质量保证 大规模并发：超大规模连接的性能优化 12.4 改进建议和发展方向 12.4.1 短期改进建议 RTT测量优化：\n引入持续RTT监测机制 使用指数加权移动平均平滑RTT抖动 区分应用RTT和网络RTT测量 性能优化：\n更智能的内存池管理策略 增强批量操作支持 CPU亲和性和NUMA优化 可靠性增强：\n更完善的错误检测和恢复机制 增强的统计信息和调试功能 连接迁移和故障转移支持 12.4.2 长期发展方向 多路径传输：\n支持MPTCP类似的多路径并发传输 路径质量感知和动态路径选择 负载均衡和冗余传输 智能流控：\n基于机器学习的流控算法 网络状况预测和主动调整 业务感知的QoS保证 边缘计算支持：\n支持边缘节点的动态发现和连接 计算任务迁移时的连接保持 边缘缓存和数据预取优化 标准化和生态：\n推动FILLP协议的标准化 构建完善的开发工具链 建立性能测试和验证体系 12.5 总结 FILLP协议作为一个基于UDP的高性能可靠传输协议，在设计上充分考虑了现代网络环境的特点和需求。通过本次深入分析，我们全面了解了：\n完整的实现架构：从应用API到系统调用的五层架构设计 详细的工作流程：连接建立、数据传输、流量控制的完整流程 关键技术机制：RTT测量、重传机制、安全保证等核心技术 性能优化策略：零拷贝、无锁结构、批量处理等优化手段 FILLP协议在华为DSoftBus框架中发挥着重要作用，为分布式软总线提供了高效可靠的传输基础。随着5G、物联网、边缘计算等新兴技术的发展，FILLP协议有望在更多场景中发挥重要作用。\n通过持续的技术创新和优化改进，FILLP协议将能够更好地适应未来网络环境的挑战，为构建高效、可靠、安全的分布式通信系统提供强有力的技术支撑。\n文档信息\n文档版本: 1.0 分析对象: OpenHarmony 5.0.2 DSoftBus FILLP协议实现 代码路径: components/nstackx/fillp/ 文档类型: 技术分析文档 本文档基于对DSoftBus项目中FILLP协议源码的深度分析和多个专项文档的整合，全面展现了FILLP协议的设计思想、实现机制和传输流程，为理解和使用FILLP协议提供了完整的技术参考。\n","date":"2025-09-17T00:00:00Z","permalink":"https://latteratter-coder.github.io/p/fillp%E5%8D%8F%E8%AE%AE/","title":"FILLP协议"},{"content":"全局数组越界访问行为分析报告 📋 目录 问题背景 测试环境 测试设计 实验结果 深入分析 安全性讨论 最佳实践建议 附录 问题背景 在C语言编程中，数组越界访问是一个常见且危险的问题。本报告专门研究以下场景：\n研究问题：在同一个进程中定义两个全局字符数组A、B（大小均为10），当数组A直接访问第12位（A[12]）时，程序是否会崩溃？能否正常访问？\n这个问题涉及到：\n全局变量的内存布局 操作系统的内存保护机制 编译器的内存对齐策略 未定义行为的实际表现 测试环境 项目 详情 操作系统 Linux 5.15.0-138-generic (Ubuntu) 架构 x86_64 编译器 GCC (GNU Compiler Collection) 编译选项 -Wall -Wextra -g -O0 测试工具 AddressSanitizer, Valgrind, objdump 测试设计 测试程序结构 1 2 3 4 5 6 7 8 9 10 11 // 全局数组定义 char A[10]; // 数组A，大小10字节 char B[10]; // 数组B，大小10字节 // 测试内容 1. 内存布局分析 2. 正常范围访问测试 3. 越界读取测试 (A[10] ~ A[15]) 4. 越界写入测试 (A[10] ~ A[12]) 5. 大范围越界测试 (A[10] ~ A[100]) 6. 段错误捕获机制 测试方法 基础测试：使用标准编译选项进行测试 内存检测：使用AddressSanitizer检测内存错误 符号分析：使用objdump分析内存布局 异常处理：实现信号处理机制捕获段错误 实验结果 🎯 核心结论 A[12] 不会崩溃，可以正常访问！\nA数组可以直接改写B数组的内容！\n详细测试数据 1. 内存布局分析 1 2 3 4 5 6 === 数组信息 === 数组A地址: 0x564e0133f120 数组B地址: 0x564e0133f110 数组A大小: 10 字节 数组B大小: 10 字节 A和B之间的距离: -16 字节 符号表信息（通过objdump获取）：\n1 2 0000000000004110 g O .bss 000000000000000a B 0000000000004120 g O .bss 000000000000000a A 2. 越界访问测试结果 访问位置 读取结果 写入结果 是否崩溃 A[10] ✅ 成功 ✅ 成功 ❌ 无崩溃 A[11] ✅ 成功 ✅ 成功 ❌ 无崩溃 A[12] ✅ 成功 ✅ 成功 ❌ 无崩溃 A[13-15] ✅ 成功 - ❌ 无崩溃 A[20-100] ✅ 成功 - ❌ 无崩溃 4. 新增：A数组改写B数组测试 测试方法 访问方式 结果 说明 负索引访问 A[-16] ✅ 成功改写B[0] B在A前16字节 系统性测试 A[-16] ~ A[-7] ✅ 完全控制B数组 可改写B[0] ~ B[9] AddressSanitizer A[-20] ❌ 检测到溢出 全局缓冲区溢出错误 5. 内存布局详细分析 实际内存布局：\n1 2 3 4 5 6 7 8 9 内存地址从低到高： ┌─────────────┬─────────────┬─────────────┐ │ 数组B │ 填充区域 │ 数组A │ │ (10字节) │ (6字节) │ (10字节) │ │0x...1110 │ │0x...1120 │ └─────────────┴─────────────┴─────────────┘ ↑ ↑ A[-16]~A[-7] A[0]~A[9] 可以改写B[0]~B[9] 正常A数组范围 关键发现：\nB数组在A数组前面16字节 A[-16] 对应 B[0]，A[-15] 对应 B[1]，以此类推 A[-16] ~ A[-7] 可以完全控制B数组的所有10个元素 6. 原始内存内容分析 1 2 3 4 5 6 7 8 9 10 从A[0]开始的20个字节内容: 偏移 0: 地址0x564e0133f120, 值=A (ASCII: 65) 偏移 1: 地址0x564e0133f121, 值=B (ASCII: 66) ... 偏移 9: 地址0x564e0133f129, 值=J (ASCII: 74) 偏移10: 地址0x564e0133f12a, 值=X (ASCII: 88) ← A[10]写入成功 偏移11: 地址0x564e0133f12b, 值=X (ASCII: 88) ← A[11]写入成功 偏移12: 地址0x564e0133f12c, 值=X (ASCII: 88) ← A[12]写入成功 偏移13: 地址0x564e0133f12d, 值=? (ASCII: 0) ... 深入分析 🔍 为什么A[12]不会崩溃？为什么A可以改写B？ 1. 内存段特性 全局数组位于.bss段\n.bss段：存储未初始化的全局和静态变量 连续内存：同一段内的变量通常分配在连续内存中 零初始化：.bss段在程序启动时被零初始化 2. 内存对齐机制 1 2 3 4 5 6 7 8 9 内存布局示意图： ┌─────────────┬─────────────┬─────────────┐ │ 数组B │ 填充区域 │ 数组A │ │ (10字节) │ (6字节) │ (10字节) │ │0x...4110 │ │0x...4120 │ └─────────────┴─────────────┴─────────────┘ ↑ A[10], A[11], A[12] 访问这个区域 编译器对齐策略：\n为了性能优化，编译器会进行内存对齐 在数组之间可能插入填充字节 这些填充区域通常可以安全访问 3. 操作系统保护机制 页级内存保护：\nLinux内存保护以页为单位（通常4KB） 小范围越界（几个字节）不会跨越页边界 只要在同一页内，不会触发段错误 虚拟内存管理：\n全局变量在进程启动时就分配好内存 .bss段通常有较大的连续空间 越界访问仍在进程的合法地址空间内 🧪 不同编译选项的影响 AddressSanitizer测试 越界访问测试：\n1 2 3 gcc -fsanitize=address -o test test.c ./test # 结果：A[12]访问仍然没有检测到错误 改写B数组测试：\n1 2 3 4 # 当测试A[-20]时，AddressSanitizer检测到错误： ERROR: AddressSanitizer: global-buffer-overflow WRITE of size 1 at 0x5574cb8f61dc thread T0 SUMMARY: AddressSanitizer: global-buffer-overflow 原因分析：\nAddressSanitizer对全局数组的小范围越界检测不够敏感 但对于较大范围的越界访问（如A[-20]）能够检测到 A[-16] ~ A[-7]的访问没有被检测到，说明在\u0026quot;安全\u0026quot;范围内 不同优化级别 -O0：无优化，越界访问成功 -O2/-O3：可能改变内存布局，但通常仍可访问 安全性讨论 ⚠️ 风险评估 1. 数据破坏风险 1 2 // 危险示例 A[12] = \u0026#39;X\u0026#39;; // 可能覆盖其他重要数据 2. 缓冲区溢出攻击 虽然不会立即崩溃，但可能被恶意利用 攻击者可能通过越界写入注入恶意代码 特别危险：A数组可以完全控制B数组，如果B数组存储敏感信息（如密码、权限标志），后果严重 3. 调试困难 越界访问可能导致难以重现的bug 数据损坏可能在很久之后才表现出来 🛡️ 未定义行为的危险性 C标准观点：\n数组越界访问是未定义行为（Undefined Behavior），编译器和运行时环境不保证任何特定的行为。\n实际影响：\n编译器差异：不同编译器可能有不同的内存布局 平台差异：不同操作系统、架构可能表现不同 版本差异：同一编译器的不同版本可能改变行为 优化影响：编译器优化可能改变内存布局 最佳实践建议 ✅ 安全编程实践 1. 边界检查 1 2 3 4 5 6 7 8 // 推荐做法 void safe_array_access(char* arr, int size, int index, char value) { if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size) { arr[index] = value; } else { fprintf(stderr, \u0026#34;数组越界：索引 %d 超出范围 [0, %d)\\n\u0026#34;, index, size); } } 2. 使用安全的数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 // 使用结构体封装数组 typedef struct { char data[10]; int size; } SafeArray; int safe_set(SafeArray* arr, int index, char value) { if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; arr-\u0026gt;size) { arr-\u0026gt;data[index] = value; return 1; // 成功 } return 0; // 失败 } 3. 编译时检查 1 2 3 4 5 6 7 8 # 启用所有警告 gcc -Wall -Wextra -Werror -o program program.c # 使用静态分析工具 gcc -fanalyzer -o program program.c # 使用运行时检查 gcc -fsanitize=address -fsanitize=bounds -o program program.c 4. 代码审查清单 所有数组访问都有边界检查 使用sizeof()而不是硬编码数组大小 循环边界正确设置 指针运算有范围验证 🔧 开发工具推荐 工具 用途 命令示例 AddressSanitizer 内存错误检测 gcc -fsanitize=address Valgrind 内存泄漏检测 valgrind --tool=memcheck ./program Clang Static Analyzer 静态代码分析 clang --analyze program.c Cppcheck 静态分析 cppcheck program.c 附录 A. 完整测试代码 1. 基础越界访问测试程序 (array_bounds_test.c) 这是最基础的测试程序，验证A[12]是否可以访问：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; // 定义两个全局字符数组，大小为10 char A[10]; char B[10]; // 用于捕获段错误的跳转缓冲区 static jmp_buf segfault_buf; static int segfault_occurred = 0; // 段错误信号处理函数 void segfault_handler(int sig) { segfault_occurred = 1; longjmp(segfault_buf, 1); } void print_array_info() { printf(\u0026#34;=== 数组信息 ===\\n\u0026#34;); printf(\u0026#34;数组A地址: %p\\n\u0026#34;, (void*)A); printf(\u0026#34;数组B地址: %p\\n\u0026#34;, (void*)B); printf(\u0026#34;数组A大小: %zu 字节\\n\u0026#34;, sizeof(A)); printf(\u0026#34;数组B大小: %zu 字节\\n\u0026#34;, sizeof(B)); printf(\u0026#34;A和B之间的距离: %ld 字节\\n\u0026#34;, (char*)B - (char*)A); printf(\u0026#34;\\n\u0026#34;); } void initialize_arrays() { // 初始化数组A for (int i = 0; i \u0026lt; 10; i++) { A[i] = \u0026#39;A\u0026#39; + i; // A[0]=\u0026#39;A\u0026#39;, A[1]=\u0026#39;B\u0026#39;, ..., A[9]=\u0026#39;J\u0026#39; } // 初始化数组B for (int i = 0; i \u0026lt; 10; i++) { B[i] = \u0026#39;a\u0026#39; + i; // B[0]=\u0026#39;a\u0026#39;, B[1]=\u0026#39;b\u0026#39;, ..., B[9]=\u0026#39;j\u0026#39; } printf(\u0026#34;=== 数组初始化完成 ===\\n\u0026#34;); printf(\u0026#34;数组A内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, A[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;数组B内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, B[i]); } printf(\u0026#34;\\n\\n\u0026#34;); } void test_array_access() { printf(\u0026#34;=== 测试数组访问 ===\\n\u0026#34;); // 测试正常访问 printf(\u0026#34;正常访问测试:\\n\u0026#34;); printf(\u0026#34;A[0] = %c\\n\u0026#34;, A[0]); printf(\u0026#34;A[9] = %c\\n\u0026#34;, A[9]); printf(\u0026#34;B[0] = %c\\n\u0026#34;, B[0]); printf(\u0026#34;B[9] = %c\\n\u0026#34;, B[9]); printf(\u0026#34;\\n\u0026#34;); // 测试越界访问 printf(\u0026#34;越界访问测试:\\n\u0026#34;); // 设置信号处理器 signal(SIGSEGV, segfault_handler); // 测试访问A[10], A[11], A[12]等 for (int i = 10; i \u0026lt;= 15; i++) { segfault_occurred = 0; if (setjmp(segfault_buf) == 0) { // 尝试读取 char value = A[i]; printf(\u0026#34;A[%d] = %c (ASCII: %d) - 成功读取\\n\u0026#34;, i, (value \u0026gt;= 32 \u0026amp;\u0026amp; value \u0026lt;= 126) ? value : \u0026#39;?\u0026#39;, (int)value); } else { printf(\u0026#34;A[%d] - 访问时发生段错误！\\n\u0026#34;, i); } } printf(\u0026#34;\\n\u0026#34;); // 测试写入越界位置 printf(\u0026#34;越界写入测试:\\n\u0026#34;); for (int i = 10; i \u0026lt;= 12; i++) { segfault_occurred = 0; if (setjmp(segfault_buf) == 0) { A[i] = \u0026#39;X\u0026#39;; printf(\u0026#34;A[%d] = \u0026#39;X\u0026#39; - 成功写入\\n\u0026#34;, i); } else { printf(\u0026#34;A[%d] - 写入时发生段错误！\\n\u0026#34;, i); } } printf(\u0026#34;\\n\u0026#34;); // 检查B数组是否被影响 printf(\u0026#34;检查B数组是否被影响:\\n\u0026#34;); printf(\u0026#34;数组B当前内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, B[i]); } printf(\u0026#34;\\n\u0026#34;); } void test_memory_layout() { printf(\u0026#34;=== 内存布局分析 ===\\n\u0026#34;); // 显示内存中的实际内容 printf(\u0026#34;从A[0]开始的20个字节内容:\\n\u0026#34;); for (int i = 0; i \u0026lt; 20; i++) { char* ptr = (char*)A + i; printf(\u0026#34;偏移%2d: 地址%p, 值=%c (ASCII:%3d)\\n\u0026#34;, i, (void*)ptr, (*ptr \u0026gt;= 32 \u0026amp;\u0026amp; *ptr \u0026lt;= 126) ? *ptr : \u0026#39;?\u0026#39;, (int)*ptr); } printf(\u0026#34;\\n\u0026#34;); // 检查A和B的相对位置 if ((char*)B \u0026gt; (char*)A) { long distance = (char*)B - (char*)A; printf(\u0026#34;B数组在A数组之后 %ld 字节\\n\u0026#34;, distance); if (distance == 10) { printf(\u0026#34;A和B在内存中是连续的！A[10]实际上就是B[0]\\n\u0026#34;); } else if (distance \u0026lt; 20) { printf(\u0026#34;A和B在内存中很接近，可能存在重叠访问\\n\u0026#34;); } } else { long distance = (char*)A - (char*)B; printf(\u0026#34;A数组在B数组之后 %ld 字节\\n\u0026#34;, distance); } } int main() { printf(\u0026#34;全局字符数组越界访问测试程序\\n\u0026#34;); printf(\u0026#34;=====================================\\n\\n\u0026#34;); print_array_info(); initialize_arrays(); test_array_access(); test_memory_layout(); printf(\u0026#34;=== 测试总结 ===\\n\u0026#34;); printf(\u0026#34;1. 全局数组通常分配在数据段(.data或.bss)\\n\u0026#34;); printf(\u0026#34;2. 编译器可能会将相邻声明的全局数组放在连续内存中\\n\u0026#34;); printf(\u0026#34;3. 越界访问可能不会立即崩溃，但会导致未定义行为\\n\u0026#34;); printf(\u0026#34;4. 实际行为取决于编译器、链接器和运行时环境\\n\u0026#34;); printf(\u0026#34;5. 在生产代码中应该避免任何形式的越界访问\\n\u0026#34;); return 0; } 2. 数组改写测试程序 (array_overwrite_test.c) 这个程序专门测试A数组是否可以改写B数组的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; // 定义两个全局字符数组，大小为10 char A[10]; char B[10]; // 用于捕获段错误的跳转缓冲区 static jmp_buf segfault_buf; static int segfault_occurred = 0; // 段错误信号处理函数 void segfault_handler(int sig) { segfault_occurred = 1; longjmp(segfault_buf, 1); } void print_memory_layout() { printf(\u0026#34;=== 内存布局信息 ===\\n\u0026#34;); printf(\u0026#34;数组A地址: %p\\n\u0026#34;, (void*)A); printf(\u0026#34;数组B地址: %p\\n\u0026#34;, (void*)B); printf(\u0026#34;A和B之间的距离: %ld 字节\\n\u0026#34;, (char*)B - (char*)A); // 判断A和B的相对位置 if ((char*)A \u0026lt; (char*)B) { printf(\u0026#34;内存布局: A在前，B在后\\n\u0026#34;); printf(\u0026#34;A[10]及以后可能影响B数组\\n\u0026#34;); } else { printf(\u0026#34;内存布局: B在前，A在后\\n\u0026#34;); printf(\u0026#34;A的负索引可能影响B数组\\n\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } void initialize_arrays() { printf(\u0026#34;=== 初始化数组 ===\\n\u0026#34;); // 初始化数组A for (int i = 0; i \u0026lt; 10; i++) { A[i] = \u0026#39;A\u0026#39; + i; // A[0]=\u0026#39;A\u0026#39;, A[1]=\u0026#39;B\u0026#39;, ..., A[9]=\u0026#39;J\u0026#39; } // 初始化数组B for (int i = 0; i \u0026lt; 10; i++) { B[i] = \u0026#39;a\u0026#39; + i; // B[0]=\u0026#39;a\u0026#39;, B[1]=\u0026#39;b\u0026#39;, ..., B[9]=\u0026#39;j\u0026#39; } printf(\u0026#34;数组A初始内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, A[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;数组B初始内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, B[i]); } printf(\u0026#34;\\n\\n\u0026#34;); } int test_overwrite_via_negative_index() { printf(\u0026#34;=== 测试通过负索引改写B数组 ===\\n\u0026#34;); long distance = (char*)A - (char*)B; int b_changed = 0; if (distance \u0026gt; 0) { // A在B后面，尝试通过A的负索引访问B printf(\u0026#34;A在B后面，距离%ld字节，尝试通过A[-%ld]访问B[0]\\n\u0026#34;, distance, distance); segfault_occurred = 0; if (setjmp(segfault_buf) == 0) { char old_b0 = B[0]; A[-distance] = \u0026#39;Y\u0026#39;; // 尝试通过A的负索引修改B[0] if (B[0] != old_b0) { printf(\u0026#34;✅ 成功！A[-%ld] = \u0026#39;Y\u0026#39; 改变了B[0]: \u0026#39;%c\u0026#39; -\u0026gt; \u0026#39;%c\u0026#39;\\n\u0026#34;, distance, old_b0, B[0]); b_changed = 1; } else { printf(\u0026#34;❌ A[-%ld] = \u0026#39;Y\u0026#39; 没有影响B[0]\\n\u0026#34;, distance); } } else { printf(\u0026#34;❌ 访问A[-%ld]时发生段错误\\n\u0026#34;, distance); } } else { printf(\u0026#34;B在A后面，无法通过负索引直接访问B\\n\u0026#34;); } return b_changed; } void test_systematic_overwrite() { printf(\u0026#34;=== 系统性测试：寻找能影响B的A索引 ===\\n\u0026#34;); // 重新初始化数组 initialize_arrays(); printf(\u0026#34;测试范围：A[-20] 到 A[30]\\n\u0026#34;); for (int offset = -20; offset \u0026lt;= 30; offset++) { // 保存B数组的原始状态 char original_b[10]; memcpy(original_b, B, 10); segfault_occurred = 0; if (setjmp(segfault_buf) == 0) { // 尝试写入一个特殊值 A[offset] = \u0026#39;Z\u0026#39;; // 检查B数组是否被改变 int b_index_changed = -1; for (int i = 0; i \u0026lt; 10; i++) { if (B[i] != original_b[i]) { b_index_changed = i; break; } } if (b_index_changed \u0026gt;= 0) { printf(\u0026#34;🎯 A[%d] = \u0026#39;Z\u0026#39; 影响了B[%d]: \u0026#39;%c\u0026#39; -\u0026gt; \u0026#39;%c\u0026#39;\\n\u0026#34;, offset, b_index_changed, original_b[b_index_changed], B[b_index_changed]); // 恢复B数组 B[b_index_changed] = original_b[b_index_changed]; } } else { printf(\u0026#34;💥 A[%d] 访问时发生段错误\\n\u0026#34;, offset); } } } // ... 其他函数省略 ... int main() { printf(\u0026#34;全局数组A改写数组B测试程序\\n\u0026#34;); printf(\u0026#34;================================\\n\\n\u0026#34;); print_memory_layout(); initialize_arrays(); int negative_success = test_overwrite_via_negative_index(); test_systematic_overwrite(); printf(\u0026#34;=== 测试总结 ===\\n\u0026#34;); printf(\u0026#34;1. 通过负索引改写B: %s\\n\u0026#34;, negative_success ? \u0026#34;成功\u0026#34; : \u0026#34;失败\u0026#34;); printf(\u0026#34;2. A数组%s直接改写B数组的内容\\n\u0026#34;, negative_success ? \u0026#34;可以\u0026#34; : \u0026#34;无法\u0026#34;); printf(\u0026#34;3. 这种行为是未定义的，不应在生产代码中使用\\n\u0026#34;); return 0; } 3. 安全威胁演示程序 (dangerous_demo.c) 这个程序演示了数组越界访问如何被恶意利用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 模拟一个真实的安全场景 char user_input[10]; // 用户输入缓冲区 char admin_flag[10]; // 管理员权限标志 void initialize_system() { // 初始化管理员标志为\u0026#34;NOADMIN\u0026#34; strcpy(admin_flag, \u0026#34;NOADMIN\u0026#34;); printf(\u0026#34;系统初始化完成\\n\u0026#34;); printf(\u0026#34;管理员权限: %s\\n\u0026#34;, admin_flag); } void process_user_input(const char* input) { printf(\u0026#34;\\n处理用户输入: %s\\n\u0026#34;, input); // 危险的操作：没有边界检查的复制 for (int i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) { user_input[i] = input[i]; // 潜在的缓冲区溢出 } printf(\u0026#34;用户输入已保存\\n\u0026#34;); } void check_admin_privileges() { printf(\u0026#34;\\n检查管理员权限...\\n\u0026#34;); printf(\u0026#34;当前管理员标志: %s\\n\u0026#34;, admin_flag); if (strncmp(admin_flag, \u0026#34;ADMIN\u0026#34;, 5) == 0) { printf(\u0026#34;🔓 管理员权限已激活！可以执行特权操作。\\n\u0026#34;); } else { printf(\u0026#34;🔒 普通用户权限，无法执行特权操作。\\n\u0026#34;); } } int main() { printf(\u0026#34;危险的数组越界访问演示\\n\u0026#34;); printf(\u0026#34;========================\\n\u0026#34;); initialize_system(); // 正常的用户输入 printf(\u0026#34;\\n--- 测试1: 正常输入 ---\\n\u0026#34;); process_user_input(\u0026#34;hello\u0026#34;); check_admin_privileges(); // 危险的长输入，可能覆盖admin_flag printf(\u0026#34;\\n--- 测试2: 长输入（可能的攻击）---\\n\u0026#34;); // 计算需要多少字符才能到达admin_flag long distance = (char*)admin_flag - (char*)user_input; if (distance \u0026gt; 0 \u0026amp;\u0026amp; distance \u0026lt; 50) { printf(\u0026#34;尝试通过长输入覆盖admin_flag...\\n\u0026#34;); // 构造恶意输入 char malicious_input[100]; memset(malicious_input, \u0026#39;X\u0026#39;, distance); // 填充到admin_flag位置 strcpy(malicious_input + distance, \u0026#34;ADMIN\u0026#34;); // 在admin_flag位置写入\u0026#34;ADMIN\u0026#34; malicious_input[distance + 5] = \u0026#39;\\0\u0026#39;; // 确保字符串结束 printf(\u0026#34;恶意输入长度: %ld 字节\\n\u0026#34;, strlen(malicious_input)); process_user_input(malicious_input); check_admin_privileges(); printf(\u0026#34;\\n💀 攻击成功！通过缓冲区溢出获得了管理员权限！\\n\u0026#34;); } else { printf(\u0026#34;当前内存布局不适合演示攻击（距离：%ld）\\n\u0026#34;, distance); } printf(\u0026#34;\\n⚠️ 这个演示展示了为什么数组越界访问如此危险！\\n\u0026#34;); printf(\u0026#34;⚠️ 在真实的程序中，这种漏洞可能被恶意利用来获取系统权限。\\n\u0026#34;); return 0; } 4. 编译脚本 (Makefile) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 CC = gcc CFLAGS = -Wall -Wextra -g -O0 TARGET = array_bounds_test SOURCE = array_bounds_test.c OVERWRITE_TARGET = array_overwrite_test OVERWRITE_SOURCE = array_overwrite_test.c DEMO_TARGET = dangerous_demo DEMO_SOURCE = dangerous_demo.c # 默认目标 all: $(TARGET) $(OVERWRITE_TARGET) $(DEMO_TARGET) # 编译目标 $(TARGET): $(SOURCE) $(CC) $(CFLAGS) -o $(TARGET) $(SOURCE) # 编译改写测试程序 $(OVERWRITE_TARGET): $(OVERWRITE_SOURCE) $(CC) $(CFLAGS) -o $(OVERWRITE_TARGET) $(OVERWRITE_SOURCE) # 编译危险演示程序 $(DEMO_TARGET): $(DEMO_SOURCE) $(CC) $(CFLAGS) -o $(DEMO_TARGET) $(DEMO_SOURCE) # 运行测试 run: $(TARGET) ./$(TARGET) # 运行改写测试 run-overwrite: $(OVERWRITE_TARGET) ./$(OVERWRITE_TARGET) # 运行危险演示 run-demo: $(DEMO_TARGET) ./$(DEMO_TARGET) # 使用AddressSanitizer编译 asan: $(SOURCE) $(CC) $(CFLAGS) -fsanitize=address -o $(TARGET)_asan $(SOURCE) # 使用AddressSanitizer编译改写测试 asan-overwrite: $(OVERWRITE_SOURCE) $(CC) $(CFLAGS) -fsanitize=address -o $(OVERWRITE_TARGET)_asan $(OVERWRITE_SOURCE) # 运行AddressSanitizer版本 run-asan: asan ./$(TARGET)_asan # 运行AddressSanitizer改写测试版本 run-asan-overwrite: asan-overwrite ./$(OVERWRITE_TARGET)_asan # 清理 clean: rm -f $(TARGET) $(TARGET)_asan $(OVERWRITE_TARGET) $(OVERWRITE_TARGET)_asan $(DEMO_TARGET) # 显示帮助 help: @echo \u0026#34;可用的目标:\u0026#34; @echo \u0026#34; all - 编译所有程序\u0026#34; @echo \u0026#34; run - 编译并运行越界访问测试程序\u0026#34; @echo \u0026#34; run-overwrite - 编译并运行数组改写测试程序\u0026#34; @echo \u0026#34; run-demo - 编译并运行危险演示程序\u0026#34; @echo \u0026#34; valgrind - 使用valgrind运行越界访问测试\u0026#34; @echo \u0026#34; asan - 使用AddressSanitizer编译越界访问测试\u0026#34; @echo \u0026#34; asan-overwrite - 使用AddressSanitizer编译改写测试\u0026#34; @echo \u0026#34; run-asan - 运行AddressSanitizer版本的越界访问测试\u0026#34; @echo \u0026#34; run-asan-overwrite - 运行AddressSanitizer版本的改写测试\u0026#34; @echo \u0026#34; clean - 清理生成的文件\u0026#34; @echo \u0026#34; help - 显示此帮助信息\u0026#34; .PHONY: all run run-overwrite run-demo valgrind asan asan-overwrite run-asan run-asan-overwrite clean help 5. 代码使用说明 快速开始：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 1. 下载所有代码文件到同一目录 # 2. 确保系统安装了GCC编译器 # 3. 运行以下命令： # 编译所有程序 make all # 运行基础测试（验证A[12]访问） make run # 运行改写测试（验证A改写B） make run-overwrite # 运行安全演示（权限提升攻击） make run-demo 高级测试：\n1 2 3 4 5 6 7 8 9 10 11 # 使用AddressSanitizer检测内存错误 make run-asan-overwrite # 使用Valgrind检测内存问题 make valgrind # 查看所有可用命令 make help # 清理生成的文件 make clean 代码结构说明：\n每个程序都包含段错误处理机制 使用setjmp/longjmp捕获可能的崩溃 详细的内存布局分析和结果输出 支持多种编译器选项和调试工具 B. 编译和运行指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 越界访问测试 make run # 数组改写测试 make run-overwrite # AddressSanitizer测试 make run-asan make run-asan-overwrite # Valgrind测试 make valgrind # 查看符号表 objdump -t array_bounds_test | grep -E \u0026#34;(A|B)$\u0026#34; # 查看所有可用命令 make help C. 测试结果示例 基础越界访问测试输出示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 全局字符数组越界访问测试程序 ===================================== === 数组信息 === 数组A地址: 0x564e0133f120 数组B地址: 0x564e0133f110 数组A大小: 10 字节 数组B大小: 10 字节 A和B之间的距离: -16 字节 === 数组初始化完成 === 数组A内容: A B C D E F G H I J 数组B内容: a b c d e f g h i j === 测试数组访问 === 正常访问测试: A[0] = A A[9] = J B[0] = a B[9] = j 越界访问测试: A[10] = ? (ASCII: 0) - 成功读取 A[11] = ? (ASCII: 0) - 成功读取 A[12] = ? (ASCII: 0) - 成功读取 ← 关键结果：A[12]可以访问！ A[13] = ? (ASCII: 0) - 成功读取 A[14] = ? (ASCII: 0) - 成功读取 A[15] = ? (ASCII: 0) - 成功读取 越界写入测试: A[10] = \u0026#39;X\u0026#39; - 成功写入 A[11] = \u0026#39;X\u0026#39; - 成功写入 A[12] = \u0026#39;X\u0026#39; - 成功写入 ← 关键结果：A[12]可以写入！ 数组改写测试输出示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 全局数组A改写数组B测试程序 ================================ === 内存布局信息 === 数组A地址: 0x564a46bc3120 数组B地址: 0x564a46bc3110 A和B之间的距离: -16 字节 内存布局: B在前，A在后 A的负索引可能影响B数组 === 测试通过负索引改写B数组 === A在B后面，距离16字节，尝试通过A[-16]访问B[0] ✅ 成功！A[-16] = \u0026#39;Y\u0026#39; 改变了B[0]: \u0026#39;a\u0026#39; -\u0026gt; \u0026#39;Y\u0026#39; ← 关键结果：A可以改写B！ === 系统性测试：寻找能影响B的A索引 === 测试范围：A[-20] 到 A[30] 🎯 A[-16] = \u0026#39;Z\u0026#39; 影响了B[0]: \u0026#39;a\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-15] = \u0026#39;Z\u0026#39; 影响了B[1]: \u0026#39;b\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-14] = \u0026#39;Z\u0026#39; 影响了B[2]: \u0026#39;c\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-13] = \u0026#39;Z\u0026#39; 影响了B[3]: \u0026#39;d\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-12] = \u0026#39;Z\u0026#39; 影响了B[4]: \u0026#39;e\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-11] = \u0026#39;Z\u0026#39; 影响了B[5]: \u0026#39;f\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-10] = \u0026#39;Z\u0026#39; 影响了B[6]: \u0026#39;g\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-9] = \u0026#39;Z\u0026#39; 影响了B[7]: \u0026#39;h\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-8] = \u0026#39;Z\u0026#39; 影响了B[8]: \u0026#39;i\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-7] = \u0026#39;Z\u0026#39; 影响了B[9]: \u0026#39;j\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; ← A[-16]~A[-7]完全控制B数组！ 安全演示输出示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 危险的数组越界访问演示 ======================== 系统初始化完成 管理员权限: NOADMIN === 内存布局信息 === user_input地址: 0x5561d97b2018 admin_flag地址: 0x5561d97b2028 两者距离: 16 字节 ⚠️ admin_flag在user_input后16字节 ⚠️ user_input[16] 可以修改admin_flag[0] --- 测试1: 正常输入 --- 处理用户输入: hello 用户输入已保存 检查管理员权限... 当前管理员标志: NOADMIN 🔒 普通用户权限，无法执行特权操作。 --- 测试2: 长输入（可能的攻击）--- 尝试通过长输入覆盖admin_flag... 恶意输入长度: 21 字节 处理用户输入: XXXXXXXXXXXXXXXXADMIN 用户输入已保存 检查管理员权限... 当前管理员标志: ADMININ 🔓 管理员权限已激活！可以执行特权操作。 ← 攻击成功！ 💀 攻击成功！通过缓冲区溢出获得了管理员权限！ D. 相关资源 C11标准文档 GCC文档 - AddressSanitizer Linux内存管理 📝 结论 通过详细的实验验证，我们得出以下结论：\n🎯 直接回答原问题： A[12]不会崩溃，可以正常访问 A数组可以直接改写B数组的内容 🔬 技术发现： 内存布局：B数组在A数组前16字节，编译器在它们之间留有6字节填充 访问方式：通过A[-16] ~ A[-7]可以完全控制B[0] ~ B[9] 检测工具：AddressSanitizer能检测到大范围越界，但对小范围越界不敏感 ⚠️ 安全警告： 未定义行为：这种访问方式是C标准未定义的行为 极度危险：A数组能完全控制B数组，可能导致严重安全问题 不可移植：不同编译器、平台可能有完全不同的行为 💡 最佳实践： 永远不要依赖这种行为 使用边界检查和安全的数据结构 启用所有编译器警告和静态分析工具 最重要的提醒：虽然测试显示不会崩溃，但这种行为是不可预测和不可移植的。在任何生产环境中都应该避免数组越界访问。\n报告生成时间：2025年9月12日\n测试环境：Linux x86_64, GCC编译器\n","date":"2025-09-12T00:00:00Z","permalink":"https://latteratter-coder.github.io/p/%E5%85%A8%E5%B1%80%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/","title":"全局数组越界访问行为分析"},{"content":"内存踩踏现象分析报告 - A操作B内存但A不崩溃，B访问时崩溃 📋 目录 问题背景 现象分析 测试验证 技术原理 实际案例 检测方法 防护措施 完整测试代码 问题背景 🔍 核心问题 是否存在A、B两个变量，A操作了B的内存，但是A没有崩溃，而B去正常访问自己的内容时崩溃的情况？\n这个问题指向了一个非常重要的内存安全概念：**内存踩踏（Memory Corruption）**的延迟效应。\n🎯 问题的实际意义 这种现象在实际软件开发中经常遇到，特别是：\n系统崩溃难以定位：崩溃点不是真正的问题根源 间歇性bug：同样的操作有时崩溃有时不崩溃 多线程环境：一个线程的错误导致另一个线程崩溃 现象分析 ✅ 答案：确实存在这种情况！ 这种现象不仅存在，而且在实际开发中相当常见。主要原因包括：\n内存布局的特殊性 操作系统内存保护的延迟性 内存管理机制的复杂性 编译器优化的影响 📊 典型场景分析 场景类型 A的操作 A的结果 B的操作 B的结果 堆内存踩踏 越界写入32字节 ✅ 不崩溃 realloc() 💥 崩溃 栈帧破坏 栈溢出 ✅ 不崩溃 函数返回 💥 崩溃 函数指针篡改 修改函数指针表 ✅ 不崩溃 调用函数指针 💥 执行错误代码 多线程竞争 越界写共享内存 ✅ 不崩溃 读取被踩踏区域 💥 崩溃 测试验证 🧪 实验设计 我们设计了5个测试场景来验证这种现象：\n1. 相邻全局数组测试 1 2 3 4 5 char global_A[10]; char global_B[10]; // A通过越界访问修改B的内存 // B正常访问自己的内存时可能崩溃 2. 堆内存踩踏测试 ⭐ 1 2 3 4 5 6 7 8 char* heap_A = malloc(16); char* heap_B = malloc(16); // A越界写入32字节，破坏堆管理结构 memset(heap_A, \u0026#39;X\u0026#39;, 32); // A不崩溃 // B进行正常内存操作 heap_B = realloc(heap_B, 32); // B崩溃！ 3. 栈内存踩踏测试 1 2 3 4 5 6 7 8 9 10 11 12 void function_A() { char buffer[16]; // 栈溢出，破坏其他栈帧 char overflow[2048]; memset(overflow, \u0026#39;X\u0026#39;, sizeof(overflow)); // A不崩溃 } void function_B() { char local_data[16]; // 正常访问栈数据 printf(\u0026#34;%s\u0026#34;, local_data); // 可能崩溃 } 4. 函数指针表踩踏 1 2 3 4 5 6 7 FunctionPtr function_table[5]; // A修改函数指针表 function_table[2] = corrupted_function; // A不崩溃 // B调用函数指针 function_table[2](); // B执行了错误的函数 5. 多线程内存踩踏 1 2 3 4 5 6 7 8 // 线程A：越界写入共享数据 for (int i = 0; i \u0026lt; 150; i++) { shared_data[i] = 0xDEADBEEF; // 超出100的范围 } // 线程B：正常访问数据 char* ptr = (char*)\u0026amp;shared_data[99] + 10; char value = *ptr; // 可能访问被踩踏的内存 📈 实际测试结果 运行我们的测试程序得到以下结果：\n1 2 3 4 5 6 7 8 9 10 11 === 测试场景2：堆内存踩踏 === heap_A地址: 0x55d2ef0d86b0 heap_B地址: 0x55d2ef0d86d0 距离: 32 字节 步骤1：A进行越界写入操作... ✅ A的越界写入操作完成，A没有崩溃 步骤2：B进行正常的内存操作... realloc(): invalid old size [程序崩溃] ✅ 验证成功！ A的越界写入没有崩溃，但B的正常realloc操作崩溃了！\n技术原理 🔬 为什么A不崩溃？ 1. 内存保护的粒度限制 1 2 3 4 5 6 7 8 操作系统内存保护以页为单位（通常4KB） ┌─────────────────────────────────────────┐ │ 4KB 页面 │ │ heap_A[16] │ heap_B[16] │ 其他数据 │ └─────────────────────────────────────────┘ ↑ ↑ A越界写入32字节，仍在同一页面内 操作系统不会触发段错误 2. 堆管理结构的位置 1 2 3 4 5 6 7 8 典型的堆内存布局： ┌──────────┬──────────┬──────────┬──────────┐ │ 管理头部 │ heap_A │ 管理头部 │ heap_B │ │ (8字节) │ (16字节) │ (8字节) │ (16字节) │ └──────────┴──────────┴──────────┴──────────┘ ↑ ↑ A越界写入破坏了B的管理头部 但A的写入操作本身不会崩溃 3. 写入操作的特性 内存写入通常只检查页面权限 不检查具体的对象边界 只要地址可写，操作就会成功 💥 为什么B会崩溃？ 1. 堆管理结构被破坏 1 2 3 4 5 6 7 8 9 // 正常的堆块头部信息 struct heap_chunk { size_t size; // 块大小 size_t prev_size; // 前一块大小 // 其他管理信息 }; // A的越界写入破坏了这些信息 // 当B调用realloc时，堆管理器读取到错误的信息 2. 数据结构一致性检查 1 2 3 4 // realloc内部会进行一致性检查 if (chunk-\u0026gt;size != expected_size) { abort(); // 检测到数据损坏，主动崩溃 } 3. 延迟的内存访问 1 2 3 4 // A的破坏是\u0026#34;定时炸弹\u0026#34; A_corrupts_memory(); // 埋下炸弹，不爆炸 // ... 其他操作 ... B_accesses_memory(); // 触发炸弹，崩溃 实际案例 🔍 你提到的softbus_server崩溃 根据你提供的崩溃信息：\n1 2 3 4 5 Pid:700, Uid:1024, Process name:softbus_server Tid:1193, Name:nStackXDFinder #00 pc 0000000000308720 Not mapped #01 pc 000000000015272c PostAuthEvent.cfi #02 pc 000000000001884c libnstackx_ctrl.z.so 分析：\n线程1193本不应该调用PostAuthEvent 但崩溃堆栈显示确实调用了 访问了未映射的内存地址0x308720 可能的内存踩踏场景：\n1 2 3 4 5 6 7 8 9 // 场景1：函数指针被踩踏 typedef void (*EventHandler)(int event, void* data); EventHandler handler = normal_handler; // 其他线程的内存操作意外修改了handler // handler现在指向了PostAuthEvent // 当nStackXDFinder调用handler时 handler(event, data); // 实际调用了PostAuthEvent 1 2 3 4 5 6 7 8 9 10 // 场景2：回调函数表被破坏 struct callback_table { EventHandler handlers[10]; }; // 某个越界写入操作修改了回调表 // handlers[5] = PostAuthEvent; // nStackXDFinder调用回调 callbacks.handlers[5](event, data); // 意外调用PostAuthEvent 🔧 排查建议 检查nStackXDFinder线程中的函数指针 查看共享数据结构是否被其他线程踩踏 使用AddressSanitizer检测内存踩踏 添加函数指针有效性检查 检测方法 🛠️ 编译时检测 1. AddressSanitizer 1 gcc -fsanitize=address -fno-omit-frame-pointer -o program program.c 优点：\n能检测大部分堆栈越界 提供详细的错误报告 性能开销相对较小 局限性：\n可能漏检小范围越界 对全局变量检测不够敏感 2. Valgrind 1 valgrind --tool=memcheck --leak-check=full ./program 3. 静态分析工具 1 2 clang-static-analyzer program.c cppcheck --enable=all program.c 🕵️ 运行时检测 1. 内存模式检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 在关键位置添加魔数检查 #define MAGIC_NUMBER 0xDEADBEEF struct protected_data { uint32_t magic_start; char actual_data[100]; uint32_t magic_end; }; void check_integrity(struct protected_data* data) { if (data-\u0026gt;magic_start != MAGIC_NUMBER || data-\u0026gt;magic_end != MAGIC_NUMBER) { printf(\u0026#34;内存被踩踏！\\n\u0026#34;); abort(); } } 2. 函数指针有效性检查 1 2 3 4 5 6 7 8 9 10 11 12 13 int is_valid_function_pointer(void* ptr) { // 检查指针是否在合法的代码段范围内 extern char _text_start, _text_end; return (ptr \u0026gt;= (void*)\u0026amp;_text_start \u0026amp;\u0026amp; ptr \u0026lt;= (void*)\u0026amp;_text_end); } void safe_call_function(FunctionPtr func) { if (is_valid_function_pointer((void*)func)) { func(); } else { printf(\u0026#34;无效的函数指针：%p\\n\u0026#34;, (void*)func); } } 3. 内存分配跟踪 1 2 3 4 5 6 7 8 9 10 // 重写malloc/free来添加边界检查 void* debug_malloc(size_t size) { size_t total_size = size + 2 * sizeof(uint32_t); uint32_t* ptr = malloc(total_size); ptr[0] = MAGIC_NUMBER; // 前哨兵 ptr[(size + sizeof(uint32_t)) / sizeof(uint32_t)] = MAGIC_NUMBER; // 后哨兵 return ptr + 1; // 返回实际数据区域 } 防护措施 🛡️ 编程实践 1. 边界检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 安全的字符串复制 void safe_strcpy(char* dest, const char* src, size_t dest_size) { if (dest_size \u0026gt; 0) { strncpy(dest, src, dest_size - 1); dest[dest_size - 1] = \u0026#39;\\0\u0026#39;; } } // 安全的数组访问 void safe_array_access(int* array, size_t size, size_t index, int value) { if (index \u0026lt; size) { array[index] = value; } else { printf(\u0026#34;数组越界：索引%zu超出范围[0, %zu)\\n\u0026#34;, index, size); } } 2. 使用安全的API 1 2 3 4 5 // 推荐使用的安全函数 strcpy → strncpy 或 strlcpy sprintf → snprintf gets → fgets memcpy → 带长度检查的版本 3. RAII和智能指针（C++） 1 2 3 // 使用智能指针避免手动内存管理 std::unique_ptr\u0026lt;char[]\u0026gt; buffer(new char[size]); std::vector\u0026lt;char\u0026gt; safe_array(size); // 自动边界检查 🔒 系统级防护 1. 栈保护 1 2 # 编译时启用栈保护 gcc -fstack-protector-all -o program program.c 2. ASLR（地址空间布局随机化） 1 2 3 4 5 # 检查ASLR状态 cat /proc/sys/kernel/randomize_va_space # 启用ASLR echo 2 \u0026gt; /proc/sys/kernel/randomize_va_space 3. DEP/NX bit（数据执行保护） 1 2 # 编译时启用 gcc -Wl,-z,noexecstack -o program program.c 🧪 测试策略 1. 模糊测试（Fuzzing） 1 2 3 # 使用AFL进行模糊测试 afl-gcc -o program program.c afl-fuzz -i input_dir -o output_dir ./program 2. 压力测试 1 2 3 4 5 6 7 // 多线程压力测试 void stress_test() { for (int i = 0; i \u0026lt; 1000000; i++) { // 进行大量内存操作 // 观察是否出现内存踩踏 } } 3. 代码审查重点 所有数组访问都有边界检查 指针运算有范围验证 字符串操作使用安全函数 动态内存分配后检查返回值 多线程访问共享数据有同步保护 完整测试代码 📁 文件结构 1 2 3 4 test/ ├── memory_corruption_test.c # 主测试程序 ├── Makefile # 编译脚本 └── 内存踩踏分析报告.md # 本文档 💻 核心测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; // 全局变量用于段错误处理 static jmp_buf segfault_buf; static int segfault_occurred = 0; void segfault_handler(int sig) { segfault_occurred = 1; longjmp(segfault_buf, 1); } // 测试场景：堆内存踩踏 void test_heap_memory_corruption() { printf(\u0026#34;=== 堆内存踩踏测试 ===\\n\u0026#34;); char* heap_A = (char*)malloc(16); char* heap_B = (char*)malloc(16); printf(\u0026#34;heap_A地址: %p\\n\u0026#34;, (void*)heap_A); printf(\u0026#34;heap_B地址: %p\\n\u0026#34;, (void*)heap_B); // A的恶意操作：越界写入 signal(SIGSEGV, segfault_handler); if (setjmp(segfault_buf) == 0) { memset(heap_A, \u0026#39;X\u0026#39;, 32); // 写入32字节，超出16字节分配 printf(\u0026#34;✅ A的越界写入完成，A没有崩溃\\n\u0026#34;); } else { printf(\u0026#34;❌ A越界写入时崩溃\\n\u0026#34;); return; } // B的正常操作：重新分配内存 if (setjmp(segfault_buf) == 0) { heap_B = (char*)realloc(heap_B, 32); printf(\u0026#34;✅ B的内存操作成功\\n\u0026#34;); } else { printf(\u0026#34;💥 B在进行正常内存操作时崩溃！\\n\u0026#34;); } // 清理 if (setjmp(segfault_buf) == 0) { free(heap_A); free(heap_B); printf(\u0026#34;内存清理成功\\n\u0026#34;); } else { printf(\u0026#34;💥 清理内存时崩溃！\\n\u0026#34;); } } int main() { printf(\u0026#34;内存踩踏测试 - A操作B内存但A不崩溃，B访问时崩溃\\n\u0026#34;); printf(\u0026#34;================================================\\n\u0026#34;); test_heap_memory_corruption(); // 其他测试场景... return 0; } 🚀 编译和运行 1 2 3 4 5 6 7 8 9 10 11 12 # 编译 make run-corruption # 或者手动编译 gcc -Wall -Wextra -g -O0 -pthread -o memory_corruption_test memory_corruption_test.c # 运行 ./memory_corruption_test # 使用AddressSanitizer检测 gcc -fsanitize=address -pthread -o memory_corruption_test_asan memory_corruption_test.c ./memory_corruption_test_asan 📊 预期输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 内存踩踏测试 - A操作B内存但A不崩溃，B访问时崩溃 ================================================ === 测试场景1：相邻全局数组内存踩踏 === [结果根据内存布局而定] === 测试场景2：堆内存踩踏 === heap_A地址: 0x55f8a1b0a6b0 heap_B地址: 0x55f8a1b0a6d0 距离: 32 字节 步骤1：A进行越界写入操作... ✅ A的越界写入操作完成，A没有崩溃 步骤2：B进行正常的内存操作... realloc(): invalid old size [程序异常终止 - 证明了我们的假设] 📝 结论 🎯 核心发现 ✅ 确实存在A操作B内存但A不崩溃，B访问时崩溃的情况！\n🔬 技术总结 现象普遍性：这种内存踩踏现象在实际开发中很常见 根本原因：操作系统内存保护的粒度和内存管理的复杂性 危险性：增加了调试难度，容易误导问题定位 可检测性：需要专门的工具和方法才能有效检测 ⚠️ 对你的softbus_server问题的启示 nStackXDFinder线程很可能是受害者，而不是肇事者 真正的问题可能在其他线程的内存操作 函数指针或回调表可能被其他代码踩踏 需要全面检查共享数据结构的完整性 💡 防护建议 启用编译器安全选项 使用内存检测工具 实施防御性编程 加强代码审查 建立内存安全测试流程 这种内存踩踏现象是C/C++程序中最隐蔽和危险的bug类型之一，需要开发者保持高度警惕并采取多层防护措施。\n报告生成时间：2025年9月12日\n测试环境：Linux x86_64, GCC编译器\n","date":"2025-09-12T00:00:00Z","permalink":"https://latteratter-coder.github.io/p/%E5%86%85%E5%AD%98%E8%B8%A9%E8%B8%8F%E7%8E%B0%E8%B1%A1/","title":"内存踩踏现象"},{"content":"加电复位：CPU的\u0026quot;本能\u0026quot; 当按下开机键，CPU获得电力后，其行为由硬件设计预先决定：\n重置寄存器：将所有内部寄存器设置为已知的初始状态。\n进入实模式：x86架构CPU会进入实模式（Real Mode），在此模式下可直接访问最初的1MB内存，无内存保护或权限分级。\n执行第一条指令：CPU的程序计数器（CS:IP寄存器）被硬编码指向内存地址 0xFFFF0。该地址位于主板的BIOS（或现代计算机的UEFI）固件芯片中。\n至此，CPU只是机械地执行硬件设计好的步骤，对\u0026quot;内核\u0026quot;一无所知。\n第一棒：固件（BIOS/UEFI） CPU开始执行固件中的代码，其主要任务是：\n硬件自检（POST）：检查关键硬件（内存、显卡、键盘等）是否正常工作。\n初始化硬件：配置主板芯片组、磁盘控制器等。\n寻找引导程序：\nBIOS：按照预设顺序（如：U盘-\u0026gt;硬盘）读取存储设备的第一个扇区（512字节），即主引导记录（MBR），并将其加载到内存地址 0x7C00 处。\nUEFI：更先进，直接从EFI系统分区中查找并加载扩展性更强的引导程序文件。\n移交控制权：CPU跳转到 0x7C00（或UEFI加载的引导程序地址），开始执行引导程序代码。\n第二棒：引导程序（Bootloader） MBR中的空间很小，通常只存放引导程序的第一阶段。其核心任务是加载功能更全的第二阶段引导程序（如GRUB、Windows Boot Manager）。\n第二阶段引导程序的工作：\n提供菜单：允许用户选择要启动的操作系统（如果有多个）。\n识别文件系统：具备解析磁盘文件系统（如EXT4, NTFS）的能力，而不仅仅是读写原始扇区。\n加载内核映像：根据配置，从文件系统中找到内核文件（如Linux的 /boot/vmlinuz-xxx），并将其读取到内存中合适的位置。\n准备内核运行环境：设置启动参数（如根文件系统位置、分辨率）。\n切换CPU模式：将CPU从实模式切换到现代的保护模式（Protected Mode） 或 长模式（Long Mode, 64位），以启用虚拟内存、权限保护等关键特性。\n跳转到内核：最后，引导程序跳转（jump） 到内核在内存中的入口地址，将控制权彻底交给内核。\n引导程序是内核的\u0026quot;引路人\u0026quot;，完成了从\u0026quot;找扇区\u0026quot;到\u0026quot;找文件\u0026quot;的关键跨越。\n第三棒：内核启动与初始化 内核启动是一个复杂的过程，可分为两个主要阶段：\n第一阶段：架构相关初始化（汇编） 这是内核最先执行的代码，直接与CPU硬件交互，通常用汇编语言编写：\n设置初始堆栈\n清除BSS段：将未初始化的全局变量区域清零。\n解压内核（如果需要）：许多发行版的内核映像是压缩过的（如vmlinuz），此阶段会进行自解压。\n启用分页（Paging）：建立初始页表，开启MMU（内存管理单元），让CPU使用虚拟内存地址。这是现代操作系统的基石。\n设置中断描述符表（IDT）：为处理硬件中断、异常和系统调用做好准备。\n跳转到主入口点：最终跳转到如 start_kernel() 这样的C语言函数，进入内核主体。\n第二阶段：通用内核初始化（C语言） start_kernel() 是内核初始化的\u0026quot;主函数\u0026quot;，它调用一系列初始化函数来构建整个操作系统：\nsched_init(): 初始化调度器，创建0号进程（idle进程）。\nmm_init(): 初始化内存管理系统（伙伴系统、slab分配器）。\ntrap_init() / init_IRQ(): 完善中断和异常处理机制。\ntime_init(): 初始化系统时钟，内核开始感知时间。\nvfs_caches_init(): 初始化虚拟文件系统（VFS），为挂载根文件系统做准备。\n挂载根文件系统：可能先挂载内存中的initramfs（临时根文件系统）来加载必要驱动，再挂载真正的根文件系统。\n启动第一个用户空间进程：这是内核初始化的最后一步。内核线程会尝试执行用户空间的 /sbin/init（或其链接，如 /lib/systemd/systemd）。这个进程成为所有用户进程的祖先（PID 1）。\n一旦 /sbin/init 被执行，内核的启动过程就正式结束，控制权交给了用户空间。\n内核启动后，它是后台运行吗？ 答案是：否。内核不是一个在\u0026quot;后台\u0026quot;运行的进程。\n这是一个关键区别。内核的运行方式与普通程序（前台或后台）有本质不同：\n内核是：\n常驻内存的代码和数据：内核始终驻留在物理内存的受保护区域（内核空间）。\n被动的执行环境和服务提供者：内核自身不会主动持续运行。它的代码在以下三种情况下被被动调用：\n系统调用（Syscall）：应用程序主动请求操作系统服务（如读写文件），通过指令（如syscall）陷入内核。\n硬件中断（Interrupt）：硬件设备需要CPU关注（如网卡收到数据、时钟滴答），触发CPU执行对应的中断处理程序。\n异常（Exception）：CPU执行指令时发生错误（如除零），由内核的异常处理程序处理。\n所有进程的\u0026quot;底层\u0026quot;：每个用户进程都像是在内核这个\u0026quot;地基\u0026quot;上建立的\u0026quot;房子\u0026quot;。当需要执行特权操作时，进程就\u0026quot;陷入\u0026quot;地基（内核）中寻求帮助。\n特征 用户进程（前台/后台） 内核 运行方式 主动执行自己的代码流 被动响应（系统调用、中断、异常） 存在形式 进程列表中的一个实体 常驻内存的代码和数据结构，是进程运行的环境 CPU模式 用户态 内核态（当被调用时） 如何结束 调用exit()或被杀掉 永不结束，直到计算机关机 总结与类比 计算机启动过程就像一场精心设计的接力赛：\nCPU：是运动员，只有跑步的本能。\nBIOS/UEFI：是第一棒教练（接生婆），确保运动员健康并把他交给下一棒。\n引导程序（GRUB等）：是第二棒领跑员（家庭教师），带领运动员到正确的位置并交棒。\n内核：是第三棒运动员兼体育场建筑师（大学），它接管比赛，并首先建造整个体育场（初始化系统），然后制定规则（系统调用），裁判比赛（调度进程）。\ninit / systemd：是赛后活动组织者，根据规则启动各种游戏和服务（用户进程）。\n内核并非后台守护进程，而是系统的基石。它静默地存在于内存中，等待被应用程序和硬件事件调用，从而为所有程序提供安全、可靠、统一的硬件访问和管理服务。\n","date":"2025-09-06T00:00:00Z","permalink":"https://latteratter-coder.github.io/p/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","title":"Linux内核启动流程"},{"content":"内核管理进程的核心可以概括为：“一抽象，两分离，四管理”。\n一抽象：将运行中的程序抽象为进程（Process）。\n两分离：实现CPU虚拟化（分时复用）和内存虚拟化（每个进程有独立的地址空间）。\n四管理：通过进程描述符（PCB）、进程调度、内存管理和进程间通信（IPC） 这四大机制来具体实现管理。\n下面我们详细展开。\n1. 进程的抽象：进程描述符（PCB） 内核要管理进程，首先必须能描述一个进程。内核通过一个称为进程控制块（PCB, Process Control Block） 的数据结构来代表一个进程。在Linux中，这就是 task_struct 结构体（非常庞大，包含上百个字段）。\n这个结构体是内核管理进程的核心，它就像一个进程的“户口本”或“病历”，记录了关于该进程的一切信息，主要包括：\n进程标识符（PID）：唯一的身份证，用于区分不同进程。\n进程状态：运行、就绪、睡眠、僵尸状态等。\n程序计数器（PC）：记录下一条要执行的指令地址。\nCPU寄存器：当进程被切换时，需要保存当前的寄存器状态，以便下次恢复。\n内存管理信息：指向页表（Page Table）的指针，这是实现虚拟内存的关键。\n文件描述符表：记录该进程打开了哪些文件。\n资源使用信息：CPU时间、内存使用量等。\n优先级：用于调度器决定谁先运行。\n进程间关系：父进程、子进程、兄弟进程等信息。\n内核将所有进程的PCB通过链表或树等数据结构组织起来。因此，管理进程在很大程度上就是管理这些 task_struct 结构体。\n2. 进程的生命周期管理（状态机） 进程并非从生到死都在运行。内核为其定义了一系列状态（State），形成一个状态机：\n就绪（Ready）：进程已准备好，只等调度器分配CPU即可运行。\n运行（Running）：进程正在CPU上执行。\n阻塞/睡眠（Blocked/Sleeping）：进程在等待某个事件（如等待用户输入、等待磁盘IO完成），此时它不需要CPU。\n僵尸（Zombie）：进程已终止，但其PCB还未被父进程回收。\n终止（Terminated）：进程结束，所有资源被回收。\n内核负责根据事件（如IO完成、时间片用完）来驱动进程在这些状态间转换。\n3. CPU虚拟化：进程调度（Scheduling） CPU核心数远少于进程数，内核通过调度器（Scheduler） 来制造“每个进程都在同时运行”的假象，即分时复用。\n调度器的工作流程：\n选择：从就绪队列中，根据特定的调度算法（如CFS-完全公平调度器）选择一个最值得运行的进程。\n切换：\n上下文切换（Context Switch）：将当前运行进程的状态（寄存器、PC等）保存到其PCB中。\n加载：将下一个要运行进程的状态从其PCB中加载到CPU寄存器中。\n切换页表，从而切换内存地址空间。\n执行：CPU开始执行新进程的代码。\n触发调度的时机：\n主动让出：进程执行系统调用（如sleep, read等待IO）或主动yield。\n被动抢占：硬件时钟中断发生，调度器检查当前进程的时间片是否用完，如果用完则强制切换。\n通过频繁的调度和上下文切换，内核实现了多个进程在CPU上的“同时”运行。\n4. 内存虚拟化：内存管理（Memory Management） 每个进程都认为自己独享整个内存空间。这是内核通过虚拟内存机制实现的魔法。\n内核为每个进程维护一张独立的页表（Page Table）：\n页表定义了虚拟地址到物理地址的映射关系。\nMMU（内存管理单元）在CPU执行指令时，通过查询当前进程的页表来自动完成地址转换。\n这样做的好处：\n隔离性与保护：进程A无法访问进程B的内存，因为它们的虚拟地址映射到不同的物理页。一个进程的崩溃不会影响整个系统。\n简化编程：程序员只需关心统一的虚拟地址空间，无需关心物理内存的具体布局。\n内核的内存管理子系统负责分配和回收物理内存页，并在进程切换时负责切换页表基地址寄存器（如x86的CR3）。\n5. 进程间通信（IPC, Inter-Process Communication） 进程之间需要协作，但由于内存隔离，它们不能直接访问对方的地址空间。内核提供了多种进程间通信（IPC） 机制来安全地传递数据：\n管道（Pipe）：单向字节流，常用于父子进程。\n消息队列（Message Queue）：内核维护的消息链表。\n共享内存（Shared Memory）：效率最高的方式。内核将同一块物理内存映射到多个进程的虚拟地址空间中。\n信号（Signal）：一种异步通知机制，用于通知进程某个事件已发生（如kill命令）。\n信号量（Semaphore） 和 互斥锁（Mutex）：用于同步对共享资源的访问，防止竞争条件。\n所有这些机制都由内核提供和管理，确保了通信的安全性和可靠性。\n6. 系统调用：进程与内核的接口 用户进程运行在用户态，权限受限。当它需要请求内核的服务（如创建进程、读写文件、申请内存）时，必须通过系统调用（System Call）。\n系统调用是用户进程主动陷入内核的唯一方式。过程如下：\n进程在寄存器中设置好系统调用号和参数。\n执行一条特殊的指令（如syscall或int 0x80），触发软中断。\nCPU切换到内核态，跳转到内核中预先定义好的系统调用处理函数。\n内核验证请求合法性后，代表进程执行所需操作。\n操作完成，内核将结果返回给进程，并切换回用户态。\n创建新进程的fork()和加载新程序的execve()，本身就是两个最重要的系统调用。\n总结：内核如何管理进程 内核通过一个精巧的体系来管理进程：\n用PCB描述进程：为每个进程创建一个task_struct作为管理元数据。\n用状态机管理生命周期：跟踪每个进程处于创建、就绪、运行、阻塞、退出等状态。\n用调度器分配CPU：通过上下文切换和分时复用，实现CPU的虚拟化。\n用页表隔离内存：为每个进程提供独立的虚拟地址空间，实现内存的虚拟化和保护。\n用IPC机制 Facilitate 协作：提供管道、共享内存等机制，让隔离的进程能安全通信。\n用系统调用提供接口：作为用户进程请求内核服务的唯一入口，保证安全和可控。\n最终，内核像一位交响乐指挥家，协调着各个进程（乐手），合理分配硬件资源（乐器），让整个系统（乐团）和谐、高效地运行。\n","date":"2025-09-06T00:00:00Z","permalink":"https://latteratter-coder.github.io/p/%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E7%9A%84/","title":"内核是如何管理进程的"},{"content":"总体概览 加载并执行一个新程序的过程可以概括为以下几步：\n外壳（Shell）解析命令并准备参数。\nfork()：创建一个新的子进程。这个子进程几乎是父进程（如 Shell）的完美复制品。\nexecve()：在子进程上下文中执行“程序替换”。这是魔法发生的地方：内核停止当前子进程的运行，清空其内存空间（除了一些保留信息），然后将指定的可执行文件加载到该内存空间中，并为其设置全新的运行环境。\n动态链接器（如果必要）介入，加载程序所依赖的共享库。\n程序开始执行，从 main() 函数开始。\n整个过程的核心是 execve() 系统调用。下图描绘了这个过程的完整流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 flowchart TD A[用户在Shell中输入命令] --\u0026gt; B[\u0026#34;Shell解析命令调用fork()创建子进程\u0026#34;] B --\u0026gt; C[子进程调用execve系统调用] C --\u0026gt; D[\u0026#34;内核处理execve()请求\u0026#34;] subgraph D[内核处理流程] D1[验证文件权限格式等] --\u0026gt; D2[释放旧地址空间\u0026lt;br\u0026gt;拆毁旧世界] D2 --\u0026gt; D3[加载可执行文件\u0026lt;br\u0026gt;ELF解析映射文本/数据段等] D3 --\u0026gt; D4[\u0026#34;设置新堆栈\u0026lt;br\u0026gt;填充参数argv、环境变量envp\u0026#34;] D4 --\u0026gt; D5[设置寄存器\u0026lt;br\u0026gt;将eip指向入口点] end D --\u0026gt; E{\u0026#34;是否为动态链接程序?\u0026#34;} E -- 是 --\u0026gt; F[\u0026#34;载入解释器(ld-linux)\u0026#34;\u0026lt;br\u0026gt;由解释器加载所需共享库] E -- 否 --\u0026gt; G[跳转到程序入口点_start] F --\u0026gt; G G --\u0026gt; H[\u0026#34;执行用户程序的main()函数\u0026#34;] H --\u0026gt; I[程序正常执行] 详细过程分析 第1步：Shell 的工作（用户空间） 当你在 Shell 中输入 ./my_program arg1 arg2 后：\nShell 解析命令，将 \u0026quot;my_program\u0026quot;, \u0026quot;arg1\u0026quot;, \u0026quot;arg2\u0026quot; 分别存储起来。\nShell 调用 fork() 系统调用，创建一个几乎是自身副本的子进程。\n第2步：fork() - 创建进程胚子（内核空间） fork() 系统调用被执行，CPU 陷入内核。\n内核创建一个新的进程描述符（task_struct），为其分配一个新的 PID。\n内核复制父进程的几乎所有资源给子进程，包括：\n内存空间：通过写时复制（Copy-on-Write, COW）技术，创建一个当前和父进程完全一样的地址空间映射（但实际物理内存页暂时共享）。\n打开的文件描述符表：子进程也继承了父进程打开的文件（stdin, stdout, stderr等）。\n进程上下文（寄存器状态等）。\n现在，系统中有了两个几乎一样的进程：父进程（Shell）和子进程。它们都从 fork() 返回开始执行。fork() 对父进程返回子进程的 PID，对子进程返回 0。代码可以通过返回值判断自己是父是子。\n第3步：execve() - 魔法核心（从用户空间到内核空间） 在子进程中，Shell 的子进程副本会调用 execve() 系统调用，其原型大致如下：\nint execve(const char *filename, char *const argv[], char *const envp[]);\nfilename：要加载的程序路径（\u0026quot;/home/user/my_program\u0026quot;）。\nargv：参数数组（{\u0026quot;my_program\u0026quot;, \u0026quot;arg1\u0026quot;, \u0026quot;arg2\u0026quot;, NULL}）。\nenvp：环境变量数组。\n一旦调用 execve()，内核就开始执行以下繁重的工作：\na. 验证与准备\n检查文件 filename 是否存在、是否具有可执行权限。\n读取文件的头部（Header），识别其格式（例如 ELF、Mach-O、PE）。\nb. “拆毁旧世界” - 释放旧地址空间\n内核释放子进程当前拥有的几乎所有资源（内存、信号处理函数等）。由于之前用的是写时复制，所以实际复制的物理内存页很少，释放代价低。\n注意：这里会处理一些例外，比如明确设置为“执行时关闭”（close-on-exec）的文件描述符会被保留，这是进程间通信的重要手段。\nc. “建立新世界” - 加载新程序\n解析可执行文件：以最常见的 ELF 格式为例，内核会解析程序头表（Program Header Table），找到需要加载的段（Segment），如：\n.text 段（代码段）：映射到内存的只读可执行区域。\n.data 段（已初始化数据）：映射到内存的可读写区域。\n.bss 段（未初始化数据）：映射到初始为零的可读写区域。\n映射到内存：内核并不急于将文件内容全部读入物理内存，而是基于内存映射（mmap） 机制，建立虚拟地址到文件偏移的映射关系。只有当程序实际访问某块内存时，才会通过缺页中断（Page Fault） 将对应的文件内容加载到物理内存。这是懒加载（Lazy Loading），非常高效。\n加载解释器（动态链接器）：如果程序是动态链接的（绝大多数都是），ELF 文件中会指定一个“解释器”（Interpreter），通常是 /lib64/ld-linux-x86-64.so.2。内核会先将这个动态链接器本身加载到进程的地址空间并映射。\nd. 设置新堆栈和寄存器\n设置新堆栈：内核为进程分配新的用户态堆栈，并将 argv 和 envp 中的参数和环境变量字符串压入（或放置到）堆栈的特定位置。\n设置寄存器：在进程的内核栈中准备一个新的上下文环境。最关键的是：\n将 指令指针（EIP/RIP） 设置为新程序的入口点（Entry Point）。对于静态链接的程序，入口点就是程序本身的 _start。对于动态链接的程序，入口点是动态链接器的入口点。\n将 栈指针（ESP/RSP） 指向新设置的用户堆栈的顶部。\n第4步：返回用户空间，开始执行 当 execve() 系统调用在内核中完成所有准备工作后：\n内核将精心准备的新上下文恢复到 CPU 寄存器。\nCPU 切换回用户态。\n根据设置好的指令指针（EIP/RIP），开始执行代码。\n现在有两种情况：\n情况A：程序是静态链接的\nCPU 直接从程序的 _start 符号开始执行。_start 是程序真正的起点，由它来初始化运行环境，最后调用 main() 函数。 情况B：程序是动态链接的（绝大多数）\nCPU 首先跳转到动态链接器（ld.so） 的入口点。\n动态链接器开始工作：\n它检查程序依赖哪些共享库（如 libc.so.6）。\n通过 mmap() 将这些共享库也加载到进程的地址空间。\n执行重定位（Relocation） 操作，修正程序中所有对共享库函数（如 printf）的引用地址（将占位符替换为实际加载的地址）。\n执行共享库的初始化代码。\n最后，动态链接器跳转到原始程序的 _start 入口点。\n第5步：执行 main() 函数 无论是否经过动态链接，最终控制权都会交到程序本身的 _start 函数。这个函数是由编译器提供的，它负责：\n设置全局变量。\n初始化标准库。\n将 argv 和 argc 从堆栈中取出，准备好参数。\n调用用户编写的 main(int argc, char *argv[]) 函数。\n至此，你的 main 函数终于被调用，程序开始执行你写的代码。\n总结 步骤 关键动作 执行者 1. Shell解析 解析命令，获取参数 Shell (用户态) 2. fork() 创建子进程副本 内核 3. execve() 系统调用，陷入内核 子进程 -\u0026gt; 内核 4. 内核处理 验证文件、释放旧空间、映射新程序、设置堆栈和寄存器 内核 5. 动态链接 加载并链接共享库 动态链接器 ld.so (用户态) 6. 程序启动 运行 _start，调用 main() 用户程序 所以，main 函数的加载和执行是内核与动态链接器（如果需要）协同工作的结果，是一个“先破后立”的过程：先通过 execve() 清空当前进程的环境，再为其注入一个全新的程序生命。\n","date":"2025-09-06T00:00:00Z","permalink":"https://latteratter-coder.github.io/p/%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%96%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B/","title":"加载一个新程序的过程"},{"content":"一、股票类型相关名词 • A股：人民币普通股票，境内公司发行，境内投资者以人民币交易。实行“T+1”交易和涨跌幅限制。\n• B股：人民币面值、外币交易，在上交所或深交所上市的外资股。交收周期较长（历史上多为T+3），有涨跌幅限制。\n• H股：内地注册公司在香港联合交易所上市的股票（常称国企股）。“T+0”交易，无涨跌幅限制。\n• N股：在中国大陆注册、于纽约交易所或纳斯达克上市的外资股。“T+0”交易，无涨跌幅限制。\n• S股：主要业务在中国大陆、在新加坡交易所上市的中资背景公司股票。“T+0”交易，交易所设有涨跌幅限制。\n• 普通股：享有表决权、分红权、剩余财产分配权，股息不固定。\n• 优先股：分红优先、清算优先，通常无或有限表决权，股息率相对固定。\n• 原始股：公司上市前发行给核心管理层、员工或机构的股份。\n• 蓝筹股：业绩稳健、规模较大、分红稳定的龙头型公司股票。\n• 红筹股：境外注册、在港上市，由中资机构实际控制的公司股票。\n• 白马股：长期业绩优良、成长性较明确、风险相对较低的股票。\n• 龙头股：行业内具有显著带动效应、对板块走势有示范作用的股票。\n• 绩优股：历史业绩优秀、未来预期稳健但高成长性有限的股票。\n• 垃圾股：基本面差、风险较高的公司股票。\n• 成长股：处于高成长阶段、利润增速较高的公司股票。\n• 冷门股：成交量小、流动性弱、价格波动较小的股票。\n• 概念股：受某一政策或热点概念驱动而被市场关注的股票。\n• 行业股：按照主营业务划分在同一行业板块内的股票。\n二、投资市场相关名词 • 一级市场：证券发行市场，进行新股发行与认购，不允许自由交易。\n• 二级市场：已发行证券的流通转让市场，包括上交所、深交所、北交所等集中交易市场与场外市场。\n• 第三市场：由非交易所会员在场外交易所上市证券的市场（如银行信托部等参与）。\n• 第四市场：机构或大户绕开交易所与经纪商，直接通过网络撮合交易的市场。\n• 北向资金：通过沪/深股通流入A股的港资与外资。\n• 南下资金：内地资金通过港股通流入香港市场的资金。\n• 熊市（空头）：价格长期下行、预期偏悲观的市场环境。\n• 牛市（多头）：价格长期上行、预期偏乐观的市场环境。\n• 牛皮市：价格长时间窄幅波动，缺乏趋势。\n• 利多/利空：分别指有利于上涨/下跌的因素或消息。\n三、股票分析相关名词与指标 • 基本面：宏观环境与公司经营、财务、治理、竞争力等基本情况。\n• 技术面：价格与量能衍生的形态、趋势与技术指标。\n• 天地板：盘中先涨停后跌停。\n• 地天板：盘中先跌停后涨停。\n• 涨停/跌停：当日价格波动的最高/最低限制价。\n• 换手率：一定期间成交量占流通股本比例。公式：换手率＝成交量／流通股本×100%。\n• 筹码集中度：流通筹码在部分账户或价位区间的集中程度。\n• 市盈率（PE）：股价/每股净利润；较低通常意味着估值较低（需结合行业）。\n• 市净率（PB）：股价/每股净资产；常用于金融、周期品等估值参考。\n• 市销率（PS）：股价/每股销售收入；适用于早期、高成长或亏损公司比较。\n• 股息率：每股股息/股价；衡量分红回报。\n• 每股收益（EPS）：净利润/总股本。\n• 估值扩展指标：PEG（PE/利润增速）、EV/EBITDA 等。\n• K线：由开盘、收盘、最高、最低构成，反映区间价格波动。\n• 均线（MA）：一定期间收盘价的移动平均，如5/10/20/60/120/250日。\n• MACD：由DIF、DEA、柱状图与零轴构成，反映趋势强弱与拐点。\n• KDJ：反映超买超卖与短期拐点。\n• OBV：将成交量方向与价格变动结合，观察量价配合。\n• BIAS：价格相对均线的偏离程度。\n• RSI：一定期间上涨幅度占总波动幅度的比例。\n• BRAR：BR重收盘价，AR重开盘价，反映市场人气与意愿。\n• BOLL（布林带）：以上轨/中轨/下轨刻画波动区间（常以20日均线与标准差计算）。\n• 内盘/外盘：分别为以买一价成交的被动卖出量/以卖一价成交的主动买入量。\n• 缩量/放量：与前期相比，成交量减少为“缩量”，增加为“放量”。\n四、交易基础与竞价机制 • 交易时间（A股）：\n9:15–9:25 开盘集合竞价（9:20–9:25不可撤单） 9:30–11:30、13:00–15:00 连续竞价 14:57–15:00 收盘集合竞价（主板/科创/创业板） • 竞价规则：\n集合竞价：以最大成交量原则确定开/收盘价；未成交部分转入连续竞价。 连续竞价：价格优先、时间优先撮合成交。 • 涨跌幅限制（以交易所最新规定为准）：\n主板：一般为±10%；ST类股票一般为±5%。 创业板/科创板：一般为±20%。 新股上市前5个交易日通常不设涨跌幅限制（设有盘中临停机制）。 • T+1/T+0：\nA股股票一般“T+1”卖出；资金与交收“T+1/ T+2”结算。 港股、美股多为“T+0”回转交易。 • 临时停牌（盘中）：\n因异常波动、重大事项、或新股上市盘中价格稳定机制触发而临停。 • 盘后交易：\n15:00–15:30 盘后固定价格交易（部分板块适用）。 十、委托与订单类型 • 限价委托：指定价格或更优价格成交，未成交部分挂单等待。\n• 市价委托（A股常见变种）：\n最优五档即时成交剩余撤销（FOK局部变体）：与对手方前五档即时成交，剩余撤单。 最优五档即时成交剩余转限价（IOC转限价）：即时成交后，剩余部分以成交均价或对手价挂为限价单。 本方最优价格：以本方队列最优价申报，提高成交概率。 对手方最优价格：以对手方队列最优价申报，追求即时成交。 注：具体可用的市价类型以交易所与券商支持为准。 • 有效期：A股场内委托为当日有效，收盘未成交自动失效；不支持GTC（长期有效）。\n十一、申报单位与价格最小变动 • 价格最小变动价位（Tick）：多数股票为0.01元；北交所、可转债等以交易所规则为准。\n• 申报数量单位：\n股票：一般以“手”为单位，1手=100股。 可转债：1手=10张（面值通常100元/张）。 ETF：多为1手=100份，部分货币ETF可能不同。 • 零股交易：\n卖出可出现“非整手”（如剩余不足100股），允许一次性卖出；买入通常需整手。 盘后固定价格交易与北交所等对零股规则可能不同，以最新规定为准。 十二、撤单、订单状态与撮合优先级 • 撤单规则：\n开盘集合竞价：9:15–9:20可撤，9:20–9:25不可撤。 连续竞价：委托未成交可随时撤单（不含临停等特殊时段）。 收盘集合竞价：14:57–15:00一般不可撤单。 • 常见订单状态：已报、部成、全成、已撤、废单（价格/数量无效、账户限制等）。\n• 撮合优先级：价格优先、时间优先；同价位按排队时间先后成交。\n十三、资金可用与结算时间线 • 卖出回款：\n当日卖出后，资金通常“可用不可取”；次日结算后可取（以券商资金规则为准）。 • 买入与卖出：\n买入后当日不得卖出（T+1）；可转债、部分基金等品种可能为T+0，以规则为准。 • 分红派息与配股缴款：资金及股份到位时间以公告与结算机构安排为准。\n十四、融资融券基础 • 定义：\n融资：向券商借钱买入标的证券，负债计息。 融券：借入标的证券卖出（做空），到期需买券归还并支付费用。 • 标的与门槛：需开通信用账户、风险评估达标，标的证券由交易所定期调整。\n• 风险要点：\n保证金比例与维持担保比例，低于维保线可能被平仓。 利息与费率成本、价格波动与流动性风险。 十五、盘后交易与大宗交易补充 • 盘后固定价格交易：\n15:00–15:30 以当日收盘价撮合；仅限限价委托，部分板块或证券支持。 • 大宗交易（Block Trade）：\n适用于大额交易，场外协议达成、场内申报过户，价格区间与最小成交数量有规定。 对二级市场即时价格影响较小，但可能传递供需与机构动向信息。 十六、IPO申购与配售基础 • 申购条件：\n需持有相应市值（以T-2日账户持有为准），不同板块市值门槛不同。 • 申购流程：\n公告日查看代码与申购上限 → 申购日按代码与数量下单 → 中签公布后按时缴款。 • 配售与中签：\n采取摇号/配号机制，按市值获得配号，中签概率与市值、发行规模等相关。 • 上市首日：\n前5个交易日通常不设涨跌幅限制（有临停），注意流动性与波动风险。 五、账户与常见投资品种 • 账户类型：\n普通账户：交易沪深主板、北交所等。 信用账户：融资融券（需风险评估与权限开通）。 科创板与创业板权限：满足条件后单独开通。 港股通权限：满足资产条件后开通。 • 常见品种：\nETF/LOF：场内基金（ETF）与可场内外申赎/交易的基金（LOF）。 封闭式基金、指数基金、主动型基金。 可转债：债券与期权性兼具，可按约定条件转换为股票。 新股申购：满足条件可按市值申购，配售中签后缴款。 优先股、存托凭证（CDR）、公募REITs（不动产投资信托）。 六、公司行为与除权除息 • 常见公司行为：分红、送股、转增、配股、并购重组、股份回购等。\n• 除权/除息：\n除息：派发现金股利后股价相应向下调整。 除权：送股或转增后因股本扩大，股价相应按比例下调。 • 简化计算：\n现金分红后参考价 ≈ 除权前收盘价 − 每股现金分红。 送/转增后参考价 ≈ 除权前收盘价 ÷（1 + 送转比例）。 实际以交易所与登记结算机构披露为准。 七、费用、税费与结算 • 佣金：按成交金额的一定比例收取，券商间差异较大（设有最低收费）。\n• 过户费：沪市股票按成交金额一定比例收取；深市股票目前多不收（以最新规则为准）。\n• 交易经手费与监管费：按交易所/监管机构标准收取。\n• 印花税：卖出股票单边征收，税率以最新国家规定为准。\n• 结算：A股采用中国结算的集中登记与资金证券交收体系，通常T+1/T+2完成清算交收。\n八、交易术语补充 • 筹码：投资者持有的股票数量。\n• 吸筹/建仓：资金在某价位区间持续买入、建立头寸。\n• 洗盘：通过短期打压或震荡清洗不稳定持仓。\n• 出货：在高位或利好刺激下分批卖出实现收益。\n• 护盘：为稳定价格进行买入维稳的行为。\n• 崩盘/跳水：短时间内价格快速大幅下跌。\n• 高开/低开/平开：当日开盘价高于/低于/等于昨日收盘价。\n• 套牢：买入后价格持续下跌而暂时亏损无法卖出的状态。\n• 盘整：价格在一定区间内横向波动。\n九、股票字母标识与特别标记 • N：新股上市首日加“N”，次日取消。\n• C：上市第2–5日标注“C”，第6日取消。\n• R：可融资融券。\n• kr：科创板可融资融券（k=科创，r=融资融券）。\n• U：科创板尚未盈利企业；首次实现盈利后取消。\n• W：同股不同权（表决权差异安排）；不再适用时取消。\n• V：协议控制架构（VIE等）或类似特殊安排；不再适用时取消。\n• G：指数贡献度视图入口（“贡”）。\n• L：存在关联品种（B股、可转债、H股、权证等）。\n• XR：已除权，买入后不再享有送股/转增等权利。\n• XD：已除息，买入后不再享有当期派息权利。\n• DR：除权除息，买入后不再享有送股与派息权利。\n• ST：连续两个会计年度亏损等特殊情形的特别处理。\n• *ST：存在退市风险的特别处理与警示。\n• PT：已退市或进入退市整理阶段的股票。\n• NST：重组或股改后恢复上市的ST股。\n• SZ/SH/BJ：分别代表深交所/上交所/北交所上市。\n——\n","date":"2025-09-04T22:55:17+08:00","permalink":"https://latteratter-coder.github.io/p/%E9%9B%86%E4%B8%AD%E7%AB%9E%E4%BB%B7%E4%B8%8E%E8%BF%9E%E7%BB%AD%E7%AB%9E%E4%BB%B7/","title":"集中竞价与连续竞价"},{"content":"核心比喻 集中竞价：像 \u0026ldquo;集体投票，一锤定音\u0026rdquo;。大家先各自出价，但都不交易，等到一个特定时刻，系统找一个能让最多交易成交的价格，统一按这个价格成交。\n连续竞价：像 \u0026ldquo;自由市场，随到随谈\u0026rdquo;。买卖双方你挂一个买单，我挂一个卖单，价格合适就立刻成交，交易是连续不断进行的。\n一、集中竞价 集中竞价发生在两个特定的时间段，其目的是为了产生一个公平的、能反映市场集中意愿的开盘价或收盘价。\n1. 发生时间：\n开盘集合竞价：每个交易日的 9:15 - 9:25\n收盘集合竞价：每个交易日的 14:57 - 15:00 （注意：目前仅深圳证券交易所、创业板、科创板采用，上海证券交易所的收盘价是最后一笔连续竞价的成交价）\n2. 核心规则与过程：\n收集申报：在以上时间段内，投资者可以提交或撤销买卖委托（但9:20-9:25之间只能提交，不能撤销）。\n不立即成交：在此期间，所有的报单只会被系统收集，并不会真正成交。\n集中撮合：在时间点结束时（9:25或15:00），交易系统的电脑主机将所有有效的买卖申报一次性集中撮合。\n成交价确定原则：这个\u0026quot;唯一价格\u0026quot;必须同时满足以下三个条件（优先级从高到低）：\n最大成交量原则：在这个价格下，所能成交的股票数量最多。\n高于该价格的所有买盘和低于该价格的所有卖盘都能全部成交。\n与该价格相同的买卖双方中有一方申报全部成交。\n3. 举个例子（开盘集合竞价）：\n假设某股票前收盘价为10.00元。在9:15-9:25期间，大家纷纷挂单：\n有人愿以10.10元买入500手\n有人愿以10.05元买入800手\n有人愿以10.00元买入1000手\n有人愿以10.00元卖出600手\n有人愿以10.05元卖出700手\n有人愿以10.10元卖出900手\n系统会尝试10.10元、10.05元、10.00元等多个价格，计算在每个价格下能成交多少手。最终发现，在10.05元这个价格时，能实现的成交量最大（例如800手）。那么，10.05元就被确定为当日的开盘价。所有符合条件（买单价≥10.05元，卖单价≤10.05元）的委托单都按10.05元成交。\n4. 特点总结：\n价格唯一：形成一个统一的价格（开盘价/收盘价）。\n时间驱动：到点了才统一处理。\n防止操纵：收盘集合竞价能有效防止在收盘最后一刻通过大幅拉抬或打压股价来操纵收盘价的行为。\n二、连续竞价 连续竞价是交易日中最主要的交易方式，我们平时看盘时的实时价格波动就是在连续竞价中产生的。\n1. 发生时间：\n早市：9:30 - 11:30 （开盘集合竞价结束后立即开始）\n午市：13:00 - 14:57 （对于有收盘集合竞价的深市等）\n2. 核心规则：\n价格优先：较高的买进申报优先于较低的买进申报；较低的卖出申报优先于较高的卖出申报。\n时间优先：同价位的申报，谁先提交订单（挂单早），谁就优先成交。\n3. 成交过程：\n新进入的买单会与卖单队列中价格最低的卖单（卖一）比较。\n新进入的卖单会与买单队列中价格最高的买单（买一）比较。\n只要报单价格匹配（买价 ≥ 卖价），就立即成交。\n4. 举个例子：\n假设某股票实时五档行情为：\n卖五 \u0026hellip; 10.10\n卖四 \u0026hellip; 10.09\n","date":"2025-09-04T22:55:17+08:00","permalink":"https://latteratter-coder.github.io/p/%E9%9B%86%E4%B8%AD%E7%AB%9E%E4%BB%B7%E4%B8%8E%E8%BF%9E%E7%BB%AD%E7%AB%9E%E4%BB%B7/","title":"集中竞价与连续竞价"}]