[{"content":"全局数组越界访问行为分析报告 📋 目录 问题背景 测试环境 测试设计 实验结果 深入分析 安全性讨论 最佳实践建议 附录 问题背景 在C语言编程中，数组越界访问是一个常见且危险的问题。本报告专门研究以下场景：\n研究问题：在同一个进程中定义两个全局字符数组A、B（大小均为10），当数组A直接访问第12位（A[12]）时，程序是否会崩溃？能否正常访问？\n这个问题涉及到：\n全局变量的内存布局 操作系统的内存保护机制 编译器的内存对齐策略 未定义行为的实际表现 测试环境 项目 详情 操作系统 Linux 5.15.0-138-generic (Ubuntu) 架构 x86_64 编译器 GCC (GNU Compiler Collection) 编译选项 -Wall -Wextra -g -O0 测试工具 AddressSanitizer, Valgrind, objdump 测试设计 测试程序结构 1 2 3 4 5 6 7 8 9 10 11 // 全局数组定义 char A[10]; // 数组A，大小10字节 char B[10]; // 数组B，大小10字节 // 测试内容 1. 内存布局分析 2. 正常范围访问测试 3. 越界读取测试 (A[10] ~ A[15]) 4. 越界写入测试 (A[10] ~ A[12]) 5. 大范围越界测试 (A[10] ~ A[100]) 6. 段错误捕获机制 测试方法 基础测试：使用标准编译选项进行测试 内存检测：使用AddressSanitizer检测内存错误 符号分析：使用objdump分析内存布局 异常处理：实现信号处理机制捕获段错误 实验结果 🎯 核心结论 A[12] 不会崩溃，可以正常访问！\nA数组可以直接改写B数组的内容！\n详细测试数据 1. 内存布局分析 1 2 3 4 5 6 === 数组信息 === 数组A地址: 0x564e0133f120 数组B地址: 0x564e0133f110 数组A大小: 10 字节 数组B大小: 10 字节 A和B之间的距离: -16 字节 符号表信息（通过objdump获取）：\n1 2 0000000000004110 g O .bss 000000000000000a B 0000000000004120 g O .bss 000000000000000a A 2. 越界访问测试结果 访问位置 读取结果 写入结果 是否崩溃 A[10] ✅ 成功 ✅ 成功 ❌ 无崩溃 A[11] ✅ 成功 ✅ 成功 ❌ 无崩溃 A[12] ✅ 成功 ✅ 成功 ❌ 无崩溃 A[13-15] ✅ 成功 - ❌ 无崩溃 A[20-100] ✅ 成功 - ❌ 无崩溃 4. 新增：A数组改写B数组测试 测试方法 访问方式 结果 说明 负索引访问 A[-16] ✅ 成功改写B[0] B在A前16字节 系统性测试 A[-16] ~ A[-7] ✅ 完全控制B数组 可改写B[0] ~ B[9] AddressSanitizer A[-20] ❌ 检测到溢出 全局缓冲区溢出错误 5. 内存布局详细分析 实际内存布局：\n1 2 3 4 5 6 7 8 9 内存地址从低到高： ┌─────────────┬─────────────┬─────────────┐ │ 数组B │ 填充区域 │ 数组A │ │ (10字节) │ (6字节) │ (10字节) │ │0x...1110 │ │0x...1120 │ └─────────────┴─────────────┴─────────────┘ ↑ ↑ A[-16]~A[-7] A[0]~A[9] 可以改写B[0]~B[9] 正常A数组范围 关键发现：\nB数组在A数组前面16字节 A[-16] 对应 B[0]，A[-15] 对应 B[1]，以此类推 A[-16] ~ A[-7] 可以完全控制B数组的所有10个元素 6. 原始内存内容分析 1 2 3 4 5 6 7 8 9 10 从A[0]开始的20个字节内容: 偏移 0: 地址0x564e0133f120, 值=A (ASCII: 65) 偏移 1: 地址0x564e0133f121, 值=B (ASCII: 66) ... 偏移 9: 地址0x564e0133f129, 值=J (ASCII: 74) 偏移10: 地址0x564e0133f12a, 值=X (ASCII: 88) ← A[10]写入成功 偏移11: 地址0x564e0133f12b, 值=X (ASCII: 88) ← A[11]写入成功 偏移12: 地址0x564e0133f12c, 值=X (ASCII: 88) ← A[12]写入成功 偏移13: 地址0x564e0133f12d, 值=? (ASCII: 0) ... 深入分析 🔍 为什么A[12]不会崩溃？为什么A可以改写B？ 1. 内存段特性 全局数组位于.bss段\n.bss段：存储未初始化的全局和静态变量 连续内存：同一段内的变量通常分配在连续内存中 零初始化：.bss段在程序启动时被零初始化 2. 内存对齐机制 1 2 3 4 5 6 7 8 9 内存布局示意图： ┌─────────────┬─────────────┬─────────────┐ │ 数组B │ 填充区域 │ 数组A │ │ (10字节) │ (6字节) │ (10字节) │ │0x...4110 │ │0x...4120 │ └─────────────┴─────────────┴─────────────┘ ↑ A[10], A[11], A[12] 访问这个区域 编译器对齐策略：\n为了性能优化，编译器会进行内存对齐 在数组之间可能插入填充字节 这些填充区域通常可以安全访问 3. 操作系统保护机制 页级内存保护：\nLinux内存保护以页为单位（通常4KB） 小范围越界（几个字节）不会跨越页边界 只要在同一页内，不会触发段错误 虚拟内存管理：\n全局变量在进程启动时就分配好内存 .bss段通常有较大的连续空间 越界访问仍在进程的合法地址空间内 🧪 不同编译选项的影响 AddressSanitizer测试 越界访问测试：\n1 2 3 gcc -fsanitize=address -o test test.c ./test # 结果：A[12]访问仍然没有检测到错误 改写B数组测试：\n1 2 3 4 # 当测试A[-20]时，AddressSanitizer检测到错误： ERROR: AddressSanitizer: global-buffer-overflow WRITE of size 1 at 0x5574cb8f61dc thread T0 SUMMARY: AddressSanitizer: global-buffer-overflow 原因分析：\nAddressSanitizer对全局数组的小范围越界检测不够敏感 但对于较大范围的越界访问（如A[-20]）能够检测到 A[-16] ~ A[-7]的访问没有被检测到，说明在\u0026quot;安全\u0026quot;范围内 不同优化级别 -O0：无优化，越界访问成功 -O2/-O3：可能改变内存布局，但通常仍可访问 安全性讨论 ⚠️ 风险评估 1. 数据破坏风险 1 2 // 危险示例 A[12] = \u0026#39;X\u0026#39;; // 可能覆盖其他重要数据 2. 缓冲区溢出攻击 虽然不会立即崩溃，但可能被恶意利用 攻击者可能通过越界写入注入恶意代码 特别危险：A数组可以完全控制B数组，如果B数组存储敏感信息（如密码、权限标志），后果严重 3. 调试困难 越界访问可能导致难以重现的bug 数据损坏可能在很久之后才表现出来 🛡️ 未定义行为的危险性 C标准观点：\n数组越界访问是未定义行为（Undefined Behavior），编译器和运行时环境不保证任何特定的行为。\n实际影响：\n编译器差异：不同编译器可能有不同的内存布局 平台差异：不同操作系统、架构可能表现不同 版本差异：同一编译器的不同版本可能改变行为 优化影响：编译器优化可能改变内存布局 最佳实践建议 ✅ 安全编程实践 1. 边界检查 1 2 3 4 5 6 7 8 // 推荐做法 void safe_array_access(char* arr, int size, int index, char value) { if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size) { arr[index] = value; } else { fprintf(stderr, \u0026#34;数组越界：索引 %d 超出范围 [0, %d)\\n\u0026#34;, index, size); } } 2. 使用安全的数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 // 使用结构体封装数组 typedef struct { char data[10]; int size; } SafeArray; int safe_set(SafeArray* arr, int index, char value) { if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; arr-\u0026gt;size) { arr-\u0026gt;data[index] = value; return 1; // 成功 } return 0; // 失败 } 3. 编译时检查 1 2 3 4 5 6 7 8 # 启用所有警告 gcc -Wall -Wextra -Werror -o program program.c # 使用静态分析工具 gcc -fanalyzer -o program program.c # 使用运行时检查 gcc -fsanitize=address -fsanitize=bounds -o program program.c 4. 代码审查清单 所有数组访问都有边界检查 使用sizeof()而不是硬编码数组大小 循环边界正确设置 指针运算有范围验证 🔧 开发工具推荐 工具 用途 命令示例 AddressSanitizer 内存错误检测 gcc -fsanitize=address Valgrind 内存泄漏检测 valgrind --tool=memcheck ./program Clang Static Analyzer 静态代码分析 clang --analyze program.c Cppcheck 静态分析 cppcheck program.c 附录 A. 完整测试代码 1. 基础越界访问测试程序 (array_bounds_test.c) 这是最基础的测试程序，验证A[12]是否可以访问：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; // 定义两个全局字符数组，大小为10 char A[10]; char B[10]; // 用于捕获段错误的跳转缓冲区 static jmp_buf segfault_buf; static int segfault_occurred = 0; // 段错误信号处理函数 void segfault_handler(int sig) { segfault_occurred = 1; longjmp(segfault_buf, 1); } void print_array_info() { printf(\u0026#34;=== 数组信息 ===\\n\u0026#34;); printf(\u0026#34;数组A地址: %p\\n\u0026#34;, (void*)A); printf(\u0026#34;数组B地址: %p\\n\u0026#34;, (void*)B); printf(\u0026#34;数组A大小: %zu 字节\\n\u0026#34;, sizeof(A)); printf(\u0026#34;数组B大小: %zu 字节\\n\u0026#34;, sizeof(B)); printf(\u0026#34;A和B之间的距离: %ld 字节\\n\u0026#34;, (char*)B - (char*)A); printf(\u0026#34;\\n\u0026#34;); } void initialize_arrays() { // 初始化数组A for (int i = 0; i \u0026lt; 10; i++) { A[i] = \u0026#39;A\u0026#39; + i; // A[0]=\u0026#39;A\u0026#39;, A[1]=\u0026#39;B\u0026#39;, ..., A[9]=\u0026#39;J\u0026#39; } // 初始化数组B for (int i = 0; i \u0026lt; 10; i++) { B[i] = \u0026#39;a\u0026#39; + i; // B[0]=\u0026#39;a\u0026#39;, B[1]=\u0026#39;b\u0026#39;, ..., B[9]=\u0026#39;j\u0026#39; } printf(\u0026#34;=== 数组初始化完成 ===\\n\u0026#34;); printf(\u0026#34;数组A内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, A[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;数组B内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, B[i]); } printf(\u0026#34;\\n\\n\u0026#34;); } void test_array_access() { printf(\u0026#34;=== 测试数组访问 ===\\n\u0026#34;); // 测试正常访问 printf(\u0026#34;正常访问测试:\\n\u0026#34;); printf(\u0026#34;A[0] = %c\\n\u0026#34;, A[0]); printf(\u0026#34;A[9] = %c\\n\u0026#34;, A[9]); printf(\u0026#34;B[0] = %c\\n\u0026#34;, B[0]); printf(\u0026#34;B[9] = %c\\n\u0026#34;, B[9]); printf(\u0026#34;\\n\u0026#34;); // 测试越界访问 printf(\u0026#34;越界访问测试:\\n\u0026#34;); // 设置信号处理器 signal(SIGSEGV, segfault_handler); // 测试访问A[10], A[11], A[12]等 for (int i = 10; i \u0026lt;= 15; i++) { segfault_occurred = 0; if (setjmp(segfault_buf) == 0) { // 尝试读取 char value = A[i]; printf(\u0026#34;A[%d] = %c (ASCII: %d) - 成功读取\\n\u0026#34;, i, (value \u0026gt;= 32 \u0026amp;\u0026amp; value \u0026lt;= 126) ? value : \u0026#39;?\u0026#39;, (int)value); } else { printf(\u0026#34;A[%d] - 访问时发生段错误！\\n\u0026#34;, i); } } printf(\u0026#34;\\n\u0026#34;); // 测试写入越界位置 printf(\u0026#34;越界写入测试:\\n\u0026#34;); for (int i = 10; i \u0026lt;= 12; i++) { segfault_occurred = 0; if (setjmp(segfault_buf) == 0) { A[i] = \u0026#39;X\u0026#39;; printf(\u0026#34;A[%d] = \u0026#39;X\u0026#39; - 成功写入\\n\u0026#34;, i); } else { printf(\u0026#34;A[%d] - 写入时发生段错误！\\n\u0026#34;, i); } } printf(\u0026#34;\\n\u0026#34;); // 检查B数组是否被影响 printf(\u0026#34;检查B数组是否被影响:\\n\u0026#34;); printf(\u0026#34;数组B当前内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, B[i]); } printf(\u0026#34;\\n\u0026#34;); } void test_memory_layout() { printf(\u0026#34;=== 内存布局分析 ===\\n\u0026#34;); // 显示内存中的实际内容 printf(\u0026#34;从A[0]开始的20个字节内容:\\n\u0026#34;); for (int i = 0; i \u0026lt; 20; i++) { char* ptr = (char*)A + i; printf(\u0026#34;偏移%2d: 地址%p, 值=%c (ASCII:%3d)\\n\u0026#34;, i, (void*)ptr, (*ptr \u0026gt;= 32 \u0026amp;\u0026amp; *ptr \u0026lt;= 126) ? *ptr : \u0026#39;?\u0026#39;, (int)*ptr); } printf(\u0026#34;\\n\u0026#34;); // 检查A和B的相对位置 if ((char*)B \u0026gt; (char*)A) { long distance = (char*)B - (char*)A; printf(\u0026#34;B数组在A数组之后 %ld 字节\\n\u0026#34;, distance); if (distance == 10) { printf(\u0026#34;A和B在内存中是连续的！A[10]实际上就是B[0]\\n\u0026#34;); } else if (distance \u0026lt; 20) { printf(\u0026#34;A和B在内存中很接近，可能存在重叠访问\\n\u0026#34;); } } else { long distance = (char*)A - (char*)B; printf(\u0026#34;A数组在B数组之后 %ld 字节\\n\u0026#34;, distance); } } int main() { printf(\u0026#34;全局字符数组越界访问测试程序\\n\u0026#34;); printf(\u0026#34;=====================================\\n\\n\u0026#34;); print_array_info(); initialize_arrays(); test_array_access(); test_memory_layout(); printf(\u0026#34;=== 测试总结 ===\\n\u0026#34;); printf(\u0026#34;1. 全局数组通常分配在数据段(.data或.bss)\\n\u0026#34;); printf(\u0026#34;2. 编译器可能会将相邻声明的全局数组放在连续内存中\\n\u0026#34;); printf(\u0026#34;3. 越界访问可能不会立即崩溃，但会导致未定义行为\\n\u0026#34;); printf(\u0026#34;4. 实际行为取决于编译器、链接器和运行时环境\\n\u0026#34;); printf(\u0026#34;5. 在生产代码中应该避免任何形式的越界访问\\n\u0026#34;); return 0; } 2. 数组改写测试程序 (array_overwrite_test.c) 这个程序专门测试A数组是否可以改写B数组的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; // 定义两个全局字符数组，大小为10 char A[10]; char B[10]; // 用于捕获段错误的跳转缓冲区 static jmp_buf segfault_buf; static int segfault_occurred = 0; // 段错误信号处理函数 void segfault_handler(int sig) { segfault_occurred = 1; longjmp(segfault_buf, 1); } void print_memory_layout() { printf(\u0026#34;=== 内存布局信息 ===\\n\u0026#34;); printf(\u0026#34;数组A地址: %p\\n\u0026#34;, (void*)A); printf(\u0026#34;数组B地址: %p\\n\u0026#34;, (void*)B); printf(\u0026#34;A和B之间的距离: %ld 字节\\n\u0026#34;, (char*)B - (char*)A); // 判断A和B的相对位置 if ((char*)A \u0026lt; (char*)B) { printf(\u0026#34;内存布局: A在前，B在后\\n\u0026#34;); printf(\u0026#34;A[10]及以后可能影响B数组\\n\u0026#34;); } else { printf(\u0026#34;内存布局: B在前，A在后\\n\u0026#34;); printf(\u0026#34;A的负索引可能影响B数组\\n\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } void initialize_arrays() { printf(\u0026#34;=== 初始化数组 ===\\n\u0026#34;); // 初始化数组A for (int i = 0; i \u0026lt; 10; i++) { A[i] = \u0026#39;A\u0026#39; + i; // A[0]=\u0026#39;A\u0026#39;, A[1]=\u0026#39;B\u0026#39;, ..., A[9]=\u0026#39;J\u0026#39; } // 初始化数组B for (int i = 0; i \u0026lt; 10; i++) { B[i] = \u0026#39;a\u0026#39; + i; // B[0]=\u0026#39;a\u0026#39;, B[1]=\u0026#39;b\u0026#39;, ..., B[9]=\u0026#39;j\u0026#39; } printf(\u0026#34;数组A初始内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, A[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;数组B初始内容: \u0026#34;); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%c \u0026#34;, B[i]); } printf(\u0026#34;\\n\\n\u0026#34;); } int test_overwrite_via_negative_index() { printf(\u0026#34;=== 测试通过负索引改写B数组 ===\\n\u0026#34;); long distance = (char*)A - (char*)B; int b_changed = 0; if (distance \u0026gt; 0) { // A在B后面，尝试通过A的负索引访问B printf(\u0026#34;A在B后面，距离%ld字节，尝试通过A[-%ld]访问B[0]\\n\u0026#34;, distance, distance); segfault_occurred = 0; if (setjmp(segfault_buf) == 0) { char old_b0 = B[0]; A[-distance] = \u0026#39;Y\u0026#39;; // 尝试通过A的负索引修改B[0] if (B[0] != old_b0) { printf(\u0026#34;✅ 成功！A[-%ld] = \u0026#39;Y\u0026#39; 改变了B[0]: \u0026#39;%c\u0026#39; -\u0026gt; \u0026#39;%c\u0026#39;\\n\u0026#34;, distance, old_b0, B[0]); b_changed = 1; } else { printf(\u0026#34;❌ A[-%ld] = \u0026#39;Y\u0026#39; 没有影响B[0]\\n\u0026#34;, distance); } } else { printf(\u0026#34;❌ 访问A[-%ld]时发生段错误\\n\u0026#34;, distance); } } else { printf(\u0026#34;B在A后面，无法通过负索引直接访问B\\n\u0026#34;); } return b_changed; } void test_systematic_overwrite() { printf(\u0026#34;=== 系统性测试：寻找能影响B的A索引 ===\\n\u0026#34;); // 重新初始化数组 initialize_arrays(); printf(\u0026#34;测试范围：A[-20] 到 A[30]\\n\u0026#34;); for (int offset = -20; offset \u0026lt;= 30; offset++) { // 保存B数组的原始状态 char original_b[10]; memcpy(original_b, B, 10); segfault_occurred = 0; if (setjmp(segfault_buf) == 0) { // 尝试写入一个特殊值 A[offset] = \u0026#39;Z\u0026#39;; // 检查B数组是否被改变 int b_index_changed = -1; for (int i = 0; i \u0026lt; 10; i++) { if (B[i] != original_b[i]) { b_index_changed = i; break; } } if (b_index_changed \u0026gt;= 0) { printf(\u0026#34;🎯 A[%d] = \u0026#39;Z\u0026#39; 影响了B[%d]: \u0026#39;%c\u0026#39; -\u0026gt; \u0026#39;%c\u0026#39;\\n\u0026#34;, offset, b_index_changed, original_b[b_index_changed], B[b_index_changed]); // 恢复B数组 B[b_index_changed] = original_b[b_index_changed]; } } else { printf(\u0026#34;💥 A[%d] 访问时发生段错误\\n\u0026#34;, offset); } } } // ... 其他函数省略 ... int main() { printf(\u0026#34;全局数组A改写数组B测试程序\\n\u0026#34;); printf(\u0026#34;================================\\n\\n\u0026#34;); print_memory_layout(); initialize_arrays(); int negative_success = test_overwrite_via_negative_index(); test_systematic_overwrite(); printf(\u0026#34;=== 测试总结 ===\\n\u0026#34;); printf(\u0026#34;1. 通过负索引改写B: %s\\n\u0026#34;, negative_success ? \u0026#34;成功\u0026#34; : \u0026#34;失败\u0026#34;); printf(\u0026#34;2. A数组%s直接改写B数组的内容\\n\u0026#34;, negative_success ? \u0026#34;可以\u0026#34; : \u0026#34;无法\u0026#34;); printf(\u0026#34;3. 这种行为是未定义的，不应在生产代码中使用\\n\u0026#34;); return 0; } 3. 安全威胁演示程序 (dangerous_demo.c) 这个程序演示了数组越界访问如何被恶意利用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 模拟一个真实的安全场景 char user_input[10]; // 用户输入缓冲区 char admin_flag[10]; // 管理员权限标志 void initialize_system() { // 初始化管理员标志为\u0026#34;NOADMIN\u0026#34; strcpy(admin_flag, \u0026#34;NOADMIN\u0026#34;); printf(\u0026#34;系统初始化完成\\n\u0026#34;); printf(\u0026#34;管理员权限: %s\\n\u0026#34;, admin_flag); } void process_user_input(const char* input) { printf(\u0026#34;\\n处理用户输入: %s\\n\u0026#34;, input); // 危险的操作：没有边界检查的复制 for (int i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) { user_input[i] = input[i]; // 潜在的缓冲区溢出 } printf(\u0026#34;用户输入已保存\\n\u0026#34;); } void check_admin_privileges() { printf(\u0026#34;\\n检查管理员权限...\\n\u0026#34;); printf(\u0026#34;当前管理员标志: %s\\n\u0026#34;, admin_flag); if (strncmp(admin_flag, \u0026#34;ADMIN\u0026#34;, 5) == 0) { printf(\u0026#34;🔓 管理员权限已激活！可以执行特权操作。\\n\u0026#34;); } else { printf(\u0026#34;🔒 普通用户权限，无法执行特权操作。\\n\u0026#34;); } } int main() { printf(\u0026#34;危险的数组越界访问演示\\n\u0026#34;); printf(\u0026#34;========================\\n\u0026#34;); initialize_system(); // 正常的用户输入 printf(\u0026#34;\\n--- 测试1: 正常输入 ---\\n\u0026#34;); process_user_input(\u0026#34;hello\u0026#34;); check_admin_privileges(); // 危险的长输入，可能覆盖admin_flag printf(\u0026#34;\\n--- 测试2: 长输入（可能的攻击）---\\n\u0026#34;); // 计算需要多少字符才能到达admin_flag long distance = (char*)admin_flag - (char*)user_input; if (distance \u0026gt; 0 \u0026amp;\u0026amp; distance \u0026lt; 50) { printf(\u0026#34;尝试通过长输入覆盖admin_flag...\\n\u0026#34;); // 构造恶意输入 char malicious_input[100]; memset(malicious_input, \u0026#39;X\u0026#39;, distance); // 填充到admin_flag位置 strcpy(malicious_input + distance, \u0026#34;ADMIN\u0026#34;); // 在admin_flag位置写入\u0026#34;ADMIN\u0026#34; malicious_input[distance + 5] = \u0026#39;\\0\u0026#39;; // 确保字符串结束 printf(\u0026#34;恶意输入长度: %ld 字节\\n\u0026#34;, strlen(malicious_input)); process_user_input(malicious_input); check_admin_privileges(); printf(\u0026#34;\\n💀 攻击成功！通过缓冲区溢出获得了管理员权限！\\n\u0026#34;); } else { printf(\u0026#34;当前内存布局不适合演示攻击（距离：%ld）\\n\u0026#34;, distance); } printf(\u0026#34;\\n⚠️ 这个演示展示了为什么数组越界访问如此危险！\\n\u0026#34;); printf(\u0026#34;⚠️ 在真实的程序中，这种漏洞可能被恶意利用来获取系统权限。\\n\u0026#34;); return 0; } 4. 编译脚本 (Makefile) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 CC = gcc CFLAGS = -Wall -Wextra -g -O0 TARGET = array_bounds_test SOURCE = array_bounds_test.c OVERWRITE_TARGET = array_overwrite_test OVERWRITE_SOURCE = array_overwrite_test.c DEMO_TARGET = dangerous_demo DEMO_SOURCE = dangerous_demo.c # 默认目标 all: $(TARGET) $(OVERWRITE_TARGET) $(DEMO_TARGET) # 编译目标 $(TARGET): $(SOURCE) $(CC) $(CFLAGS) -o $(TARGET) $(SOURCE) # 编译改写测试程序 $(OVERWRITE_TARGET): $(OVERWRITE_SOURCE) $(CC) $(CFLAGS) -o $(OVERWRITE_TARGET) $(OVERWRITE_SOURCE) # 编译危险演示程序 $(DEMO_TARGET): $(DEMO_SOURCE) $(CC) $(CFLAGS) -o $(DEMO_TARGET) $(DEMO_SOURCE) # 运行测试 run: $(TARGET) ./$(TARGET) # 运行改写测试 run-overwrite: $(OVERWRITE_TARGET) ./$(OVERWRITE_TARGET) # 运行危险演示 run-demo: $(DEMO_TARGET) ./$(DEMO_TARGET) # 使用AddressSanitizer编译 asan: $(SOURCE) $(CC) $(CFLAGS) -fsanitize=address -o $(TARGET)_asan $(SOURCE) # 使用AddressSanitizer编译改写测试 asan-overwrite: $(OVERWRITE_SOURCE) $(CC) $(CFLAGS) -fsanitize=address -o $(OVERWRITE_TARGET)_asan $(OVERWRITE_SOURCE) # 运行AddressSanitizer版本 run-asan: asan ./$(TARGET)_asan # 运行AddressSanitizer改写测试版本 run-asan-overwrite: asan-overwrite ./$(OVERWRITE_TARGET)_asan # 清理 clean: rm -f $(TARGET) $(TARGET)_asan $(OVERWRITE_TARGET) $(OVERWRITE_TARGET)_asan $(DEMO_TARGET) # 显示帮助 help: @echo \u0026#34;可用的目标:\u0026#34; @echo \u0026#34; all - 编译所有程序\u0026#34; @echo \u0026#34; run - 编译并运行越界访问测试程序\u0026#34; @echo \u0026#34; run-overwrite - 编译并运行数组改写测试程序\u0026#34; @echo \u0026#34; run-demo - 编译并运行危险演示程序\u0026#34; @echo \u0026#34; valgrind - 使用valgrind运行越界访问测试\u0026#34; @echo \u0026#34; asan - 使用AddressSanitizer编译越界访问测试\u0026#34; @echo \u0026#34; asan-overwrite - 使用AddressSanitizer编译改写测试\u0026#34; @echo \u0026#34; run-asan - 运行AddressSanitizer版本的越界访问测试\u0026#34; @echo \u0026#34; run-asan-overwrite - 运行AddressSanitizer版本的改写测试\u0026#34; @echo \u0026#34; clean - 清理生成的文件\u0026#34; @echo \u0026#34; help - 显示此帮助信息\u0026#34; .PHONY: all run run-overwrite run-demo valgrind asan asan-overwrite run-asan run-asan-overwrite clean help 5. 代码使用说明 快速开始：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 1. 下载所有代码文件到同一目录 # 2. 确保系统安装了GCC编译器 # 3. 运行以下命令： # 编译所有程序 make all # 运行基础测试（验证A[12]访问） make run # 运行改写测试（验证A改写B） make run-overwrite # 运行安全演示（权限提升攻击） make run-demo 高级测试：\n1 2 3 4 5 6 7 8 9 10 11 # 使用AddressSanitizer检测内存错误 make run-asan-overwrite # 使用Valgrind检测内存问题 make valgrind # 查看所有可用命令 make help # 清理生成的文件 make clean 代码结构说明：\n每个程序都包含段错误处理机制 使用setjmp/longjmp捕获可能的崩溃 详细的内存布局分析和结果输出 支持多种编译器选项和调试工具 B. 编译和运行指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 越界访问测试 make run # 数组改写测试 make run-overwrite # AddressSanitizer测试 make run-asan make run-asan-overwrite # Valgrind测试 make valgrind # 查看符号表 objdump -t array_bounds_test | grep -E \u0026#34;(A|B)$\u0026#34; # 查看所有可用命令 make help C. 测试结果示例 基础越界访问测试输出示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 全局字符数组越界访问测试程序 ===================================== === 数组信息 === 数组A地址: 0x564e0133f120 数组B地址: 0x564e0133f110 数组A大小: 10 字节 数组B大小: 10 字节 A和B之间的距离: -16 字节 === 数组初始化完成 === 数组A内容: A B C D E F G H I J 数组B内容: a b c d e f g h i j === 测试数组访问 === 正常访问测试: A[0] = A A[9] = J B[0] = a B[9] = j 越界访问测试: A[10] = ? (ASCII: 0) - 成功读取 A[11] = ? (ASCII: 0) - 成功读取 A[12] = ? (ASCII: 0) - 成功读取 ← 关键结果：A[12]可以访问！ A[13] = ? (ASCII: 0) - 成功读取 A[14] = ? (ASCII: 0) - 成功读取 A[15] = ? (ASCII: 0) - 成功读取 越界写入测试: A[10] = \u0026#39;X\u0026#39; - 成功写入 A[11] = \u0026#39;X\u0026#39; - 成功写入 A[12] = \u0026#39;X\u0026#39; - 成功写入 ← 关键结果：A[12]可以写入！ 数组改写测试输出示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 全局数组A改写数组B测试程序 ================================ === 内存布局信息 === 数组A地址: 0x564a46bc3120 数组B地址: 0x564a46bc3110 A和B之间的距离: -16 字节 内存布局: B在前，A在后 A的负索引可能影响B数组 === 测试通过负索引改写B数组 === A在B后面，距离16字节，尝试通过A[-16]访问B[0] ✅ 成功！A[-16] = \u0026#39;Y\u0026#39; 改变了B[0]: \u0026#39;a\u0026#39; -\u0026gt; \u0026#39;Y\u0026#39; ← 关键结果：A可以改写B！ === 系统性测试：寻找能影响B的A索引 === 测试范围：A[-20] 到 A[30] 🎯 A[-16] = \u0026#39;Z\u0026#39; 影响了B[0]: \u0026#39;a\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-15] = \u0026#39;Z\u0026#39; 影响了B[1]: \u0026#39;b\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-14] = \u0026#39;Z\u0026#39; 影响了B[2]: \u0026#39;c\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-13] = \u0026#39;Z\u0026#39; 影响了B[3]: \u0026#39;d\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-12] = \u0026#39;Z\u0026#39; 影响了B[4]: \u0026#39;e\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-11] = \u0026#39;Z\u0026#39; 影响了B[5]: \u0026#39;f\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-10] = \u0026#39;Z\u0026#39; 影响了B[6]: \u0026#39;g\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-9] = \u0026#39;Z\u0026#39; 影响了B[7]: \u0026#39;h\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-8] = \u0026#39;Z\u0026#39; 影响了B[8]: \u0026#39;i\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; 🎯 A[-7] = \u0026#39;Z\u0026#39; 影响了B[9]: \u0026#39;j\u0026#39; -\u0026gt; \u0026#39;Z\u0026#39; ← A[-16]~A[-7]完全控制B数组！ 安全演示输出示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 危险的数组越界访问演示 ======================== 系统初始化完成 管理员权限: NOADMIN === 内存布局信息 === user_input地址: 0x5561d97b2018 admin_flag地址: 0x5561d97b2028 两者距离: 16 字节 ⚠️ admin_flag在user_input后16字节 ⚠️ user_input[16] 可以修改admin_flag[0] --- 测试1: 正常输入 --- 处理用户输入: hello 用户输入已保存 检查管理员权限... 当前管理员标志: NOADMIN 🔒 普通用户权限，无法执行特权操作。 --- 测试2: 长输入（可能的攻击）--- 尝试通过长输入覆盖admin_flag... 恶意输入长度: 21 字节 处理用户输入: XXXXXXXXXXXXXXXXADMIN 用户输入已保存 检查管理员权限... 当前管理员标志: ADMININ 🔓 管理员权限已激活！可以执行特权操作。 ← 攻击成功！ 💀 攻击成功！通过缓冲区溢出获得了管理员权限！ D. 相关资源 C11标准文档 GCC文档 - AddressSanitizer Linux内存管理 📝 结论 通过详细的实验验证，我们得出以下结论：\n🎯 直接回答原问题： A[12]不会崩溃，可以正常访问 A数组可以直接改写B数组的内容 🔬 技术发现： 内存布局：B数组在A数组前16字节，编译器在它们之间留有6字节填充 访问方式：通过A[-16] ~ A[-7]可以完全控制B[0] ~ B[9] 检测工具：AddressSanitizer能检测到大范围越界，但对小范围越界不敏感 ⚠️ 安全警告： 未定义行为：这种访问方式是C标准未定义的行为 极度危险：A数组能完全控制B数组，可能导致严重安全问题 不可移植：不同编译器、平台可能有完全不同的行为 💡 最佳实践： 永远不要依赖这种行为 使用边界检查和安全的数据结构 启用所有编译器警告和静态分析工具 最重要的提醒：虽然测试显示不会崩溃，但这种行为是不可预测和不可移植的。在任何生产环境中都应该避免数组越界访问。\n报告生成时间：2025年9月12日\n测试环境：Linux x86_64, GCC编译器\n","date":"2025-09-12T00:00:00Z","permalink":"https://zhangquanhua1.github.io/p/%E5%85%A8%E5%B1%80%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/","title":"全局数组越界访问行为分析"},{"content":"C/C++编程中一个极其经典、常见且危险的问题的典型表现。它的名字是：\n栈缓冲区溢出导致返回地址被覆盖，进而 hijack（劫持）程序执行流 这是一个属于 “内存损坏” (Memory Corruption) 大类的经典问题，也是历史上绝大多数软件安全漏洞的根源。\n为什么说它“经典”？ 历史悠久：自C语言诞生以来，这个问题就一直存在。1988年著名的 “莫里斯蠕虫” 就利用了fingerd程序的栈缓冲区溢出漏洞，成为了首个引起全球关注的网络攻击事件。\n安全漏洞的常青树：尽管现代操作系统和编译器已经引入了许多缓解措施（如DEP/NX, ASLR, Stack Canaries），但由代码编写不当导致的栈溢出依然是常见的高危漏洞来源。\n教科书式的案例：几乎所有讲解C/C++内存安全、软件漏洞和逆向工程的课程和书籍，都会以“栈缓冲区溢出”作为开篇的第一个经典案例。\n这个经典问题的核心要素与您的日志完美匹配 经典问题要素\t在您的日志中的体现\n根源：不安全的操作\t您的代码中（很可能在libnstackx_ctrl.z.so）存在对固定大小的栈数组（如char buf[100]）进行写入操作，且未检查输入长度。 触发：越界写入\t一个过长的输入（如网络数据包）被拷贝到该数组中，写入了超出其分配空间的数据。 破坏：覆盖关键数据\t越界数据覆盖了栈上保存的函数返回地址。这是栈帧结构的一部分，位于局部变量之后。 表现：控制流劫持\t当前函数执行完毕时，CPU从被覆盖的返回地址处读取下一个要执行的指令地址。这个地址被篡改成了一个无效值 (0x0000000000308720)。 结果：崩溃\tCPU试图执行无效地址的指令，导致段错误 (SIGSEGV)。 附加特征：调用栈不可靠\t由于栈本身已被破坏，任何试图回溯调用栈的工具都会得到不可靠甚至完全错误的结果。工具在垃圾数据中扫描，误将某些数据解释为指向PostAuthEvent的指针。这正是该经典问题的标志性特征。 与之相关的其他经典概念 Smashing The Stack：这是一篇发表于1996年的著名论文《Smashing The Stack for Fun and Profit》的标题。该论文详细讲解了如何利用栈缓冲区溢出来执行任意代码，使得这个问题在安全社区人尽皆知。您的案例就是“Stack Smashing”的一个典型后果。 Segmentation Fault (SIGSEGV)：这是此类问题最直接、最常见的结果。\n未定义行为 (Undefined Behavior)：在C/C++标准中，数组越界访问就属于“未定义行为”，意味着任何事情都可能发生。程序崩溃反而是相对“好”的结果。\n总结 您遇到的不是什么稀奇古怪的新问题，而是一个教科书级别的、经典的栈缓冲区溢出导致程序控制流被劫持并最终崩溃的案例。\n排查这类问题的经典方法是：\n忽略不可靠的调用栈，认识到PostAuthEvent是受害者而非元凶。\n将注意力集中在崩溃线程（nStackXDFinder）中所有对固定大小数组进行写入操作的代码上。\n使用AddressSanitizer等工具，它们能像侦探一样精准地指出是哪一行代码发生了越界写入。\n修复代码，用带长度检查的安全函数（如snprintf, strncpy）替换不安全的函数（如sprintf, strcpy），并在拷贝前始终进行长度校验。\n这个问题之所以经典，是因为它完美地展示了C/C++在赋予程序员强大内存控制能力的同时，也要求程序员承担起全部的责任，细微的疏忽就会导致整个程序以最意想不到的方式崩溃。\n","date":"2025-09-12T00:00:00Z","permalink":"https://zhangquanhua1.github.io/p/%E5%87%BD%E6%95%B0%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BA%86%E6%B5%81%E7%A8%8B%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%87%BD%E6%95%B0/","title":"函数访问到了流程中不存在的函数"},{"content":"加电复位：CPU的\u0026quot;本能\u0026quot; 当按下开机键，CPU获得电力后，其行为由硬件设计预先决定：\n重置寄存器：将所有内部寄存器设置为已知的初始状态。\n进入实模式：x86架构CPU会进入实模式（Real Mode），在此模式下可直接访问最初的1MB内存，无内存保护或权限分级。\n执行第一条指令：CPU的程序计数器（CS:IP寄存器）被硬编码指向内存地址 0xFFFF0。该地址位于主板的BIOS（或现代计算机的UEFI）固件芯片中。\n至此，CPU只是机械地执行硬件设计好的步骤，对\u0026quot;内核\u0026quot;一无所知。\n第一棒：固件（BIOS/UEFI） CPU开始执行固件中的代码，其主要任务是：\n硬件自检（POST）：检查关键硬件（内存、显卡、键盘等）是否正常工作。\n初始化硬件：配置主板芯片组、磁盘控制器等。\n寻找引导程序：\nBIOS：按照预设顺序（如：U盘-\u0026gt;硬盘）读取存储设备的第一个扇区（512字节），即主引导记录（MBR），并将其加载到内存地址 0x7C00 处。\nUEFI：更先进，直接从EFI系统分区中查找并加载扩展性更强的引导程序文件。\n移交控制权：CPU跳转到 0x7C00（或UEFI加载的引导程序地址），开始执行引导程序代码。\n第二棒：引导程序（Bootloader） MBR中的空间很小，通常只存放引导程序的第一阶段。其核心任务是加载功能更全的第二阶段引导程序（如GRUB、Windows Boot Manager）。\n第二阶段引导程序的工作：\n提供菜单：允许用户选择要启动的操作系统（如果有多个）。\n识别文件系统：具备解析磁盘文件系统（如EXT4, NTFS）的能力，而不仅仅是读写原始扇区。\n加载内核映像：根据配置，从文件系统中找到内核文件（如Linux的 /boot/vmlinuz-xxx），并将其读取到内存中合适的位置。\n准备内核运行环境：设置启动参数（如根文件系统位置、分辨率）。\n切换CPU模式：将CPU从实模式切换到现代的保护模式（Protected Mode） 或 长模式（Long Mode, 64位），以启用虚拟内存、权限保护等关键特性。\n跳转到内核：最后，引导程序跳转（jump） 到内核在内存中的入口地址，将控制权彻底交给内核。\n引导程序是内核的\u0026quot;引路人\u0026quot;，完成了从\u0026quot;找扇区\u0026quot;到\u0026quot;找文件\u0026quot;的关键跨越。\n第三棒：内核启动与初始化 内核启动是一个复杂的过程，可分为两个主要阶段：\n第一阶段：架构相关初始化（汇编） 这是内核最先执行的代码，直接与CPU硬件交互，通常用汇编语言编写：\n设置初始堆栈\n清除BSS段：将未初始化的全局变量区域清零。\n解压内核（如果需要）：许多发行版的内核映像是压缩过的（如vmlinuz），此阶段会进行自解压。\n启用分页（Paging）：建立初始页表，开启MMU（内存管理单元），让CPU使用虚拟内存地址。这是现代操作系统的基石。\n设置中断描述符表（IDT）：为处理硬件中断、异常和系统调用做好准备。\n跳转到主入口点：最终跳转到如 start_kernel() 这样的C语言函数，进入内核主体。\n第二阶段：通用内核初始化（C语言） start_kernel() 是内核初始化的\u0026quot;主函数\u0026quot;，它调用一系列初始化函数来构建整个操作系统：\nsched_init(): 初始化调度器，创建0号进程（idle进程）。\nmm_init(): 初始化内存管理系统（伙伴系统、slab分配器）。\ntrap_init() / init_IRQ(): 完善中断和异常处理机制。\ntime_init(): 初始化系统时钟，内核开始感知时间。\nvfs_caches_init(): 初始化虚拟文件系统（VFS），为挂载根文件系统做准备。\n挂载根文件系统：可能先挂载内存中的initramfs（临时根文件系统）来加载必要驱动，再挂载真正的根文件系统。\n启动第一个用户空间进程：这是内核初始化的最后一步。内核线程会尝试执行用户空间的 /sbin/init（或其链接，如 /lib/systemd/systemd）。这个进程成为所有用户进程的祖先（PID 1）。\n一旦 /sbin/init 被执行，内核的启动过程就正式结束，控制权交给了用户空间。\n内核启动后，它是后台运行吗？ 答案是：否。内核不是一个在\u0026quot;后台\u0026quot;运行的进程。\n这是一个关键区别。内核的运行方式与普通程序（前台或后台）有本质不同：\n内核是：\n常驻内存的代码和数据：内核始终驻留在物理内存的受保护区域（内核空间）。\n被动的执行环境和服务提供者：内核自身不会主动持续运行。它的代码在以下三种情况下被被动调用：\n系统调用（Syscall）：应用程序主动请求操作系统服务（如读写文件），通过指令（如syscall）陷入内核。\n硬件中断（Interrupt）：硬件设备需要CPU关注（如网卡收到数据、时钟滴答），触发CPU执行对应的中断处理程序。\n异常（Exception）：CPU执行指令时发生错误（如除零），由内核的异常处理程序处理。\n所有进程的\u0026quot;底层\u0026quot;：每个用户进程都像是在内核这个\u0026quot;地基\u0026quot;上建立的\u0026quot;房子\u0026quot;。当需要执行特权操作时，进程就\u0026quot;陷入\u0026quot;地基（内核）中寻求帮助。\n特征 用户进程（前台/后台） 内核 运行方式 主动执行自己的代码流 被动响应（系统调用、中断、异常） 存在形式 进程列表中的一个实体 常驻内存的代码和数据结构，是进程运行的环境 CPU模式 用户态 内核态（当被调用时） 如何结束 调用exit()或被杀掉 永不结束，直到计算机关机 总结与类比 计算机启动过程就像一场精心设计的接力赛：\nCPU：是运动员，只有跑步的本能。\nBIOS/UEFI：是第一棒教练（接生婆），确保运动员健康并把他交给下一棒。\n引导程序（GRUB等）：是第二棒领跑员（家庭教师），带领运动员到正确的位置并交棒。\n内核：是第三棒运动员兼体育场建筑师（大学），它接管比赛，并首先建造整个体育场（初始化系统），然后制定规则（系统调用），裁判比赛（调度进程）。\ninit / systemd：是赛后活动组织者，根据规则启动各种游戏和服务（用户进程）。\n内核并非后台守护进程，而是系统的基石。它静默地存在于内存中，等待被应用程序和硬件事件调用，从而为所有程序提供安全、可靠、统一的硬件访问和管理服务。\n","date":"2025-09-06T00:00:00Z","permalink":"https://zhangquanhua1.github.io/p/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","title":"Linux内核启动流程"},{"content":"内核管理进程的核心可以概括为：“一抽象，两分离，四管理”。\n一抽象：将运行中的程序抽象为进程（Process）。\n两分离：实现CPU虚拟化（分时复用）和内存虚拟化（每个进程有独立的地址空间）。\n四管理：通过进程描述符（PCB）、进程调度、内存管理和进程间通信（IPC） 这四大机制来具体实现管理。\n下面我们详细展开。\n1. 进程的抽象：进程描述符（PCB） 内核要管理进程，首先必须能描述一个进程。内核通过一个称为进程控制块（PCB, Process Control Block） 的数据结构来代表一个进程。在Linux中，这就是 task_struct 结构体（非常庞大，包含上百个字段）。\n这个结构体是内核管理进程的核心，它就像一个进程的“户口本”或“病历”，记录了关于该进程的一切信息，主要包括：\n进程标识符（PID）：唯一的身份证，用于区分不同进程。\n进程状态：运行、就绪、睡眠、僵尸状态等。\n程序计数器（PC）：记录下一条要执行的指令地址。\nCPU寄存器：当进程被切换时，需要保存当前的寄存器状态，以便下次恢复。\n内存管理信息：指向页表（Page Table）的指针，这是实现虚拟内存的关键。\n文件描述符表：记录该进程打开了哪些文件。\n资源使用信息：CPU时间、内存使用量等。\n优先级：用于调度器决定谁先运行。\n进程间关系：父进程、子进程、兄弟进程等信息。\n内核将所有进程的PCB通过链表或树等数据结构组织起来。因此，管理进程在很大程度上就是管理这些 task_struct 结构体。\n2. 进程的生命周期管理（状态机） 进程并非从生到死都在运行。内核为其定义了一系列状态（State），形成一个状态机：\n就绪（Ready）：进程已准备好，只等调度器分配CPU即可运行。\n运行（Running）：进程正在CPU上执行。\n阻塞/睡眠（Blocked/Sleeping）：进程在等待某个事件（如等待用户输入、等待磁盘IO完成），此时它不需要CPU。\n僵尸（Zombie）：进程已终止，但其PCB还未被父进程回收。\n终止（Terminated）：进程结束，所有资源被回收。\n内核负责根据事件（如IO完成、时间片用完）来驱动进程在这些状态间转换。\n3. CPU虚拟化：进程调度（Scheduling） CPU核心数远少于进程数，内核通过调度器（Scheduler） 来制造“每个进程都在同时运行”的假象，即分时复用。\n调度器的工作流程：\n选择：从就绪队列中，根据特定的调度算法（如CFS-完全公平调度器）选择一个最值得运行的进程。\n切换：\n上下文切换（Context Switch）：将当前运行进程的状态（寄存器、PC等）保存到其PCB中。\n加载：将下一个要运行进程的状态从其PCB中加载到CPU寄存器中。\n切换页表，从而切换内存地址空间。\n执行：CPU开始执行新进程的代码。\n触发调度的时机：\n主动让出：进程执行系统调用（如sleep, read等待IO）或主动yield。\n被动抢占：硬件时钟中断发生，调度器检查当前进程的时间片是否用完，如果用完则强制切换。\n通过频繁的调度和上下文切换，内核实现了多个进程在CPU上的“同时”运行。\n4. 内存虚拟化：内存管理（Memory Management） 每个进程都认为自己独享整个内存空间。这是内核通过虚拟内存机制实现的魔法。\n内核为每个进程维护一张独立的页表（Page Table）：\n页表定义了虚拟地址到物理地址的映射关系。\nMMU（内存管理单元）在CPU执行指令时，通过查询当前进程的页表来自动完成地址转换。\n这样做的好处：\n隔离性与保护：进程A无法访问进程B的内存，因为它们的虚拟地址映射到不同的物理页。一个进程的崩溃不会影响整个系统。\n简化编程：程序员只需关心统一的虚拟地址空间，无需关心物理内存的具体布局。\n内核的内存管理子系统负责分配和回收物理内存页，并在进程切换时负责切换页表基地址寄存器（如x86的CR3）。\n5. 进程间通信（IPC, Inter-Process Communication） 进程之间需要协作，但由于内存隔离，它们不能直接访问对方的地址空间。内核提供了多种进程间通信（IPC） 机制来安全地传递数据：\n管道（Pipe）：单向字节流，常用于父子进程。\n消息队列（Message Queue）：内核维护的消息链表。\n共享内存（Shared Memory）：效率最高的方式。内核将同一块物理内存映射到多个进程的虚拟地址空间中。\n信号（Signal）：一种异步通知机制，用于通知进程某个事件已发生（如kill命令）。\n信号量（Semaphore） 和 互斥锁（Mutex）：用于同步对共享资源的访问，防止竞争条件。\n所有这些机制都由内核提供和管理，确保了通信的安全性和可靠性。\n6. 系统调用：进程与内核的接口 用户进程运行在用户态，权限受限。当它需要请求内核的服务（如创建进程、读写文件、申请内存）时，必须通过系统调用（System Call）。\n系统调用是用户进程主动陷入内核的唯一方式。过程如下：\n进程在寄存器中设置好系统调用号和参数。\n执行一条特殊的指令（如syscall或int 0x80），触发软中断。\nCPU切换到内核态，跳转到内核中预先定义好的系统调用处理函数。\n内核验证请求合法性后，代表进程执行所需操作。\n操作完成，内核将结果返回给进程，并切换回用户态。\n创建新进程的fork()和加载新程序的execve()，本身就是两个最重要的系统调用。\n总结：内核如何管理进程 内核通过一个精巧的体系来管理进程：\n用PCB描述进程：为每个进程创建一个task_struct作为管理元数据。\n用状态机管理生命周期：跟踪每个进程处于创建、就绪、运行、阻塞、退出等状态。\n用调度器分配CPU：通过上下文切换和分时复用，实现CPU的虚拟化。\n用页表隔离内存：为每个进程提供独立的虚拟地址空间，实现内存的虚拟化和保护。\n用IPC机制 Facilitate 协作：提供管道、共享内存等机制，让隔离的进程能安全通信。\n用系统调用提供接口：作为用户进程请求内核服务的唯一入口，保证安全和可控。\n最终，内核像一位交响乐指挥家，协调着各个进程（乐手），合理分配硬件资源（乐器），让整个系统（乐团）和谐、高效地运行。\n","date":"2025-09-06T00:00:00Z","permalink":"https://zhangquanhua1.github.io/p/%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E7%9A%84/","title":"内核是如何管理进程的"},{"content":"总体概览 加载并执行一个新程序的过程可以概括为以下几步：\n外壳（Shell）解析命令并准备参数。\nfork()：创建一个新的子进程。这个子进程几乎是父进程（如 Shell）的完美复制品。\nexecve()：在子进程上下文中执行“程序替换”。这是魔法发生的地方：内核停止当前子进程的运行，清空其内存空间（除了一些保留信息），然后将指定的可执行文件加载到该内存空间中，并为其设置全新的运行环境。\n动态链接器（如果必要）介入，加载程序所依赖的共享库。\n程序开始执行，从 main() 函数开始。\n整个过程的核心是 execve() 系统调用。下图描绘了这个过程的完整流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 flowchart TD A[用户在Shell中输入命令] --\u0026gt; B[\u0026#34;Shell解析命令调用fork()创建子进程\u0026#34;] B --\u0026gt; C[子进程调用execve系统调用] C --\u0026gt; D[\u0026#34;内核处理execve()请求\u0026#34;] subgraph D[内核处理流程] D1[验证文件权限格式等] --\u0026gt; D2[释放旧地址空间\u0026lt;br\u0026gt;拆毁旧世界] D2 --\u0026gt; D3[加载可执行文件\u0026lt;br\u0026gt;ELF解析映射文本/数据段等] D3 --\u0026gt; D4[\u0026#34;设置新堆栈\u0026lt;br\u0026gt;填充参数argv、环境变量envp\u0026#34;] D4 --\u0026gt; D5[设置寄存器\u0026lt;br\u0026gt;将eip指向入口点] end D --\u0026gt; E{\u0026#34;是否为动态链接程序?\u0026#34;} E -- 是 --\u0026gt; F[\u0026#34;载入解释器(ld-linux)\u0026#34;\u0026lt;br\u0026gt;由解释器加载所需共享库] E -- 否 --\u0026gt; G[跳转到程序入口点_start] F --\u0026gt; G G --\u0026gt; H[\u0026#34;执行用户程序的main()函数\u0026#34;] H --\u0026gt; I[程序正常执行] 详细过程分析 第1步：Shell 的工作（用户空间） 当你在 Shell 中输入 ./my_program arg1 arg2 后：\nShell 解析命令，将 \u0026quot;my_program\u0026quot;, \u0026quot;arg1\u0026quot;, \u0026quot;arg2\u0026quot; 分别存储起来。\nShell 调用 fork() 系统调用，创建一个几乎是自身副本的子进程。\n第2步：fork() - 创建进程胚子（内核空间） fork() 系统调用被执行，CPU 陷入内核。\n内核创建一个新的进程描述符（task_struct），为其分配一个新的 PID。\n内核复制父进程的几乎所有资源给子进程，包括：\n内存空间：通过写时复制（Copy-on-Write, COW）技术，创建一个当前和父进程完全一样的地址空间映射（但实际物理内存页暂时共享）。\n打开的文件描述符表：子进程也继承了父进程打开的文件（stdin, stdout, stderr等）。\n进程上下文（寄存器状态等）。\n现在，系统中有了两个几乎一样的进程：父进程（Shell）和子进程。它们都从 fork() 返回开始执行。fork() 对父进程返回子进程的 PID，对子进程返回 0。代码可以通过返回值判断自己是父是子。\n第3步：execve() - 魔法核心（从用户空间到内核空间） 在子进程中，Shell 的子进程副本会调用 execve() 系统调用，其原型大致如下：\nint execve(const char *filename, char *const argv[], char *const envp[]);\nfilename：要加载的程序路径（\u0026quot;/home/user/my_program\u0026quot;）。\nargv：参数数组（{\u0026quot;my_program\u0026quot;, \u0026quot;arg1\u0026quot;, \u0026quot;arg2\u0026quot;, NULL}）。\nenvp：环境变量数组。\n一旦调用 execve()，内核就开始执行以下繁重的工作：\na. 验证与准备\n检查文件 filename 是否存在、是否具有可执行权限。\n读取文件的头部（Header），识别其格式（例如 ELF、Mach-O、PE）。\nb. “拆毁旧世界” - 释放旧地址空间\n内核释放子进程当前拥有的几乎所有资源（内存、信号处理函数等）。由于之前用的是写时复制，所以实际复制的物理内存页很少，释放代价低。\n注意：这里会处理一些例外，比如明确设置为“执行时关闭”（close-on-exec）的文件描述符会被保留，这是进程间通信的重要手段。\nc. “建立新世界” - 加载新程序\n解析可执行文件：以最常见的 ELF 格式为例，内核会解析程序头表（Program Header Table），找到需要加载的段（Segment），如：\n.text 段（代码段）：映射到内存的只读可执行区域。\n.data 段（已初始化数据）：映射到内存的可读写区域。\n.bss 段（未初始化数据）：映射到初始为零的可读写区域。\n映射到内存：内核并不急于将文件内容全部读入物理内存，而是基于内存映射（mmap） 机制，建立虚拟地址到文件偏移的映射关系。只有当程序实际访问某块内存时，才会通过缺页中断（Page Fault） 将对应的文件内容加载到物理内存。这是懒加载（Lazy Loading），非常高效。\n加载解释器（动态链接器）：如果程序是动态链接的（绝大多数都是），ELF 文件中会指定一个“解释器”（Interpreter），通常是 /lib64/ld-linux-x86-64.so.2。内核会先将这个动态链接器本身加载到进程的地址空间并映射。\nd. 设置新堆栈和寄存器\n设置新堆栈：内核为进程分配新的用户态堆栈，并将 argv 和 envp 中的参数和环境变量字符串压入（或放置到）堆栈的特定位置。\n设置寄存器：在进程的内核栈中准备一个新的上下文环境。最关键的是：\n将 指令指针（EIP/RIP） 设置为新程序的入口点（Entry Point）。对于静态链接的程序，入口点就是程序本身的 _start。对于动态链接的程序，入口点是动态链接器的入口点。\n将 栈指针（ESP/RSP） 指向新设置的用户堆栈的顶部。\n第4步：返回用户空间，开始执行 当 execve() 系统调用在内核中完成所有准备工作后：\n内核将精心准备的新上下文恢复到 CPU 寄存器。\nCPU 切换回用户态。\n根据设置好的指令指针（EIP/RIP），开始执行代码。\n现在有两种情况：\n情况A：程序是静态链接的\nCPU 直接从程序的 _start 符号开始执行。_start 是程序真正的起点，由它来初始化运行环境，最后调用 main() 函数。 情况B：程序是动态链接的（绝大多数）\nCPU 首先跳转到动态链接器（ld.so） 的入口点。\n动态链接器开始工作：\n它检查程序依赖哪些共享库（如 libc.so.6）。\n通过 mmap() 将这些共享库也加载到进程的地址空间。\n执行重定位（Relocation） 操作，修正程序中所有对共享库函数（如 printf）的引用地址（将占位符替换为实际加载的地址）。\n执行共享库的初始化代码。\n最后，动态链接器跳转到原始程序的 _start 入口点。\n第5步：执行 main() 函数 无论是否经过动态链接，最终控制权都会交到程序本身的 _start 函数。这个函数是由编译器提供的，它负责：\n设置全局变量。\n初始化标准库。\n将 argv 和 argc 从堆栈中取出，准备好参数。\n调用用户编写的 main(int argc, char *argv[]) 函数。\n至此，你的 main 函数终于被调用，程序开始执行你写的代码。\n总结 步骤 关键动作 执行者 1. Shell解析 解析命令，获取参数 Shell (用户态) 2. fork() 创建子进程副本 内核 3. execve() 系统调用，陷入内核 子进程 -\u0026gt; 内核 4. 内核处理 验证文件、释放旧空间、映射新程序、设置堆栈和寄存器 内核 5. 动态链接 加载并链接共享库 动态链接器 ld.so (用户态) 6. 程序启动 运行 _start，调用 main() 用户程序 所以，main 函数的加载和执行是内核与动态链接器（如果需要）协同工作的结果，是一个“先破后立”的过程：先通过 execve() 清空当前进程的环境，再为其注入一个全新的程序生命。\n","date":"2025-09-06T00:00:00Z","permalink":"https://zhangquanhua1.github.io/p/%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%96%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B/","title":"加载一个新程序的过程"},{"content":"一、股票类型相关名词 • A股：人民币普通股票，境内公司发行，境内投资者以人民币交易。实行“T+1”交易和涨跌幅限制。\n• B股：人民币面值、外币交易，在上交所或深交所上市的外资股。交收周期较长（历史上多为T+3），有涨跌幅限制。\n• H股：内地注册公司在香港联合交易所上市的股票（常称国企股）。“T+0”交易，无涨跌幅限制。\n• N股：在中国大陆注册、于纽约交易所或纳斯达克上市的外资股。“T+0”交易，无涨跌幅限制。\n• S股：主要业务在中国大陆、在新加坡交易所上市的中资背景公司股票。“T+0”交易，交易所设有涨跌幅限制。\n• 普通股：享有表决权、分红权、剩余财产分配权，股息不固定。\n• 优先股：分红优先、清算优先，通常无或有限表决权，股息率相对固定。\n• 原始股：公司上市前发行给核心管理层、员工或机构的股份。\n• 蓝筹股：业绩稳健、规模较大、分红稳定的龙头型公司股票。\n• 红筹股：境外注册、在港上市，由中资机构实际控制的公司股票。\n• 白马股：长期业绩优良、成长性较明确、风险相对较低的股票。\n• 龙头股：行业内具有显著带动效应、对板块走势有示范作用的股票。\n• 绩优股：历史业绩优秀、未来预期稳健但高成长性有限的股票。\n• 垃圾股：基本面差、风险较高的公司股票。\n• 成长股：处于高成长阶段、利润增速较高的公司股票。\n• 冷门股：成交量小、流动性弱、价格波动较小的股票。\n• 概念股：受某一政策或热点概念驱动而被市场关注的股票。\n• 行业股：按照主营业务划分在同一行业板块内的股票。\n二、投资市场相关名词 • 一级市场：证券发行市场，进行新股发行与认购，不允许自由交易。\n• 二级市场：已发行证券的流通转让市场，包括上交所、深交所、北交所等集中交易市场与场外市场。\n• 第三市场：由非交易所会员在场外交易所上市证券的市场（如银行信托部等参与）。\n• 第四市场：机构或大户绕开交易所与经纪商，直接通过网络撮合交易的市场。\n• 北向资金：通过沪/深股通流入A股的港资与外资。\n• 南下资金：内地资金通过港股通流入香港市场的资金。\n• 熊市（空头）：价格长期下行、预期偏悲观的市场环境。\n• 牛市（多头）：价格长期上行、预期偏乐观的市场环境。\n• 牛皮市：价格长时间窄幅波动，缺乏趋势。\n• 利多/利空：分别指有利于上涨/下跌的因素或消息。\n三、股票分析相关名词与指标 • 基本面：宏观环境与公司经营、财务、治理、竞争力等基本情况。\n• 技术面：价格与量能衍生的形态、趋势与技术指标。\n• 天地板：盘中先涨停后跌停。\n• 地天板：盘中先跌停后涨停。\n• 涨停/跌停：当日价格波动的最高/最低限制价。\n• 换手率：一定期间成交量占流通股本比例。公式：换手率＝成交量／流通股本×100%。\n• 筹码集中度：流通筹码在部分账户或价位区间的集中程度。\n• 市盈率（PE）：股价/每股净利润；较低通常意味着估值较低（需结合行业）。\n• 市净率（PB）：股价/每股净资产；常用于金融、周期品等估值参考。\n• 市销率（PS）：股价/每股销售收入；适用于早期、高成长或亏损公司比较。\n• 股息率：每股股息/股价；衡量分红回报。\n• 每股收益（EPS）：净利润/总股本。\n• 估值扩展指标：PEG（PE/利润增速）、EV/EBITDA 等。\n• K线：由开盘、收盘、最高、最低构成，反映区间价格波动。\n• 均线（MA）：一定期间收盘价的移动平均，如5/10/20/60/120/250日。\n• MACD：由DIF、DEA、柱状图与零轴构成，反映趋势强弱与拐点。\n• KDJ：反映超买超卖与短期拐点。\n• OBV：将成交量方向与价格变动结合，观察量价配合。\n• BIAS：价格相对均线的偏离程度。\n• RSI：一定期间上涨幅度占总波动幅度的比例。\n• BRAR：BR重收盘价，AR重开盘价，反映市场人气与意愿。\n• BOLL（布林带）：以上轨/中轨/下轨刻画波动区间（常以20日均线与标准差计算）。\n• 内盘/外盘：分别为以买一价成交的被动卖出量/以卖一价成交的主动买入量。\n• 缩量/放量：与前期相比，成交量减少为“缩量”，增加为“放量”。\n四、交易基础与竞价机制 • 交易时间（A股）：\n9:15–9:25 开盘集合竞价（9:20–9:25不可撤单） 9:30–11:30、13:00–15:00 连续竞价 14:57–15:00 收盘集合竞价（主板/科创/创业板） • 竞价规则：\n集合竞价：以最大成交量原则确定开/收盘价；未成交部分转入连续竞价。 连续竞价：价格优先、时间优先撮合成交。 • 涨跌幅限制（以交易所最新规定为准）：\n主板：一般为±10%；ST类股票一般为±5%。 创业板/科创板：一般为±20%。 新股上市前5个交易日通常不设涨跌幅限制（设有盘中临停机制）。 • T+1/T+0：\nA股股票一般“T+1”卖出；资金与交收“T+1/ T+2”结算。 港股、美股多为“T+0”回转交易。 • 临时停牌（盘中）：\n因异常波动、重大事项、或新股上市盘中价格稳定机制触发而临停。 • 盘后交易：\n15:00–15:30 盘后固定价格交易（部分板块适用）。 十、委托与订单类型 • 限价委托：指定价格或更优价格成交，未成交部分挂单等待。\n• 市价委托（A股常见变种）：\n最优五档即时成交剩余撤销（FOK局部变体）：与对手方前五档即时成交，剩余撤单。 最优五档即时成交剩余转限价（IOC转限价）：即时成交后，剩余部分以成交均价或对手价挂为限价单。 本方最优价格：以本方队列最优价申报，提高成交概率。 对手方最优价格：以对手方队列最优价申报，追求即时成交。 注：具体可用的市价类型以交易所与券商支持为准。 • 有效期：A股场内委托为当日有效，收盘未成交自动失效；不支持GTC（长期有效）。\n十一、申报单位与价格最小变动 • 价格最小变动价位（Tick）：多数股票为0.01元；北交所、可转债等以交易所规则为准。\n• 申报数量单位：\n股票：一般以“手”为单位，1手=100股。 可转债：1手=10张（面值通常100元/张）。 ETF：多为1手=100份，部分货币ETF可能不同。 • 零股交易：\n卖出可出现“非整手”（如剩余不足100股），允许一次性卖出；买入通常需整手。 盘后固定价格交易与北交所等对零股规则可能不同，以最新规定为准。 十二、撤单、订单状态与撮合优先级 • 撤单规则：\n开盘集合竞价：9:15–9:20可撤，9:20–9:25不可撤。 连续竞价：委托未成交可随时撤单（不含临停等特殊时段）。 收盘集合竞价：14:57–15:00一般不可撤单。 • 常见订单状态：已报、部成、全成、已撤、废单（价格/数量无效、账户限制等）。\n• 撮合优先级：价格优先、时间优先；同价位按排队时间先后成交。\n十三、资金可用与结算时间线 • 卖出回款：\n当日卖出后，资金通常“可用不可取”；次日结算后可取（以券商资金规则为准）。 • 买入与卖出：\n买入后当日不得卖出（T+1）；可转债、部分基金等品种可能为T+0，以规则为准。 • 分红派息与配股缴款：资金及股份到位时间以公告与结算机构安排为准。\n十四、融资融券基础 • 定义：\n融资：向券商借钱买入标的证券，负债计息。 融券：借入标的证券卖出（做空），到期需买券归还并支付费用。 • 标的与门槛：需开通信用账户、风险评估达标，标的证券由交易所定期调整。\n• 风险要点：\n保证金比例与维持担保比例，低于维保线可能被平仓。 利息与费率成本、价格波动与流动性风险。 十五、盘后交易与大宗交易补充 • 盘后固定价格交易：\n15:00–15:30 以当日收盘价撮合；仅限限价委托，部分板块或证券支持。 • 大宗交易（Block Trade）：\n适用于大额交易，场外协议达成、场内申报过户，价格区间与最小成交数量有规定。 对二级市场即时价格影响较小，但可能传递供需与机构动向信息。 十六、IPO申购与配售基础 • 申购条件：\n需持有相应市值（以T-2日账户持有为准），不同板块市值门槛不同。 • 申购流程：\n公告日查看代码与申购上限 → 申购日按代码与数量下单 → 中签公布后按时缴款。 • 配售与中签：\n采取摇号/配号机制，按市值获得配号，中签概率与市值、发行规模等相关。 • 上市首日：\n前5个交易日通常不设涨跌幅限制（有临停），注意流动性与波动风险。 五、账户与常见投资品种 • 账户类型：\n普通账户：交易沪深主板、北交所等。 信用账户：融资融券（需风险评估与权限开通）。 科创板与创业板权限：满足条件后单独开通。 港股通权限：满足资产条件后开通。 • 常见品种：\nETF/LOF：场内基金（ETF）与可场内外申赎/交易的基金（LOF）。 封闭式基金、指数基金、主动型基金。 可转债：债券与期权性兼具，可按约定条件转换为股票。 新股申购：满足条件可按市值申购，配售中签后缴款。 优先股、存托凭证（CDR）、公募REITs（不动产投资信托）。 六、公司行为与除权除息 • 常见公司行为：分红、送股、转增、配股、并购重组、股份回购等。\n• 除权/除息：\n除息：派发现金股利后股价相应向下调整。 除权：送股或转增后因股本扩大，股价相应按比例下调。 • 简化计算：\n现金分红后参考价 ≈ 除权前收盘价 − 每股现金分红。 送/转增后参考价 ≈ 除权前收盘价 ÷（1 + 送转比例）。 实际以交易所与登记结算机构披露为准。 七、费用、税费与结算 • 佣金：按成交金额的一定比例收取，券商间差异较大（设有最低收费）。\n• 过户费：沪市股票按成交金额一定比例收取；深市股票目前多不收（以最新规则为准）。\n• 交易经手费与监管费：按交易所/监管机构标准收取。\n• 印花税：卖出股票单边征收，税率以最新国家规定为准。\n• 结算：A股采用中国结算的集中登记与资金证券交收体系，通常T+1/T+2完成清算交收。\n八、交易术语补充 • 筹码：投资者持有的股票数量。\n• 吸筹/建仓：资金在某价位区间持续买入、建立头寸。\n• 洗盘：通过短期打压或震荡清洗不稳定持仓。\n• 出货：在高位或利好刺激下分批卖出实现收益。\n• 护盘：为稳定价格进行买入维稳的行为。\n• 崩盘/跳水：短时间内价格快速大幅下跌。\n• 高开/低开/平开：当日开盘价高于/低于/等于昨日收盘价。\n• 套牢：买入后价格持续下跌而暂时亏损无法卖出的状态。\n• 盘整：价格在一定区间内横向波动。\n九、股票字母标识与特别标记 • N：新股上市首日加“N”，次日取消。\n• C：上市第2–5日标注“C”，第6日取消。\n• R：可融资融券。\n• kr：科创板可融资融券（k=科创，r=融资融券）。\n• U：科创板尚未盈利企业；首次实现盈利后取消。\n• W：同股不同权（表决权差异安排）；不再适用时取消。\n• V：协议控制架构（VIE等）或类似特殊安排；不再适用时取消。\n• G：指数贡献度视图入口（“贡”）。\n• L：存在关联品种（B股、可转债、H股、权证等）。\n• XR：已除权，买入后不再享有送股/转增等权利。\n• XD：已除息，买入后不再享有当期派息权利。\n• DR：除权除息，买入后不再享有送股与派息权利。\n• ST：连续两个会计年度亏损等特殊情形的特别处理。\n• *ST：存在退市风险的特别处理与警示。\n• PT：已退市或进入退市整理阶段的股票。\n• NST：重组或股改后恢复上市的ST股。\n• SZ/SH/BJ：分别代表深交所/上交所/北交所上市。\n——\n","date":"2025-09-04T22:55:17+08:00","permalink":"https://zhangquanhua1.github.io/p/%E9%9B%86%E4%B8%AD%E7%AB%9E%E4%BB%B7%E4%B8%8E%E8%BF%9E%E7%BB%AD%E7%AB%9E%E4%BB%B7/","title":"集中竞价与连续竞价"},{"content":"核心比喻 集中竞价：像 \u0026ldquo;集体投票，一锤定音\u0026rdquo;。大家先各自出价，但都不交易，等到一个特定时刻，系统找一个能让最多交易成交的价格，统一按这个价格成交。\n连续竞价：像 \u0026ldquo;自由市场，随到随谈\u0026rdquo;。买卖双方你挂一个买单，我挂一个卖单，价格合适就立刻成交，交易是连续不断进行的。\n一、集中竞价 集中竞价发生在两个特定的时间段，其目的是为了产生一个公平的、能反映市场集中意愿的开盘价或收盘价。\n1. 发生时间：\n开盘集合竞价：每个交易日的 9:15 - 9:25\n收盘集合竞价：每个交易日的 14:57 - 15:00 （注意：目前仅深圳证券交易所、创业板、科创板采用，上海证券交易所的收盘价是最后一笔连续竞价的成交价）\n2. 核心规则与过程：\n收集申报：在以上时间段内，投资者可以提交或撤销买卖委托（但9:20-9:25之间只能提交，不能撤销）。\n不立即成交：在此期间，所有的报单只会被系统收集，并不会真正成交。\n集中撮合：在时间点结束时（9:25或15:00），交易系统的电脑主机将所有有效的买卖申报一次性集中撮合。\n成交价确定原则：这个\u0026quot;唯一价格\u0026quot;必须同时满足以下三个条件（优先级从高到低）：\n最大成交量原则：在这个价格下，所能成交的股票数量最多。\n高于该价格的所有买盘和低于该价格的所有卖盘都能全部成交。\n与该价格相同的买卖双方中有一方申报全部成交。\n3. 举个例子（开盘集合竞价）：\n假设某股票前收盘价为10.00元。在9:15-9:25期间，大家纷纷挂单：\n有人愿以10.10元买入500手\n有人愿以10.05元买入800手\n有人愿以10.00元买入1000手\n有人愿以10.00元卖出600手\n有人愿以10.05元卖出700手\n有人愿以10.10元卖出900手\n系统会尝试10.10元、10.05元、10.00元等多个价格，计算在每个价格下能成交多少手。最终发现，在10.05元这个价格时，能实现的成交量最大（例如800手）。那么，10.05元就被确定为当日的开盘价。所有符合条件（买单价≥10.05元，卖单价≤10.05元）的委托单都按10.05元成交。\n4. 特点总结：\n价格唯一：形成一个统一的价格（开盘价/收盘价）。\n时间驱动：到点了才统一处理。\n防止操纵：收盘集合竞价能有效防止在收盘最后一刻通过大幅拉抬或打压股价来操纵收盘价的行为。\n二、连续竞价 连续竞价是交易日中最主要的交易方式，我们平时看盘时的实时价格波动就是在连续竞价中产生的。\n1. 发生时间：\n早市：9:30 - 11:30 （开盘集合竞价结束后立即开始）\n午市：13:00 - 14:57 （对于有收盘集合竞价的深市等）\n2. 核心规则：\n价格优先：较高的买进申报优先于较低的买进申报；较低的卖出申报优先于较高的卖出申报。\n时间优先：同价位的申报，谁先提交订单（挂单早），谁就优先成交。\n3. 成交过程：\n新进入的买单会与卖单队列中价格最低的卖单（卖一）比较。\n新进入的卖单会与买单队列中价格最高的买单（买一）比较。\n只要报单价格匹配（买价 ≥ 卖价），就立即成交。\n4. 举个例子：\n假设某股票实时五档行情为：\n卖五 \u0026hellip; 10.10\n卖四 \u0026hellip; 10.09\n","date":"2025-09-04T22:55:17+08:00","permalink":"https://zhangquanhua1.github.io/p/%E9%9B%86%E4%B8%AD%E7%AB%9E%E4%BB%B7%E4%B8%8E%E8%BF%9E%E7%BB%AD%E7%AB%9E%E4%BB%B7/","title":"集中竞价与连续竞价"}]