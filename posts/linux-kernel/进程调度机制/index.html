<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux内核进程调度机制详解 | 我的博客</title><meta name=keywords content="进程调度,调度器,内核开发,系统编程"><meta name=description content="深入解析Linux内核的进程调度机制，包括调度策略、调度器实现和性能优化"><meta name=author content><link rel=canonical href=https://zhangquanhua1.github.io/posts/linux-kernel/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://zhangquanhua1.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhangquanhua1.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhangquanhua1.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zhangquanhua1.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zhangquanhua1.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://zhangquanhua1.github.io/posts/linux-kernel/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://zhangquanhua1.github.io/posts/linux-kernel/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="我的博客"><meta property="og:title" content="Linux内核进程调度机制详解"><meta property="og:description" content="深入解析Linux内核的进程调度机制，包括调度策略、调度器实现和性能优化"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-22T10:00:00+08:00"><meta property="article:modified_time" content="2025-01-22T10:00:00+08:00"><meta property="article:tag" content="进程调度"><meta property="article:tag" content="调度器"><meta property="article:tag" content="内核开发"><meta property="article:tag" content="系统编程"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux内核进程调度机制详解"><meta name=twitter:description content="深入解析Linux内核的进程调度机制，包括调度策略、调度器实现和性能优化"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zhangquanhua1.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Linux内核进程调度机制详解","item":"https://zhangquanhua1.github.io/posts/linux-kernel/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux内核进程调度机制详解","name":"Linux内核进程调度机制详解","description":"深入解析Linux内核的进程调度机制，包括调度策略、调度器实现和性能优化","keywords":["进程调度","调度器","内核开发","系统编程"],"articleBody":"Linux内核进程调度机制详解 概述 进程调度是操作系统的核心功能之一，负责决定哪个进程在何时使用CPU资源。Linux内核的调度器经过多次演进，从O(1)调度器到CFS（完全公平调度器），不断优化调度性能和公平性。\n调度器的基本概念 1. 调度目标 公平性：\n每个进程都有机会获得CPU时间 避免进程饥饿现象 效率性：\n减少调度开销 提高系统吞吐量 响应性：\n交互式进程快速响应 实时进程及时处理 2. 调度策略 SCHED_NORMAL：\n普通进程的默认策略 基于时间片轮转 SCHED_FIFO：\n先进先出实时调度 高优先级进程优先执行 SCHED_RR：\n轮转实时调度 同优先级进程轮流执行 SCHED_BATCH：\n批处理调度 适合CPU密集型任务 SCHED_IDLE：\n空闲调度 只在系统空闲时运行 CFS调度器详解 1. 核心思想 CFS（Completely Fair Scheduler）基于虚拟运行时间的概念：\n虚拟运行时间 = 实际运行时间 / 进程权重 公平性保证：\n所有进程的虚拟运行时间应该相等 权重高的进程获得更多CPU时间 2. 红黑树实现 CFS使用红黑树来维护可运行进程：\nstruct rb_root cfs_rq-\u003etasks_timeline; struct rb_node *rb_leftmost; 插入操作：\n按虚拟运行时间排序 最左边的节点是下一个要运行的进程 删除操作：\n进程运行后从树中删除 重新计算虚拟运行时间后重新插入 3. 时间片分配 动态时间片：\n基于系统负载动态调整 避免固定时间片的问题 最小粒度：\n防止频繁切换 保证调度效率 调度器实现细节 1. 调度队列 struct cfs_rq { struct load_weight load; unsigned long nr_running; u64 min_vruntime; struct rb_root tasks_timeline; struct rb_node *rb_leftmost; struct sched_entity *curr; struct sched_entity *next; }; 2. 调度实体 struct sched_entity { struct load_weight load; struct rb_node run_node; struct list_head group_node; unsigned int on_rq; u64 exec_start; u64 sum_exec_runtime; u64 vruntime; u64 prev_sum_exec_runtime; }; 3. 调度函数 pick_next_task()：\nstatic struct task_struct *pick_next_task_fair(struct rq *rq) { struct cfs_rq *cfs_rq = \u0026rq-\u003ecfs; struct sched_entity *se; se = pick_next_entity(cfs_rq); if (!se) return NULL; return task_of(se); } 实时调度 1. RT调度器 优先级管理：\n实时进程优先级高于普通进程 优先级范围：1-99（数字越大优先级越高） 调度策略：\nSCHED_FIFO：抢占式，直到主动让出CPU SCHED_RR：时间片轮转，同优先级轮流执行 2. 抢占机制 内核抢占：\n允许高优先级进程抢占低优先级进程 提高实时性能 用户抢占：\n从内核态返回用户态时检查 确保实时进程及时响应 负载均衡 1. 多核调度 负载分布：\n将进程分散到不同CPU核心 避免单个核心过载 NUMA感知：\n考虑内存访问延迟 优先在本地节点调度 2. 负载迁移 主动迁移：\n定期检查负载分布 主动迁移进程平衡负载 被动迁移：\n进程唤醒时选择合适CPU 避免热点CPU 性能优化 1. 缓存友好 CPU亲和性：\n进程倾向于在同一CPU上运行 提高缓存命中率 NUMA优化：\n内存分配与CPU节点匹配 减少跨节点访问 2. 调度开销优化 快速路径：\n常见情况快速处理 减少不必要的计算 延迟敏感：\n交互式进程优先调度 减少响应延迟 调试和监控 1. 调度统计 /proc/schedstat：\n调度器运行统计 负载均衡信息 /proc/sched_debug：\n详细调度信息 调试调度问题 2. 性能分析 perf sched：\n调度事件分析 性能瓶颈识别 ftrace：\n调度函数跟踪 实时性能监控 总结 Linux内核的进程调度机制是一个复杂而精密的系统：\nCFS调度器：保证公平性和效率 实时调度：满足实时性要求 负载均衡：充分利用多核资源 性能优化：减少调度开销 理解调度机制对于系统编程和性能优化都是非常重要的基础知识。\n","wordCount":"226","inLanguage":"en","datePublished":"2025-01-22T10:00:00+08:00","dateModified":"2025-01-22T10:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zhangquanhua1.github.io/posts/linux-kernel/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zhangquanhua1.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zhangquanhua1.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zhangquanhua1.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://zhangquanhua1.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://zhangquanhua1.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://zhangquanhua1.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://zhangquanhua1.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Linux内核进程调度机制详解</h1><div class=post-meta><span title='2025-01-22 10:00:00 +0800 +0800'>January 22, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;226 words</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#linux%e5%86%85%e6%a0%b8%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3 aria-label=Linux内核进程调度机制详解>Linux内核进程调度机制详解</a><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=调度器的基本概念>调度器的基本概念</a><ul><li><a href=#1-%e8%b0%83%e5%ba%a6%e7%9b%ae%e6%a0%87 aria-label="1. 调度目标">1. 调度目标</a></li><li><a href=#2-%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5 aria-label="2. 调度策略">2. 调度策略</a></li></ul></li><li><a href=#cfs%e8%b0%83%e5%ba%a6%e5%99%a8%e8%af%a6%e8%a7%a3 aria-label=CFS调度器详解>CFS调度器详解</a><ul><li><a href=#1-%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3 aria-label="1. 核心思想">1. 核心思想</a></li><li><a href=#2-%e7%ba%a2%e9%bb%91%e6%a0%91%e5%ae%9e%e7%8e%b0 aria-label="2. 红黑树实现">2. 红黑树实现</a></li><li><a href=#3-%e6%97%b6%e9%97%b4%e7%89%87%e5%88%86%e9%85%8d aria-label="3. 时间片分配">3. 时间片分配</a></li></ul></li><li><a href=#%e8%b0%83%e5%ba%a6%e5%99%a8%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82 aria-label=调度器实现细节>调度器实现细节</a><ul><li><a href=#1-%e8%b0%83%e5%ba%a6%e9%98%9f%e5%88%97 aria-label="1. 调度队列">1. 调度队列</a></li><li><a href=#2-%e8%b0%83%e5%ba%a6%e5%ae%9e%e4%bd%93 aria-label="2. 调度实体">2. 调度实体</a></li><li><a href=#3-%e8%b0%83%e5%ba%a6%e5%87%bd%e6%95%b0 aria-label="3. 调度函数">3. 调度函数</a></li></ul></li><li><a href=#%e5%ae%9e%e6%97%b6%e8%b0%83%e5%ba%a6 aria-label=实时调度>实时调度</a><ul><li><a href=#1-rt%e8%b0%83%e5%ba%a6%e5%99%a8 aria-label="1. RT调度器">1. RT调度器</a></li><li><a href=#2-%e6%8a%a2%e5%8d%a0%e6%9c%ba%e5%88%b6 aria-label="2. 抢占机制">2. 抢占机制</a></li></ul></li><li><a href=#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1 aria-label=负载均衡>负载均衡</a><ul><li><a href=#1-%e5%a4%9a%e6%a0%b8%e8%b0%83%e5%ba%a6 aria-label="1. 多核调度">1. 多核调度</a></li><li><a href=#2-%e8%b4%9f%e8%bd%bd%e8%bf%81%e7%a7%bb aria-label="2. 负载迁移">2. 负载迁移</a></li></ul></li><li><a href=#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96 aria-label=性能优化>性能优化</a><ul><li><a href=#1-%e7%bc%93%e5%ad%98%e5%8f%8b%e5%a5%bd aria-label="1. 缓存友好">1. 缓存友好</a></li><li><a href=#2-%e8%b0%83%e5%ba%a6%e5%bc%80%e9%94%80%e4%bc%98%e5%8c%96 aria-label="2. 调度开销优化">2. 调度开销优化</a></li></ul></li><li><a href=#%e8%b0%83%e8%af%95%e5%92%8c%e7%9b%91%e6%8e%a7 aria-label=调试和监控>调试和监控</a><ul><li><a href=#1-%e8%b0%83%e5%ba%a6%e7%bb%9f%e8%ae%a1 aria-label="1. 调度统计">1. 调度统计</a></li><li><a href=#2-%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 aria-label="2. 性能分析">2. 性能分析</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=linux内核进程调度机制详解>Linux内核进程调度机制详解<a hidden class=anchor aria-hidden=true href=#linux内核进程调度机制详解>#</a></h1><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><p>进程调度是操作系统的核心功能之一，负责决定哪个进程在何时使用CPU资源。Linux内核的调度器经过多次演进，从O(1)调度器到CFS（完全公平调度器），不断优化调度性能和公平性。</p><h2 id=调度器的基本概念>调度器的基本概念<a hidden class=anchor aria-hidden=true href=#调度器的基本概念>#</a></h2><h3 id=1-调度目标>1. 调度目标<a hidden class=anchor aria-hidden=true href=#1-调度目标>#</a></h3><p><strong>公平性</strong>：</p><ul><li>每个进程都有机会获得CPU时间</li><li>避免进程饥饿现象</li></ul><p><strong>效率性</strong>：</p><ul><li>减少调度开销</li><li>提高系统吞吐量</li></ul><p><strong>响应性</strong>：</p><ul><li>交互式进程快速响应</li><li>实时进程及时处理</li></ul><h3 id=2-调度策略>2. 调度策略<a hidden class=anchor aria-hidden=true href=#2-调度策略>#</a></h3><p><strong>SCHED_NORMAL</strong>：</p><ul><li>普通进程的默认策略</li><li>基于时间片轮转</li></ul><p><strong>SCHED_FIFO</strong>：</p><ul><li>先进先出实时调度</li><li>高优先级进程优先执行</li></ul><p><strong>SCHED_RR</strong>：</p><ul><li>轮转实时调度</li><li>同优先级进程轮流执行</li></ul><p><strong>SCHED_BATCH</strong>：</p><ul><li>批处理调度</li><li>适合CPU密集型任务</li></ul><p><strong>SCHED_IDLE</strong>：</p><ul><li>空闲调度</li><li>只在系统空闲时运行</li></ul><h2 id=cfs调度器详解>CFS调度器详解<a hidden class=anchor aria-hidden=true href=#cfs调度器详解>#</a></h2><h3 id=1-核心思想>1. 核心思想<a hidden class=anchor aria-hidden=true href=#1-核心思想>#</a></h3><p>CFS（Completely Fair Scheduler）基于虚拟运行时间的概念：</p><pre tabindex=0><code>虚拟运行时间 = 实际运行时间 / 进程权重
</code></pre><p><strong>公平性保证</strong>：</p><ul><li>所有进程的虚拟运行时间应该相等</li><li>权重高的进程获得更多CPU时间</li></ul><h3 id=2-红黑树实现>2. 红黑树实现<a hidden class=anchor aria-hidden=true href=#2-红黑树实现>#</a></h3><p>CFS使用红黑树来维护可运行进程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> rb_root cfs_rq<span style=color:#f92672>-&gt;</span>tasks_timeline;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> rb_node <span style=color:#f92672>*</span>rb_leftmost;
</span></span></code></pre></div><p><strong>插入操作</strong>：</p><ul><li>按虚拟运行时间排序</li><li>最左边的节点是下一个要运行的进程</li></ul><p><strong>删除操作</strong>：</p><ul><li>进程运行后从树中删除</li><li>重新计算虚拟运行时间后重新插入</li></ul><h3 id=3-时间片分配>3. 时间片分配<a hidden class=anchor aria-hidden=true href=#3-时间片分配>#</a></h3><p><strong>动态时间片</strong>：</p><ul><li>基于系统负载动态调整</li><li>避免固定时间片的问题</li></ul><p><strong>最小粒度</strong>：</p><ul><li>防止频繁切换</li><li>保证调度效率</li></ul><h2 id=调度器实现细节>调度器实现细节<a hidden class=anchor aria-hidden=true href=#调度器实现细节>#</a></h2><h3 id=1-调度队列>1. 调度队列<a hidden class=anchor aria-hidden=true href=#1-调度队列>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> cfs_rq {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> load_weight load;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> nr_running;
</span></span><span style=display:flex><span>    u64 min_vruntime;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> rb_root tasks_timeline;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> rb_node <span style=color:#f92672>*</span>rb_leftmost;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>curr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=2-调度实体>2. 调度实体<a hidden class=anchor aria-hidden=true href=#2-调度实体>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> sched_entity {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> load_weight load;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> rb_node run_node;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> list_head group_node;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> on_rq;
</span></span><span style=display:flex><span>    u64 exec_start;
</span></span><span style=display:flex><span>    u64 sum_exec_runtime;
</span></span><span style=display:flex><span>    u64 vruntime;
</span></span><span style=display:flex><span>    u64 prev_sum_exec_runtime;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=3-调度函数>3. 调度函数<a hidden class=anchor aria-hidden=true href=#3-调度函数>#</a></h3><p><strong>pick_next_task()</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> task_struct <span style=color:#f92672>*</span><span style=color:#a6e22e>pick_next_task_fair</span>(<span style=color:#66d9ef>struct</span> rq <span style=color:#f92672>*</span>rq)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> cfs_rq <span style=color:#f92672>*</span>cfs_rq <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>rq<span style=color:#f92672>-&gt;</span>cfs;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sched_entity <span style=color:#f92672>*</span>se;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    se <span style=color:#f92672>=</span> <span style=color:#a6e22e>pick_next_entity</span>(cfs_rq);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>se)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>task_of</span>(se);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=实时调度>实时调度<a hidden class=anchor aria-hidden=true href=#实时调度>#</a></h2><h3 id=1-rt调度器>1. RT调度器<a hidden class=anchor aria-hidden=true href=#1-rt调度器>#</a></h3><p><strong>优先级管理</strong>：</p><ul><li>实时进程优先级高于普通进程</li><li>优先级范围：1-99（数字越大优先级越高）</li></ul><p><strong>调度策略</strong>：</p><ul><li>SCHED_FIFO：抢占式，直到主动让出CPU</li><li>SCHED_RR：时间片轮转，同优先级轮流执行</li></ul><h3 id=2-抢占机制>2. 抢占机制<a hidden class=anchor aria-hidden=true href=#2-抢占机制>#</a></h3><p><strong>内核抢占</strong>：</p><ul><li>允许高优先级进程抢占低优先级进程</li><li>提高实时性能</li></ul><p><strong>用户抢占</strong>：</p><ul><li>从内核态返回用户态时检查</li><li>确保实时进程及时响应</li></ul><h2 id=负载均衡>负载均衡<a hidden class=anchor aria-hidden=true href=#负载均衡>#</a></h2><h3 id=1-多核调度>1. 多核调度<a hidden class=anchor aria-hidden=true href=#1-多核调度>#</a></h3><p><strong>负载分布</strong>：</p><ul><li>将进程分散到不同CPU核心</li><li>避免单个核心过载</li></ul><p><strong>NUMA感知</strong>：</p><ul><li>考虑内存访问延迟</li><li>优先在本地节点调度</li></ul><h3 id=2-负载迁移>2. 负载迁移<a hidden class=anchor aria-hidden=true href=#2-负载迁移>#</a></h3><p><strong>主动迁移</strong>：</p><ul><li>定期检查负载分布</li><li>主动迁移进程平衡负载</li></ul><p><strong>被动迁移</strong>：</p><ul><li>进程唤醒时选择合适CPU</li><li>避免热点CPU</li></ul><h2 id=性能优化>性能优化<a hidden class=anchor aria-hidden=true href=#性能优化>#</a></h2><h3 id=1-缓存友好>1. 缓存友好<a hidden class=anchor aria-hidden=true href=#1-缓存友好>#</a></h3><p><strong>CPU亲和性</strong>：</p><ul><li>进程倾向于在同一CPU上运行</li><li>提高缓存命中率</li></ul><p><strong>NUMA优化</strong>：</p><ul><li>内存分配与CPU节点匹配</li><li>减少跨节点访问</li></ul><h3 id=2-调度开销优化>2. 调度开销优化<a hidden class=anchor aria-hidden=true href=#2-调度开销优化>#</a></h3><p><strong>快速路径</strong>：</p><ul><li>常见情况快速处理</li><li>减少不必要的计算</li></ul><p><strong>延迟敏感</strong>：</p><ul><li>交互式进程优先调度</li><li>减少响应延迟</li></ul><h2 id=调试和监控>调试和监控<a hidden class=anchor aria-hidden=true href=#调试和监控>#</a></h2><h3 id=1-调度统计>1. 调度统计<a hidden class=anchor aria-hidden=true href=#1-调度统计>#</a></h3><p><strong>/proc/schedstat</strong>：</p><ul><li>调度器运行统计</li><li>负载均衡信息</li></ul><p><strong>/proc/sched_debug</strong>：</p><ul><li>详细调度信息</li><li>调试调度问题</li></ul><h3 id=2-性能分析>2. 性能分析<a hidden class=anchor aria-hidden=true href=#2-性能分析>#</a></h3><p><strong>perf sched</strong>：</p><ul><li>调度事件分析</li><li>性能瓶颈识别</li></ul><p><strong>ftrace</strong>：</p><ul><li>调度函数跟踪</li><li>实时性能监控</li></ul><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>Linux内核的进程调度机制是一个复杂而精密的系统：</p><ol><li><strong>CFS调度器</strong>：保证公平性和效率</li><li><strong>实时调度</strong>：满足实时性要求</li><li><strong>负载均衡</strong>：充分利用多核资源</li><li><strong>性能优化</strong>：减少调度开销</li></ol><p>理解调度机制对于系统编程和性能优化都是非常重要的基础知识。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhangquanhua1.github.io/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/>进程调度</a></li><li><a href=https://zhangquanhua1.github.io/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/>调度器</a></li><li><a href=https://zhangquanhua1.github.io/tags/%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91/>内核开发</a></li><li><a href=https://zhangquanhua1.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/>系统编程</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zhangquanhua1.github.io/>我的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>